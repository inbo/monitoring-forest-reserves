---
title: "Update forresdat 5 - vegetatie"
author: "Anja Leyman"
date: "`r Sys.Date()`"
output: 
  html_document:
    keep_md: FALSE
    number_sections: yes
    fig_caption: yes
    code_folding: hide
    toc: TRUE
    toc_float:
      collapsed: yes
      smooth_scroll: yes
---

```{r Rm, eval = FALSE}
rm(list=ls())
```

```{r Setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  eval = FALSE,  # FALSE: dan kan ik knitten zonder dat er iets gebeurt
  message = FALSE,
  warning = FALSE, 
  fig.width = 9,
  fig.align = TRUE)

library(here)

# libraries & invoergegevens & functions
source(here::here("scripts/Setup.R"))

```


```{r Setup2}
path_to_html_teamdrive <- paste0(path_to_dataverwerking_teamdrive, "25_Overkoepelend")
```

> juiste forrescalc kiezen:   
- om weg te schrijven naar forresdat - branch main => met juiste release van het package: dan `install.packages("forrescalc")`  
- laatste correcties van forrescalc => juiste branch selecteren in forrescalc en opnieuw builden - wegschrijven kan naar forresdat - branch "develop"
(10/3/25: branch 'bugfix' met corr van read_forresdat waarbij we de develop branch kunnen selecteren ipv main)

```{r forrescalc_to_write_to_forresdat, eval = FALSE}
# !!! eerst zeker 'install.packages("forrescalc")
# zodat forresdat-data goede release krijgt!
# zie mail 7/10/24 van Els L.
# soms een andere branch nodig als Els nog iets moet fixen, maar als ik naar forresdat 
# wil wegschrijven, moet ik officiële versie van forrescalc gebruiken

install.packages("forrescalc")

```


# Vraagstelling
DOEL van dit script is een update van forresdat gegevens naar 

- forresdat-folder als tsv (nadien nog te pushen naar github)
- BR_analysedb.accdb
- output-folders "_plot-level-data" en "_tree-level-data" als csv
- gdrive-folders "_plot-level-data" en "_tree-level-data" als csv

Kersselaerspleyn blijkt op meerdere vlakken uitzonderingen te bevatten.
Deze uitzonderingen worden na het inladen van de data gecorrigeerd. 


```{r results='hold', eval=TRUE}
path_to_forresdat_data
path_to_analysis_set_db
path_to_plotlevel_csv
path_to_treelevel_csv
path_to_output_gdrive
path_to_meetgegevens

```


# Load plotinfo

Plotinfo inladen: `plottype`, naam `forest_reserve` en info over survey's.
(plotinfo op gdrive en forresdat: enkel processed plots!)

```{r }
# mbv forresdat
# plotinfo <- read_forresdat(file = "plotinfo", root = path_to_forresdat_data)
# names(plotinfo)
# ?read_forresdat

# van c-schijf
plotinfo <- read.csv2(paste0(path_to_plotlevel_csv, "plotinfo.csv")) %>% 
  select(-1)

```


# Load lookuplijsten

```{r load_lkp}
con <- odbcConnectAccess2007(path_to_fieldmap_db)

  qHerbSpecies240810<- sqlFetch(con, "qHerbSpecies240810", stringsAsFactors = FALSE)
  qCoverHerbs <- sqlFetch(con, "qCoverHerbs", stringsAsFactors = FALSE)
  qBrowsIndex <- sqlFetch(con, "qBrowsIndex", stringsAsFactors = FALSE)
  
odbcClose(con)

```


# Load vegetation - OK - 19/1/2023 - 18/3/2025

```{r load_veg}
data_vegetation <-
  load_data_vegetation(
    database = path_to_fieldmap_db,
    processed = TRUE
  )
data_herblayer <-
  load_data_herblayer(
    database = path_to_fieldmap_db,
    processed = TRUE
  )


```

# Calculate

```{r}
vegetation <- calculate_vegetation(data_vegetation, data_herblayer)
```


```{r CreateSeparateDataframesVeg}
for (tablename in names(vegetation)) {
     assign(tablename, vegetation[[tablename]])
} 

```


# Controle plot-level-data

```{r}
data_vegetation %>% filter(plot_id == 1176 & period == 1)
data_herblayer %>% filter(plot_id == 1176)
data_herblayer %>% filter(plot_id == 1176 & period == 1)

veg_by_plot %>% filter(plot_id == 1176 & period == 1)

```


# Check NA's

```{r results='hide'}
names(veg_by_plot)
summary(veg_by_plot)
# veel covers niet ingevuld ...
```

```{r}
col <- c("number_of_species", "cumm_herb_coverage_class_average_perc")

veg_by_plot %>% filter_at(col, any_vars(is.na(.))) %>% 
  filter(number_of_species != 0) %>% nrow() == 0
# 122 met cumm_herb_coverage_class_average_perc = NA, allemaal aantal soorten = 0

```

Doordat in herblayer een record met species = NA wordt toegevoegd voor elke plot waar een opname gebeurd
is, zijn er hier rare NA's


Op te lossen is alvast feit dat bij bv plot 41000 (species = NA MAAR browsing is 100)
wegens load_data_herblayer:
 IIf(Herb.browse_index_id IS NULL AND pd.GameImpactVegObserved = 10,
             100, Herb.browse_index_id) AS browse_index_id,
             
daar zou extra vwdde moeten zijn dat er een soort is?
anderzijds bij percentage browing misschein wel ok


Dan zijn er 2 plots waar tijdens 1e set niet alle subplots opgemeten werden, 
waardoor er 40 subplots zijn met soort = NA én jaart al = NA


(11000: ook 40 plots met species = AN, maar daar wel een jaartal => dat duidt onderscheid met waar
dan wél een opname gebeurd is)

Op te kuisen!!!
            
```{r}
names(veg_by_core_area_species)

col <- c("number_of_subplots_with_species", "perc_of_subplots", "mean_coverage_class_average_perc")

t <- veg_by_core_area_species %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0
# 4 records met mean_coverage_class_average_perc = NA wegens species = NA

t1 <- data_herblayer %>% filter(plottype == "CA" & is.na(species))
# bv. 11000 - periode 1: 750 subplots 


# bv. plot 41000: species = NA en browsing ;s 100
# wegens load_data_herblayer:
# IIf(Herb.browse_index_id IS NULL AND pd.GameImpactVegObserved = 10,
#             100, Herb.browse_index_id) AS browse_index_id,

# 31000 en 43000: 40 subplots zodnder species peroide 1 = omdat ze niet opgemeten zijn
# jaartal is ook NA

# 11000: idem, maar daar is wel een jaartal ingevuld?

t2 <- data_herblayer %>% filter(plottype == "CP" & is.na(species))

```

# TEMP: browse_index niet ingevuld: NA ipv 100 (no browsing)

!! browse_index : NA in herblayer_by_plot, terwijl het 100 (= no browsing) zou moeten zijn (game_impact_veg  = TRUE bij plotinfo )

!! heeft te maken met onvolledig aanvullen van FM-DC: NA zou 100 moeten worden bij voorafgaandelijke datacontrole

? bij welke bosreservaten komt dit voor? 
Enkel 31000 41000 43000 (Hannecart en Rodebos)

> Hierna tijdelijke correctie (gevraagd aan Peter 17/1/2023)

```{r}
check_brows_0 <- data_herblayer %>% 
  left_join(plotinfo %>% select(plot_id, period, game_impact_veg)) %>% 
  filter(is.na(browse_index_id)) %>% 
  filter(game_impact_veg == TRUE) 
           
table(check_brows_0$plot_id, check_brows_0$period)
#           2    3
#   21000 1112    0
#   31000    0  491
#   41000    0  907
#   43000    0  687
```

```{r corr_browseindex_NA}
data_herblayer_ <- data_herblayer %>% 
  left_join(plotinfo %>% select(plot_id, period, game_impact_veg),
            by = c("plot_id", "period")) %>% 
  mutate(browse_index_id = ifelse(is.na(browse_index_id) & game_impact_veg == TRUE,
                                  100,
                                  browse_index_id)) %>% 
  select(-game_impact_veg)


data_herblayer <- data_herblayer_
```

> Na correctie data_herblayer ook veg_by_core_area_species opnieuw laten berekenen
(de andere plot-level-resultaten mbt vegetatie zijn OK, daar komt browsing niet in voor)

```{r corr_browseindex_CA}
check_CA_browsing <- veg_by_core_area_species %>% 
  left_join(plotinfo %>% select(plot_id, period, game_impact_veg),
            by = c("plot_id", "period")) %>% 
  filter(is.na(perc_of_subplots_browsed)) %>% 
  filter(game_impact_veg == TRUE) 

table(check_CA_browsing$plot_id, check_CA_browsing$period)  
  #       2  3
  # 21000 29  0
  # 31000  0 49
  # 41000  0 29
  # 43000  0 56

# herberekenen met gecorrigeerde data_herblayer
data_herblayer_CA <- data_herblayer %>%
    filter(.data$plottype == "CA")

veg_by_core_area_species_ <- calculate_vegetation_core_area_species(data_herblayer_CA)

veg_by_core_area_species <- veg_by_core_area_species_

```

> Alle vegetatie-resultaten terug in een lijst stoppen

```{r combine_veg}
vegetation_ <- list(
      veg_by_plot = veg_by_plot,
      veg_by_core_area_species = veg_by_core_area_species
    )

vegetation <- vegetation_
```



# TEMP controle KV Zoniën KERN_1983 - OPGELOST

In de kernvlakte "Zoniën KERN_1983" werden slechts in 710 van de 750 subplots effectief soorten 
genoteerd. Dus 40 subplots zonder kruidlaag. 
 <!-- (< monitoringrapport 2000: "In eerste instantie werden de 710 niet-lege opnamen  -->
 <!-- (i.c. zonder kruidlaag) door TWINSPAN geanalyseerd") -->

Initieel werd `n_subplots` fout berekend bij periode 1: 710 ipv 750 (2eset wel OK, 140)
19/3/2025: opgelost door aan herblayer ook de lege subplots toe te voegen (species = NA), 
<!-- bij "query_herblayer" wordt immers vertrokken van plots en vegetation-layer,  -->
<!-- met een left_join van herblayer -->

```{r eval=FALSE}
by_core_area_species <- data_herblayer %>%
    group_by(.data$plot_id, .data$period, .data$plottype) %>%
    mutate(
      n_subplots = n_distinct(.data$subplot_id))

t3 <- by_core_area_species %>% 
  filter(plot_id == 11000 & is.na(species) & period == 1)
nrow(t3) == 40 
unique(t3$n_subplots) == 750

# Forrescalc-code:

# calculate_vegetation_core_area_species <- function(data_herblayer, data_vegetation) {
#   by_core_area_species <- data_herblayer %>%
#     group_by(.data$plot_id, .data$period) %>%
#     mutate(
#       n_subplots = n_distinct(.data$subplot_id))

# load_data_herblayer <- ...
#  query_herblayer <- ....
        #  FROM ((((Plots
        #           INNER JOIN PlotDetails_%1$deSet pd ON Plots.ID = pd.IDPlots)
        #           INNER JOIN Vegetation%2$s Veg ON Plots.ID = Veg.IDPlots)
        #           LEFT JOIN (
        #             SELECT Herblayer.IDPlots,
```

```{r check_n_subplots_veg, eval = FALSE}
# controle n_subplots door runnen van deel van de functie -> OK!!
table(by_core_area_species$n_subplots)
# 1    10    34    50    98   105   140   750 
# 30312   441   653 11253 28567  6163  2285  4570

```

```{r check_veg_Kerss_KV, eval = FALSE}
check_Kerss <- veg_by_core_area_species %>% 
  filter(plot_id == 11000)

veg_by_core_area_species %>% 
  filter(plot_id == 11000 & species == 71)  # beuk
# period = 2, zelfde resultaat als dataverwerking 2010 - OK
# 123 subpolots -	 0,879 perc_subplots - 0.9 mean_coverage_class_average_perc 

```

Resultaten stemmen overeen met dataverwerking uit 2012.



# Export vegetation

```{r join_plotinfo_veg}
veg_plotinfo <- lapply(vegetation, function(x) left_join(x, plotinfo %>% select(plot_id, forest_reserve, plottype, period, survey_number), by = c("plot_id", "period")))
# lapply: same function over all elements of the list
```


```{r save_veg_git, eval = FALSE}
# geen plotinfo naar git
save_results_forresdat(
  results = vegetation,
  repo_path = path_to_git_forresdat,
  metadata_path = paste0(path_to_metadata, "_metadata_plotlevel_results_veg.xlsx"),
  push = FALSE,
  strict = TRUE,
  branch = "develop"
)
```

```{r save_veg_git_manueel, eval = FALSE}
# manueel - eigen simpele functie - als save_results_git niet werkt
save_results_tsv(vegetation, 
                 root = path_to_forresdat_data, 
                 strict = FALSE)
```


```{r save_veg_access_csv, eval = FALSE}
# volgende functie heb ik zelf geschreven, zit niet in het package!
save_results_csv (
    results = veg_plotinfo,
    output_dir = path_to_plotlevel_csv
    )

# afgerond voor export naar access
# de df's van CP mogen op 0 afgerond worden (= 1ste drie dataframes)
# de KV's op 2 cijfers na de komma

round_df <- function(df, digits) {
  df[] <- lapply(df, function(x) if(is.numeric(x)) round(x, digits) else x)
  return(df)
}

veg_round <- veg_plotinfo %>% 
  lapply(., function(x) round_df(x, 2))

# save_results_access (
#   results = veg_round,
#   database = path_to_analysis_set_db,
#   remove_tables = TRUE
#   )

# Functie "save_results_access" (< package) geeft problemen met dates => hierna manueel
veg_by_plot <- veg_by_plot %>% 
  mutate(date_vegetation = as.Date(gsub(' SAST','',date_vegetation))) 
  # gsub (SAST) is om tijdzone weg te halen, anders wordt een dag vroeger weergegeven


con <- odbcConnectAccess2007(path_to_analysis_set_db)

# veg_by_plot
dbtables <- sqlTables(con)
if ("veg_by_plot" %in% dbtables$TABLE_NAME) {
        sqlDrop(con, "veg_by_plot")
      }
sqlSave(con, dat = veg_by_plot, tablename = "veg_by_plot", varTypes = c(date_vegetation="datetime"))


# veg_by_core_area_species
dbtables <- sqlTables(con)
if ("veg_by_core_area_species" %in% dbtables$TABLE_NAME) {
        sqlDrop(con, "veg_by_core_area_species")
      }
sqlSave(con, dat = veg_by_core_area_species, tablename = "veg_by_core_area_species")

odbcClose(con)
```



Direct naar gdrive exporteren (csv): 
naar **/PRJ_BOSECO_ALGEMEEN/PRJ_BR_AanvraagGegevens/!METADATA-ALL_PLOTS/_plot-level-data/**

```{r save_veg_gdrive, eval = FALSE}
save_results_csv(
    results = veg_plotinfo,
    output_dir = path_to_plotlevel_gdrive
    )

```


# Export herblayer - OK - 19/1/2023

Ook herblayer naar forresdat wegschrijven

```{r select_variables}
names(data_herblayer)

con <- odbcConnectAccess2007(path_to_fieldmap_db)
qBrowsIndex <- sqlFetch(con, "qBrowsIndex")
# qCoverHerbs <- sqlFetch(con, "qCoverHerbs")
odbcClose(con)

herblayer <- data_herblayer %>%
  select(plot_id, subplot_id, period, 
         date_vegetation, year, 
         species, coverage_class_average_perc, 
         browse_index_id) %>%
  left_join(qBrowsIndex %>% select(ID, Value2), by = c("browse_index_id" = "ID")) %>% 
  rename(browse_index = Value2) %>% 
  # mutate(date_vegetation = as.Date(date_vegetation)) 
  # !! r as.Date returns previous day 
  mutate(date_vegetation = as.Date(gsub(' SAST','',date_vegetation))) 
  # Which will remove the timezone from part of the string and then convert to date.

# save_results_xxxx: gemaakt om list weg te schrijven
# hier maar één dataframe
herblayer_list <- list(herblayer_by_plot = herblayer)
herblayer_list_git <- list(herblayer_by_plot = herblayer %>% select(-browse_index))
# summary(herblayer)

```


```{r join_plotinfo_herb}
herb_plotinfo <- lapply(herblayer_list, function(x) left_join(x, plotinfo %>% select(plot_id, forest_reserve, plottype, period, survey_number), by = c("plot_id", "period")))
# lapply: same function over all elements of the list

```


```{r save_herb_git, eval = FALSE}
# geen plotinfo naar git
save_results_forresdat(
  results = herblayer_list_git,
  repo_path = path_to_git_forresdat,
  metadata_path = paste0(path_to_metadata, "_metadata_plotlevel_results_veg.xlsx"),
  push = FALSE,
  strict = TRUE,
  branch = "develop"
)

# check: echt niet veranderd??
# check <- read_vc(file = "herblayer_by_plot", root = path_to_forresdat_data)
# check %>% filter(plot_id == 41000 & period == 3 & browse_index_id == 100)
# herblayer %>% filter(plot_id == 41000 & period == 3 & browse_index_id == 100)
```

```{r save_herb_git_manueel, eval = FALSE}
# manueel - eigen simpele functie - als save_results_git niet werkt
save_results_tsv(herblayer_list_git, 
                 root = path_to_forresdat_data, 
                 strict = FALSE)
```


```{r save_herb_access_csv, eval = FALSE}
# volgende functie heb ik zelf geschreven, zit niet in het package!
save_results_csv (
    results = herb_plotinfo,
    output_dir = path_to_plotlevel_csv
    )

# afgerond voor export naar access
herb_round <- herb_plotinfo %>% 
  lapply(., function(x) round_df(x, 2))

# save to access nog steeds niet opgelost, is alsof access date niet herkent
# => manueel gedaan (csv opgeslagen als xlsx en dan geïmporteerd; csv gaf zelfd eproblemen als access)
        # save_results_access(
        #   results = herb_[1],
        #   database = path_to_analysis_set_db,
        #   remove_tables = TRUE
        # )

# probleem met datumvelden => varTypes aanduiden
con <- odbcConnectAccess2007(path_to_analysis_set_db)

dbtables <- sqlTables(con)
if ("herblayer_by_plot" %in% dbtables$TABLE_NAME) {
        sqlDrop(con, "herblayer_by_plot")
      }
# sqlSave(con, dat = herblayer, tablename = "herblayer_by_plot", fast = FALSE)
sqlSave(con, dat = herb_round[[1]], tablename = "herblayer_by_plot", varTypes = c(date_vegetation="datetime"))

odbcClose(con)

```

Direct naar gdrive exporteren (csv): 
naar **/PRJ_BOSECO_ALGEMEEN/PRJ_BR_AanvraagGegevens/!METADATA-ALL_PLOTS/_plot-level-data/**

```{r save_herb_gdrive, eval = FALSE}
save_results_csv(
    results = herb_plotinfo,
    output_dir = path_to_plotlevel_gdrive
    )

```


**Na update van forresdat, project "forresdat" openen en alles naar de cloud pushen**
**Eventueel ook access op gdrive plaatsen**


# Copy html to teamdrive

Na knitting - manueel

```{r eval = FALSE}
# Specify the path of the file you want to copy
source_file <- here::here(paste0("Scripts/OpbouwDatabank/Main_UpdateForresdat_05_vegetation.html"))

# Specify the destination directory where you want to copy the file
destination_dir <- path_to_html_teamdrive

# Copy the file to the destination directory
file.copy(from = source_file, to = destination_dir, overwrite = TRUE)
# ? file.copy
```
