---
title: "Update forresdat"
author: "Anja Leyman"
date: "`r Sys.Date()`"
output: 
  html_document:
    keep_md: FALSE
    number_sections: yes
    fig_caption: yes
    code_folding: hide
    toc: TRUE
    toc_float:
      collapsed: yes
      smooth_scroll: yes
---


```{r Rm, eval = FALSE}
rm(list=ls())
```

```{r Setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  eval = FALSE,  # dan kan ik knitten zonder dat er iets gebeurt
  message = FALSE,
  warning = FALSE, 
  fig.width = 9,
  fig.align = TRUE)

library(here)

# libraries & invoergegevens
source(here::here("scripts/Setup.R"))
source(here::here("scripts/ExtraFunctions.R"))
source(here::here("scripts/ExtraFunctions_volume.R"))
```


# Vraagstelling
DOEL van dit script is een update van forresdat gegevens naar 

- forresdat-folder als tsv (nadien nog te pushen naar github)
- BR_analysedb.accdb
- output-folders "_plot-level-data" en "_tree-level-data" als csv
- gdrive-folders "_plot-level-data" en "_tree-level-data" als csv

```{r results='hold', eval=TRUE}
path_to_forresdat_data
path_to_analysis_set_db
path_to_plotlevel_csv
path_to_treelevel_csv
path_to_output_gdrive
```


# Stand van zaken

## Zero values in een plot (29/11/2022)    

FINAAL: 

bij dendro_by_plot, reg_by_plot en veg_by_plot alle plots opgenomen waar een 
respectievelijke survey gebeurd is, dus ook de plots zonder bomen, reg of veg
(logs_by_decay: daar niet, want welke decaystage kies je dan?)


## jan/2023

- 19/1/2023: rubbing en browsing gecorrigeerd (niet gewacht op correctie van package)
- opp. KV Hannecart en Rodebosfout => correctie
- volume deadwood was fout berekend (enkel obv log ipv als som van log en snag)
- 14/2/2023: tabellen “dendro_by_diam_plot” en “dendro_by_diam_plot_species”: 
diam-klasses 10-15cm/15-20cm/20-25cm/25-30cm/…: “vol_log_m3_ha_min40cm” = NA ipv “0” 



## 22/11/2022

Nog eens alles runnen, met speciale aandacht voor   
- deadw NA ipv 0 correctie (waar geen opnames is: NA ipv een 0)  
- deadw Kerss KV: vanaf 40 cm   
- dendro Kerss KV 1eSET: pas vanaf 30 cm (5-30 cm was enkel subsample => wegfilteren)   
- deadw intact mbv dagnelie  
- plot 475 decade 1: nul toegevoegd - enkel aan dendro_by_plot  
- plots enamebos: biomass = 0 toegevoegd - enkel aan dendro_by_plot  
- reg Kerss KV ! aanpassing nodig want opp in FM-db stemt niet overeen met 
geïnventariseerde opp. voor reg  


## 20/9/2022: NA deadwood Kerss

* een NA in CalcVolume_m3 van deadwood kersselaerspleyn (3eSET) zorgde voor een nulwaarde 
=> Calcvolume bijgewerkt in access (op termijn te programmeren in R) voor fragmenten
(nog 2 intacte bomen in KV 43000, periode 3, die berekend moeten worden mbv Dagnelie)

* plotarea_ha obv lengte$breedte (KV) was een factor 10000 te groot => aangepast in forrescalc

* NA's voor vol_log_m3_ha in dendro_by_plot(_xxx) werden als '0' ingesteld in forrescalc
=> aanpassing gevraagd aan Els (via commit)
=> tijdelijk gecorrigeerd in onderstaand script


## 13/7/2022: reg

* reg_AL aangepast: overal nr_regeneration verwijderd (of nr_established and nr_seedlings)
Immers in approx_nr_reg hebben we zelfde info.
Was verwarrend: werd berekend obv enkel de exacte aantallen, maar als er dan gegroepeerd werd op niveau plot, 
werd geen rekening gehouden met de aantallen uit de intervallen.

Approx_nr_reg: zou steeds obv een aantalsklasse moeten zijn bij seedlings en obv exact aantal bij established => datacontrole
Als allebei, dan wordt aantalsklasse genomen.
Dus dan moet bij de datacontrole gezorgd worden dat bij de established enkel een aantal staat (of enkel een antalsklasse als geen exact aantal gekend is) (is opgenomen in instructies voor datacontrole)


## 8/4/2022: reg

* branch statistics in reg_Al gemerged: alles ivm shoots(iufro, ..) en reg nu normaal in orde
* foutjes in db ook gecorrigeerd
* enkel obv datum en niet meer opnamejaar (opnamejaar wordt enkel nog gebruikt als date niet beschikbaar is)


## 11/3/2022: trees_calc

* tabellen `trees_calc` en `stems_calc`: processed mét correcte tree_id en non-unique tree_id, beide obv coppice waar nodig (= alle CP's en een deel van de KV's die ik vroeger ooit verwerkt heb, maar die nog geen hoogtemodellen hebben)
* `tree_wide`: enkel processed, obv tree_id based on coppice_id
* `trees_calc_non_processed` en `stems_calc_non_processed`: bevatten alle bomen, ook van non-processed plots ==> tree_id obv old_id


## feb-mrt/2022

- 21/2/2022: update nalv correctie coppice-id (+ kleine aanpassing plotinfo)
=> enkel tree level data & plotinfo bijgewerkt  

- 8/3/2022: update dendro nalv nieuwe dh-curves Zonien (Kerss CP&KV, Zwaenep CP, Harras KV) - 
obv branch "statistics_and_other_issues".  

- 9/3/2022: ook tree-id toegevoegd, functie was nog niet in orde, maar licht aangepast  




# Update lookuplijsten - INDIEN GEWIJZIGD

Enkel indien de q-tabellen gewijzigd zijn.
Enkel de gewijzigde tabellen vermelden.

Opnieuw gedaan op 22/11/2022.

## Naar csv

Eerst alle lookuplijsten inladen, dan in een list stoppen en exporteren.


```{r load_lkp}
con <- odbcConnectAccess2007(path_to_fieldmap_db)

  qIndShootCop <- sqlFetch(con, "qIndShootCop", stringsAsFactors = FALSE)
  # deadw_test <- sqlFetch(con, "Deadwood_3eSET", stringsAsFactors = FALSE)
  qAliveDead <- sqlFetch(con, "qAliveDead", stringsAsFactors = FALSE)
  qSpecies <- sqlFetch(con, "qSpecies", stringsAsFactors = FALSE)
  qDecaystage <- sqlFetch(con, "qdecaystage", stringsAsFactors = FALSE)
  qIntactSnag <- sqlFetch(con, "qIntactSnag", stringsAsFactors = FALSE)
  qVdagnVfm <- sqlFetch(con, "qVdagnVfm", stringsAsFactors = FALSE)
    
  qHerbSpecies240810<- sqlFetch(con, "qHerbSpecies240810", stringsAsFactors = FALSE)
  qCoverHerbs <- sqlFetch(con, "qCoverHerbs", stringsAsFactors = FALSE)
  qBrowsIndex <- sqlFetch(con, "qBrowsIndex", stringsAsFactors = FALSE)
  
  qHeightClass_regeneration <- sqlFetch(con, "qHeightClass_regeneration", stringsAsFactors = FALSE)
  qnumber_regeneration_classes <- sqlFetch(con, "qnumber_regeneration_classes", stringsAsFactors = FALSE)
  
  qcommonremark <- sqlFetch(con, "qcommonremark", stringsAsFactors = FALSE)
  qCrownVolRedu <- sqlFetch(con, "qCrownVolRedu", stringsAsFactors = FALSE)
  qBranchLenghtReduction <- sqlFetch(con, "qBranchLenghtReduction", stringsAsFactors = FALSE)

  qiufroheight <- sqlFetch(con, "qiufroheight", stringsAsFactors = FALSE)
  qiufroheight_shoots <- sqlFetch(con, "qiufroheight_shoots", stringsAsFactors = FALSE)
  qiufrovitality <- sqlFetch(con, "qiufrovitality", stringsAsFactors = FALSE)
  qiufrovitality_shoots <- sqlFetch(con, "qiufrovitality_shoots", stringsAsFactors = FALSE)
  qiufrosocialstatus <- sqlFetch(con, "qiufrosocialstatus", stringsAsFactors = FALSE)
  qiufrosocialstatus_shoots <- sqlFetch(con, "qiufrosocialstatus_shoots", stringsAsFactors = FALSE)
  
odbcClose(con)

```

```{r lkplists_to_csv, eval = FALSE}
# list maken van alle lookuplijsten en zo alle lookuplijsten als csv opslaan
list_lkp <- list(qIndShootCop = qIndShootCop, qAliveDead = qAliveDead, qSpecies = qSpecies, 
                 qDecaystage = qDecaystage, qIntactSnag = qIntactSnag, 
                 qVdagnVfm = qVdagnVfm,
                 qCrownVolRedu = qCrownVolRedu, qBranchLenghtReduction = qBranchLenghtReduction,
                 qiufroheight = qiufroheight, qiufroheight_shoots = qiufroheight_shoots,
                 qiufrosocialstatus = qiufrosocialstatus, 
                 qiufrosocialstatus_shoots = qiufrosocialstatus_shoots,
                 qiufrovitality = qiufrovitality, 
                 qiufrovitality_shoots = qiufrovitality_shoots,
                 qHerbSpecies240810 = qHerbSpecies240810, 
                 qCoverHerbs = qCoverHerbs, qBrowsIndex = qBrowsIndex, 
                 qHeightClass_regeneration = qHeightClass_regeneration, 
                 qnumber_regeneration_classes = qnumber_regeneration_classes,
                 qcommonremark = qcommonremark
                 )

names(list_lkp)

# save naar C-schijf
save_results_csv(
    results = list_lkp,
    output_dir = path_to_plotlevel_csv
  )

# save naar gdrive
save_results_csv(
    results = list_lkp,
    output_dir = path_to_plotlevel_gdrive
  )

```


## Rechtstreeks van FM-db naar git 

```{r lulist1, eval = FALSE}
from_access_to_git(
  database = path_to_fieldmap_db,
  tables = c("qAliveDead", "qSpecies", "qHerbSpecies240810", 
             "qHeightClass_regeneration", "qnumber_regeneration_classes", 
             "qdecaystage",
             "qcommonremark", 
             "qiufrosocialstatus", "qiufroheight", "qiufrovitality", 
             "qBrowsIndex", "qCoverHerbs", 
             "qPlotType", 
             "qIntactSnag", "qIndShootCop", "qVdagnVfm",
             "qCrownVolRedu","qBranchLenghtReduction"),
  repo_path = path_to_git_forresdat,
  strict = FALSE
)

# !!!! argument "strict": keep default TRUE to update data without structural changes,
                  #    change to FALSE only if tables are structurally changed
                  #          (e.g. additional column, change in sorting order,...)


# from_access_to_git(
#   database = path_to_fieldmap_db,
#   tables = c("qCoverHerbs"),
#   repo_path = path_to_git_forresdat,
#   strict = FALSE
# )

```


## Vanuit git naar analysedb

```{r lulist2, eval = FALSE}
from_git_to_access(tables = c("qAliveDead", "qSpecies", "qHerbSpecies240810", 
             "qHeightClass_regeneration", "qnumber_regeneration_classes", 
             "qdecaystage",
             "qcommonremark", 
             "qiufrosocialstatus", "qiufroheight", "qiufrovitality", 
             "qBrowsIndex", "qCoverHerbs", 
             "qPlotType", 
             "qIntactSnag", "qIndShootCop", "qVdagnVfm", 
             "qCrownVolRedu","qBranchLenghtReduction"),
                   repo_path = path_to_git_forresdat,
                   database = path_to_analysis_set_db,
             remove_tables = TRUE)

# lookuplijsten niet als csv of xls geëxporteerd, want teveel rompslomp, zit in de access-db

```


## Als git-functies niet werken

```{r lulist_manueel, eval = FALSE}
# list_lkp aangemaakt in hogere chunck, bevat alle LU-lijsten

# één LU_list: 
# list_lkp <- list(qCoverHerbs = qCoverHerbs)

save_results_access (
  results = list_lkp,
  database = path_to_analysis_set_db,
  remove_tables = TRUE
)

# exporteren - tsv - eigen simpele functie
save_results_tsv(list_lkp, 
                 root = path_to_forresdat_data)
```





# Plotinfo - OK - 19/1/2023

## Load plotinfo

Plotinfo samenstellen, zijnde plottype, naam forest_reserve en info over survey en data al dan niet processed.
Wegschrijven naar git, access en opslaan als csv

```{r plotinfo_load}
plotinfo <- load_plotinfo(database = path_to_fieldmap_db)
names(plotinfo)
```

```{r check_processed}
# enkel checken bij deze waar er een dendro-opname gebeurd is
# anders ook deze van vorige decades mee, die niet kunne processed zijn
check_processed <- plotinfo %>% 
  filter(survey_trees == TRUE)

table(check_processed$forest_reserve, check_processed$data_processed)
# table(plotinfo$forest_reserve, plotinfo$data_processed)
```

```{r check_not_processed}
plotinfo_check <- plotinfo %>% 
  group_by(forest_reserve, plottype, period, survey_trees, data_processed) %>% 
  summarize(n_plots = n()) %>% 
  ungroup()

plotinfo_check %>% 
  filter(survey_trees == TRUE & data_processed == FALSE)

# omgekeerd geen plots die processed zijn, en géén survey_trees
plotinfo %>%  filter(data_processed & !survey_trees) %>% nrow() == 0
```

Enkel nog CP's derde set Withoefse heide (dd 13/7/2022), is gepland voor 2023.

Zelf aangepast in dbEls als processed, ook gevraagd aan Peter (OK, gebeurd in dB_Els_deel2_202207141612.zip) :  

- Sevendonck A en Q - 1e & 2e decade
- Liedekerke TR - 1e & 2e decade
- Hannecart - 3e decade
- Rodebos (2 KV's: KV en KV2) - 3e decade



## Export plotinfo

```{r plotinfo_save_git, eval=FALSE}
save_results_git(
  results = list(plotinfo = plotinfo)
  , repo_path = path_to_git_forresdat
  , strict = TRUE
  # , strict = FALSE
)

```

```{r plotinfo_save_git_manueel, eval=FALSE}
# manueel - eigen simpele functie - als save_results_git niet werkt
save_results_tsv(list(plotinfo = plotinfo), 
                 root = path_to_forresdat_data, 
                 strict = TRUE)

```


```{r plotinfo_save_access_csv, eval=FALSE}
save_results_access (
  results = list(plotinfo = plotinfo),
  database = path_to_analysis_set_db,
  remove_tables = TRUE
)

save_results_csv(
    results = list(plotinfo = plotinfo),
    output_dir = path_to_plotlevel_csv
  )

```

Direct naar gdrive exporteren (csv): 
naar **/PRJ_BOSECO_ALGEMEEN/PRJ_BR_AanvraagGegevens/!METADATA-ALL_PLOTS/_plot-level-data/**

```{r plotinfo_save_gdrive, eval = FALSE}
# naar gdrive
save_results_csv(
    results = list(plotinfo = plotinfo),
    output_dir = path_to_plotlevel_gdrive
  )

```

# Dendro - voorlopig OK - 23/1/2023

## Load dendro data

<!-- (Er zijn geen shoots, en ook geen deadwood, reg of veg in Kerss KV 1986) -->

```{r load_dendro1_processed_or_not}
data_dendro <- load_data_dendrometry(database = path_to_fieldmap_db, 
                                     extra_variables = TRUE, 
                                     processed = TRUE)
# 79866 + 2455 = 82321 (rodebos)
# 83171 (22/11/2022)

# ook éénmalig eens non_processed op 11/3/2022 (ook zo weggeschreven): stems en trees
data_dendro_ <- load_data_dendrometry(database = path_to_fieldmap_db,
                                     extra_variables = TRUE,
                                     processed = FALSE)
#86399 - 2455 = 83944 (11/3/2022)
# 84873 (22/11/2022)

t <- data_dendro_ %>% 
  anti_join(data_dendro)
table(t$forest_reserve)
# allemaal With heide

```

```{r load_dendro2}
data_shoots <- load_data_shoots(database = path_to_fieldmap_db, extra_variables = TRUE)

data_stems  <- compose_stem_data(data_dendro, data_shoots, extra_variables = TRUE)

height_model <- load_height_models(path_to_height_models)

data_deadwood <- load_data_deadwood(database = path_to_fieldmap_db, processed = TRUE)
```

```{r check_heightmodels}
table(height_model$forest_reserve, height_model$period)
table(plotinfo$forest_reserve)

height_model %>% group_by(forest_reserve) %>% summarise(n = n()) %>% ungroup() %>% anti_join(plotinfo, by = c("forest_reserve"))
# Rodebos	51	- OK, als algemeen voor beide KV's, niet gelinkt aan een feitelijke KV	
# Rodebos KV	56 - NIET OK!!! - AANGEPAST
# Walenbos	28	- OK, als algemeen voor beide KV's, niet gelinkt aan een feitelijke KV
```

## Deadwood volume bijwerken - OK - 23/11/2022

De volumeberekening van liggend dood hout baseert zich op het veld `calc_volume_m3`
uit FM-databank (layer `Deadwood`).

Indien deadwood als fragment opgemeten werd (zie veld `IntactFragment` en 
bijhorende LU-list `qVdagnVfm`), is dit een kopie van het veld `Volume_m3.`
Dit veld wordt in FM-DC automatisch berekend. 
Belangrijk is om te zorgen dat dit volume als "inside plot" berekend wordt.

Indien deadwood als intact aangevinkt staat, moeten er tarieven gebruikt worden om
dit volume te berekenen.
Er werd afgesproken met Peter dit enkel nog te gebruiken voor de BE's of de KV's  
als ze plotgrens niet overschrijden. 

- Enkel in Kerss KV - 2eSET & 3eSET staan nog (veel) intacte bomen: 
klopt wel degelijk...voor KV KP = BEkartering....
- In 1eSET niks meer (aangevuld met fragmenten - copy van 2eSET - door Peter)
- Héél uitzonderlijk in 3e SET: 2 bomen in KV Rodebos (plot 43000)


### Fragmenten - update in FM

**Elke keer te doen bij nieuwe db**

In Fieldmap zijn er twee velden opgenomen, die "manueel" bijgewerkt moeten worden.
Makkelijkste is om dit hier op te vangen in een updatequery.

Het gaat om de velden 
- `calc_volume_m3`
- `calc_length`

Deze velden zijn exacte copies van de velden 
- `volume_m3` (als IntactFragment = 20)
- `length_m`

Maar omdat deze laatste twee velden per ongeluk gewijzigd kunnen worden in FM-DC 
(te berekenen als "Total Volume" of "Volume inside plot"), is het veiliger om 
deze waardes vast te klikken in `calc_volume_m3` & `calc_length`.

Voor 3de set was `calc_volume_m3` niet steeds berekend (in acces).
Dat doen we hier mbv een updatequery, nadat we zeker zijn dat de waardes correct 
berekend zijn in FM-DC ("inside plot").
Dit moet normaliter enkel gebeuren voor periode 3, periode 1 en 2 zijn bijgewerkt 
in de moederdatabank zelf.

```{r sql_update_calc_deadw_inside_plot, eval = FALSE}
# !! ENKEL UITVOEREN NADAT IN DC "volume inside plot" BEREKEND IS
# data_deadwood_old <- data_deadwood

# layers_deadw <- c("Deadwood", "Deadwood_2eSET", "Deadwood_3eSET")
# 
# for (x in layers_deadw){
# 
# qry_update_calc_vol <- "UPDATE x 
#       LEFT JOIN qVdagnVfm ON x.IntactFragment = qVdagnVfm.ID 
#       SET x.CalcVolume_m3 = [Volume_m3] 
#       WHERE (((x.CalcVolume_m3) Is Null) AND ((x.IntactFragment)=20))"
# 
# qry_update_calc_length <- "UPDATE x 
#       LEFT JOIN qVdagnVfm ON x.IntactFragment = qVdagnVfm.ID 
#       SET x.CalcLength_m = [Length_m] 
#       WHERE ((x.CalcLength_m) Is Null)"
#   
# conn <- odbcConnectAccess2007(path_to_fieldmap_db)
# # conn <- odbcConnectAccess2007(path_to_fieldmap_db), rows_at_time = 1)
# 
# sqlQuery(conn,qry_update_calc_vol)
# sqlQuery(conn,qry_update_calc_length)
# 
# odbcClose(conn)
# }

# enkel deadw_3eSET
qry_update_calc_vol <- paste0("UPDATE Deadwood_3eSET SET Deadwood_3eSET.CalcVolume_m3 = Deadwood_3eSET.Volume_m3 WHERE ((Deadwood_3eSET.CalcVolume_m3 Is Null) AND (Deadwood_3eSET.IntactFragment=20))") %>%
           noquote()

qry_update_calc_length <- "UPDATE Deadwood_3eSET SET Deadwood_3eSET.CalcLength_m = Deadwood_3eSET.Length_m WHERE ((Deadwood_3eSET.CalcLength_m) Is Null)" %>%
           noquote()
  
conn <- odbcConnectAccess2007(path_to_fieldmap_db)

sqlQuery(conn,qry_update_calc_vol)
sqlQuery(conn,qry_update_calc_length)

odbcClose(conn)

# opnieuw inladen
data_deadwood_old <- data_deadwood
data_deadwood <- load_data_deadwood(database = path_to_fieldmap_db, processed = TRUE)


data_deadwood %>% filter(is.na(calc_volume_m3)) %>% nrow()
# 2 (intacte)
```


### Intacte bomen - correctie voorlopig in script

Indien deadwood als intact (veld `IntactFragment`) aangevinkt staat, moeten er 
tarieven gebruikt worden om dit volume te berekenen.

> Issue # 105 aangemaakt in forrescalc. Wordt geïmplementeerd.
Toch nog steeds eens checken of intact-fragment wel klopt!!


Er werd afgesproken met Peter `intact` enkel nog te gebruiken voor de BE's of de KV's  
(als bomen tenminste plotgrens van KV niet overschrijden). 

- Enkel in Kerss KV - 2eSET & 3eSET staan nog (veel) intacte bomen: 
klopt wel degelijk...voor KV KP = BEkartering....
- In 1eSET geen intacte bomen meer (aangevuld met fragmenten - copy van 2eSET - door Peter)
- Héél uitzonderlijk in 3e SET: 2 bomen in KV Rodebos (plot 43000)

In onderstaande code wordt het volume voor intacte bomen (ook indien NIET NA) 
bijgewerkt obv tarieven (stam + kroon), behalve wanneer er een substantieel deel buiten 
de plotgrenzen valt (> 1/2de). 

---- 

Volumes van de twee intacte bomen van **KV Rodebos** (plot 43000) berekenen 
als intacte boom (volledig binnen plot).    

**Kerss KV**: indien "intact" vermeld staat én stam voor meer dan 1/2de binnen de plot ligt.   

!! Soms is min_diameter ook nog vrij hoog, bv. min_diam 300 en max_diam 420 (of 410 en 710).   
In dat geval is het volume berekend als fragment (met twee vrij hoge diameters, en zelfde lengte) 
hoger dan dat van een intacte boom ...   
Daar eventueel toch volume fragment nemen??   
Gevraagd aan Peter wat beste is (mail 23/11/2023)   
**Voorlopig** alles wat decay 13 en 14 is als fragment meenemen.
Peter past ook wel nog aan in databank.
**DUS OP TERMIJN MOET DIE EXTRA FILTER OP DECAYSTAGE EN MIN_DIAM NIET MEER GEBEUREN**


<!-- In 1eSET werd wel nog gebruik gemaakt van intacte bomen. -->
<!-- Peter heeft dit gecheckt: ca 140 bomen van de 4000 in dit geval. -->
<!-- Daarvan veel meer dan de helft sowieso te smal om zware zijtakken (> 10 cm) te hebben.  -->
<!-- Daarenboven ook kroon soms deels buiten CP of KV. -->
<!-- ==> Wellicht zou fout door te werken met enkel fragmenten verwaarloosbaar zijn. -->
<!-- (eventueel eens te checken: volgens Peter enkel KV Pruikenmakers mogelijks afwijking) -->


<!-- 28/11/2019: (c) Peter (zie Trello):   -->
<!-- Aangepast in MDB (update op citrix), alles voor CP's en KV's staat nu op 20 (calc FieldMap),  -->
<!-- dit volgens de besproken werkwijze;  -->
<!-- uiteindelijk werden hiervoor in 7 plots kroontakken uit de 2e set gekopieerd  -->
<!-- naar de 1e Set, afbraak werd op 1 of 2 gezet cfr stam,  -->
<!-- er werd in opmerkingsveld "manueel" genoteerd: -->
<!-- plot 922 : 1 essentak -->
<!-- plot 934 : 1 eikentak -->
<!-- plot 803 : 2 beukentakken -->
<!-- plot 819 : 1 lorkentak -->
<!-- plot 71000 : 4 beukentakken -->
<!-- plot 81000 : 3 eikentakken -->
<!-- plot 12100 : 29 eikentakken (kv pruikemakers)!! -->

<!-- Volumes dood hout kunnen specifiek voor deze plots vgl'en worden met oude berekende data als proef. -->

<!-- Mail Peter 23/11/2022 ivm Kerss KV: -->
<!-- "Nu helemaal gerecapituleerd hoe het zit met dode liggende (zware) bomen kernvlakte Kerselaerspleyn. -->
<!-- Deze werden hermeten in de plot 13100 Natman en mosbomen ifv opstart inventarisatie Glen toen. -->
<!-- Hiervoor werd boomlaag gekopieerd over geheel van Kersselaerspleyn en enkel hermeten/bijgemeten, verkort voor oudere objecten -->
<!-- in de kernvlakte en rond de kernvlakte =bufferzone. Nadien heb ik dan in de plot 11000, de hermeten objecten die voldoen aan de diameter -->
<!-- en volledig of deels binnen de plotsgrens van de kernvlakte liggen ingeladen, vandaar uitzonderlijk hier wel combi intact en afgesneden, -->
<!-- In die natmanbomenplot (13100à zitten/zaten bijvoorbeeld ook bomen met kleine diameters die destijds door onze Ruben werden bemonsterd en een natmanid kregen -->
<!-- en die nu voor Glen zijn werk opnieuw werden bekeken, als ze er nog lagen." -->


```{r posssible_fragment_check, eval = FALSE}
# !! gemerkt dat calc_vol in Kerss KV (plot 11000, 2de en 3de decade) exacte copie 
# is van volume inside plot, terwijl het om intacte bomen gaat
# => volume bijwerken

data_deadwood_intact <- data_deadwood %>% 
  filter(intact_fragm == 10)

# toch nog niet helemaal zoals afgesproken met Peter => file doormailen met mogelijke fragmenten
posssible_fragment <- data_deadwood_intact %>% 
  filter((calc_length_m < total_length_m/2)|
           decaystage == 14|
           (decaystage == 13 & min_diam_mm > 150)) %>% 
  select(plot_id, plottype, forest_reserve, , period, date_dendro, lying_deadw_id,
         species, decaystage, intact_fragm, calc_volume_m3, calc_length_m, total_length_m,
         min_diam_mm, max_diam_mm)

write_csv2(posssible_fragment, here::here("output/posssible_fragment_Kerss_KV.csv"))

```

```{r calc_deadw_intact1}
## TIJDELIK toch nog doen , lijkt nog niet aangepoast in db
data_deadwood_intact_NIET <- data_deadwood %>% 
  filter(intact_fragm == 10 & calc_length_m < total_length_m/2) %>%
  # enkel de weinig vergane met lage_min_diam, rest zijn toch fragmenten
  # afgesproken via mail 24/11/2022 van Peter dat hij dit ook zo gaat aanpassen in moederdb
  filter(decaystage < 13 | (decaystage == 13 & min_diam_mm < 150))


data_deadwood_intact <- data_deadwood %>% 
  filter(intact_fragm == 10 & calc_length_m > total_length_m/2) %>%
  # enkel de weinig vergane met lage_min_diam, rest zijn toch fragmenten
  # afgesproken via mail 24/11/2022 van Peter dat hij dit ook zo gaat aanpassen in moederdb
  filter(decaystage < 13 | (decaystage == 13 & min_diam_mm < 150))
 

# check <- data_deadwood %>% 
#   filter(intact_fragm == 10) %>% 
#   anti_join(data_deadwood_intact)
# check2 <- data_deadwood_intact_ %>% 
#   filter(intact_fragm == 10 & calc_length_m < total_length_m)

data_deadwood_fragm <- data_deadwood %>% 
  anti_join(data_deadwood_intact)

nrow(data_deadwood) == nrow(data_deadwood_intact) + nrow(data_deadwood_fragm)

# tarieven
data_deadwood_intact_ <- my.CalcVolBA(data_deadwood_intact, tarieven2ing, nIngang = 2, 
             varNameDiameter = "max_diam_mm",
             varNameHeight = "calc_length_m")
data_deadwood_intact_ <- my.CalcVolBranches(data_deadwood_intact_, tarieven1ingKroon, 
             varNameDiameter = "max_diam_mm")

data_deadwood_intact_ <- data_deadwood_intact_ %>% 
  mutate(diff_vol = (vol_stem_m3 + vol_crown_m3) - calc_volume_m3,
         diff_vol_proc = 100*diff_vol/calc_volume_m3)
# !! eigenlijk mag dat niet vergeleken worden, want één intacte boom bestaat uit 
# meerdere fragmenten

# !! soms calc_length veel kleiner dan total_length => dan mag intact zeker niet

```


```{r calc_deadw_intact2}
data_deadwood_intact_ <- data_deadwood_intact_ %>% 
  mutate(calc_volume_m3 = ifelse(
    # intact_fragm == 10 & diff_vol > 0,
    # !! ev. alleen maar indien volume intact > volume fragment (dus als diff_vol > 0)
    # NEE: zou opgelost moeten worden door Peter: zijn eigenlijk toch fragmenten
    intact_fragm == 10,
    vol_stem_m3 + vol_crown_m3,
    calc_volume_m3))

names(data_deadwood_intact_)
data_deadwood_intact <- data_deadwood_intact_ %>% 
  select(-(26:30))

data_deadwood <- rbind(data_deadwood_intact, data_deadwood_fragm)
```

```{r check_dead1}
check_deadw <- data_deadwood %>% 
  filter(is.na(calc_volume_m3))
nrow(check_deadw) == 0
# waren er 2, nu 0 (intact, plot 43.000, geprogrammeerd mbv tarieven dagnelie)

# summary(check_deadw$period) # enkel periode 3
# unique(check_deadw$plot_id) # enkel plot 43000 
# plotinfo %>% filter(plot_id %in% check_deadw$plot_id) # Rodebos KV

```

## Staande bomen 1ste decade KV Kersselaerspleyn pas vanaf 30 cm

**Methodiekrapport**:

*Dendrometrics*: 
Full survey of all trees (L+D) with DBH>30cm in 1986-87; revisited in 1991 to
record windthrown trees due to windstorms of february 1991 (Vivian & Wiebke). Volume
calculations with tariffs (Van den Berge et al. 1990; 1992).

In 2000/01 : re-survey of full area, with DBH threshold of 30 cm, trees of 10-30 cm counted,
not positioned; smaller trees not surveyed in full area but in subsamples (see regeneration).

2010 and 2020 : full survey of all trees (L+D) with DBH>5cm.

*Eigen verwerking*: 

Concreet Kersselaerspleyn_IA_KV1986etc_INBO33: bevat alle jaartallen:
	- 1986 (!! Enkel deze die in 2000 nog recht stonden => enkel te gebruiken voor volume-aanwas)
	- 2000 (!! Pas gebiedsdekkend opgemeten vanaf 30 cm DBH => extra filter toevoegen bij de verwerking)
	- 2010


In 2000 werd gebiedsdekkend gemeten vanaf 30 cm DBH, en twee groepen vanaf 5 cm.
Daarnaast streeplijsten: samen met veg in 750 subsamples: 30-20, 20-10 en < 10 cm.
Ev. op termijn te implementeren (zie trello)

<!-- Nog niet op die manier verwerkt, nu dus zelfs fout!!!!! -->
**DAAROM in trees en stems deze < 30 cm wegfilteren zdd we resultaten hebben van levend > 30 cm**
**(cfr dataverwerking in 2012) **

> We gaan ervanuit dat degene die data gebruiken, het methodiekrapport gelezen hebben en dit dus weten.


```{r}
data_stems_<- data_stems %>% 
  filter(plot_id != 11000 | 
           period %in% c(2,3) |
           dbh_mm >= 300)

check <- data_stems %>% 
  anti_join(data_stems_)
table(check$period, check$plot_id)   # ok
  #     11000
  # 1   913
data_stems <- data_stems_

data_dendro_ <- data_dendro %>% 
  filter(plot_id != 11000 | 
           period %in% c(2,3) |
           dbh_mm >= 300)
check <- data_dendro %>% 
  anti_join(data_dendro_)
table(check$period, check$plot_id)   # ok
  #     11000
  # 1   913
data_dendro <- data_dendro_

```


```{r}
check_Kerss <- data_stems %>% 
  filter(plot_id == 11000 & period == 1)
min(check_Kerss$dbh_mm) # 300
```

## KV Kerss 1986 - opgepast

In 1986: in FM werden enkel deze die in 2000 nog recht stonden, ingeladen.  
Dus enkel geschikt voor aanwas-berekeningen, niet om staande voorraad te berekenen.

Kan niet (moeilijk) rechtgezet worden.


## Calculate dendro data

```{r calc_dendro}
data_stems_calc <- calc_variables_stem_level(data_stems, height_model)

data_dendro_calc <- calc_variables_tree_level(data_dendro, data_stems_calc)

dendro <- calculate_dendrometry(data_dendro, data_deadwood, data_shoots, height_model)
```


```{r CreateSeparateDataframesDendro}
for (tablename in names(dendro)) {
     assign(tablename, dendro[[tablename]])
} 

```


## Check NA's

Niet alle NA's moeten door een 0 vervangen worden.
Een NA wijst vaak op een missing value in FM => dat eerst oplossen

> OPGEPAST
> Als in trees layer het veld `ind_sht_cop` = coppice (12)
én de  shoot zit toch niet in de shoots layer
dan wordt een fout gecreëerd in forrescalc (met NA voor volume als gevolg)
DUS BEST MEENEMEN IN DATACONTROLE

> OOK AANDACHT VOOR MISSING DBH OF HEIGHT VAN SNAGS !!!


### Tree-level

```{r check_NA1, eval = FALSE}
col <- c("dbh_mm", "species", "dbh_class_5cm", "calc_height_m", "vol_crown_m3",
         "vol_bole_m3", "vol_tot_m3", "stem_number_alive_ha", "stem_number_dead_ha",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha",
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha",
         "intact_snag", "alive_dead", "ind_sht_cop")
nrow(data_stems_calc  %>%
       filter_at(col, any_vars(is.na(.)))) == 0

col <- c("dbh_mm", "species", "dbh_class_5cm", "calc_height_m",
         "basal_area_m2", "vol_bole_m3", "vol_crown_m3", "vol_tot_m3",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha",
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha",
         "number_of_trees_alive_ha", "number_of_trees_dead_ha")

nrow(data_dendro_calc  %>%
       filter_at(col, any_vars(is.na(.)))) == 0

# names(data_stems_calc)
# names(data_dendro_calc)
# data_stems_NA <- data_stems_calc %>% 
#   filter_at(col, any_vars(is.na(.))) %>%
#   select(plot_id, period,
#          dbh_mm, species, alive_dead, 
#          height_m, calc_height_m, vol_bole_m3, vol_bole_alive_m3_ha,
#          decaystage, intact_snag,
#          ind_sht_cop,
#          contains(c("iufro", "remark"))
#          ) %>% 
#   left_join(plotinfo, by = c("plot_id", "period")) 
```


### Dendro_by_plot 

```{r check_NA2}
col <- c("year", "number_of_tree_species", "number_of_trees_ha", "stem_number_ha",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha", 
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha",
         "vol_log_m3_ha", "vol_deadw_m3_ha", "stems_per_tree")

dendro_by_plot %>% filter_at(col, any_vars(is.na(.)))
# 1 plot: 475


```

Plot 475, periode 1, bevat geen staande bomen, wel liggende.
> Voorlopig '0' van maken, maar moet in package opgelost worden (opgenomen als issue nov 2022).

```{r change_NA2}
dendro_by_plot_ <- dendro_by_plot %>% 
  replace((is.na(.)), 0) %>% 
  mutate(vol_deadw_m3_ha = vol_dead_standing_m3_ha + vol_log_m3_ha)

dendro_by_plot_ %>% filter_at(col, any_vars(is.na(.)))
# OK, geen NA's meer

dendro_by_plot <- dendro_by_plot_
```


### Dendro_by_plot_species 

Foutje in package: op dit moment NA's als soort niet voorkomt staand, maar wel liggend.
Dat moet 0 worden.

> In forrescalc aangeduid als te verbeteren.
> Hierna voorlopig corrigeren

```{r}
col <- c("year", "species", "number_of_trees_ha", "stem_number_ha",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha", 
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha",
         "vol_log_m3_ha", "vol_deadw_m3_ha")

dendro_by_plot_species %>% filter_at(col, any_vars(is.na(.))) %>% nrow()
# 765

check <- dendro_by_plot_species %>% filter_at(col, any_vars(is.na(.)))

# deze moeten allemaal 0 worden
dendro_by_plot_species_ <- dendro_by_plot_species %>% 
  replace((is.na(.)), 0) %>% 
  mutate(vol_deadw_m3_ha = vol_dead_standing_m3_ha + vol_log_m3_ha)

dendro_by_plot_species_ %>% filter_at(col, any_vars(is.na(.))) %>% nrow()
# OK, geen NA's meer

dendro_by_plot_species <- dendro_by_plot_species_
```


### Dendro_by_diam_plot

Foutje in package dat nu gecorrigeerd is (25/11/2022).

```{r}
col <- c("year", "stem_number_alive_ha", "stem_number_dead_ha",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha", 
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha",
         "vol_log_m3_ha")

dendro_by_diam_plot %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0
# 0

# check <- dendro_by_diam_plot %>% filter_at(col, any_vars(is.na(.)))
# 
# dendro_by_diam_plot_ <- dendro_by_diam_plot %>% 
#   replace((is.na(.)), 0)
# 
# dendro_by_diam_plot_ %>% filter_at(col, any_vars(is.na(.))) %>% nrow()
# # OK, geen NA's meer
# 
# dendro_by_diam_plot <- dendro_by_diam_plot_
```


### Dendro_by_diam_plot_species

Idem als voorgaande.

```{r}
col <- c("year", "species", "stem_number_alive_ha", "stem_number_dead_ha",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha", 
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha",
         "vol_log_m3_ha")

dendro_by_diam_plot_species %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0

# check <- dendro_by_diam_plot_species %>% filter_at(col, any_vars(is.na(.)))
# 
# # enkel vol_dead_standing is NA, rest is 0 zoals het zou moeten zijn
# # dit veld moet ook 0 worden
# dendro_by_diam_plot_species_ <- dendro_by_diam_plot_species %>% 
#   replace((is.na(.)), 0)
# 
# dendro_by_diam_plot_species_ %>% filter_at(col, any_vars(is.na(.))) %>% nrow()
# # OK, geen NA's meer
# 
# dendro_by_diam_plot_species <- dendro_by_diam_plot_species_
```



### Logs_by_decay_plot_species

> moet aangepast worden: op termijn zal dit uitgebreid worden met ook het staand dood hout

```{r}
names(logs_by_decay_plot)

col <- c("year", "decaystage", "vol_log_m3_ha")

logs_by_decay_plot %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0

check <- logs_by_decay_plot %>% filter_at(col, any_vars(is.na(.)))

# deels decaystage missing => ook OK
# na aanpassing verderop: deels KV Kerss (met wel info over min40cm) => OK 
# moet niet aangepast worden
```

### Logs_by_decay_plot_species

Idem als hiervoor.

```{r}
col <- c("year", "decaystage", "species", "vol_log_m3_ha")

logs_by_decay_plot_species %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0

check <- logs_by_decay_plot_species %>% filter_at(col, any_vars(is.na(.)))
# OK
```



## Add zero's

Sommige plots bevatten geen bomen én geen dood hout (Bv. Ename), en zijn dus 
niet opgenomen in `dendro_by_plot`.
Hoewel het niet zinvol is om in elke dataset nullen toe te voegen (bv. per_species), 
is het wel nuttig bij `dendro_per_plot`.

Functie `add_zero_no_na`  blijkt niet geschikt voor dit. 
<!-- Nadeel is dat er ook gegevens van liggend dood hout opgenomen zijn, en blijkbaar kan er maar één variabele als `add_zero_no_na` opgenomen worden.  -->
<!-- Idealiter zou dataset in twee moeten opgesplits worden: liggend en staand,  -->
<!-- en vervolgens elk onafhankelijk van elkaar mbv add_zeros aangevuld. -->

<!-- Maakt alles vrij complex, voor iets heel simpels. -->
<!-- We weten al dat de nulwaarden voor plots met bomen, maar zonder liggend dood hout, -->
<!-- toegevoegd zijn. -->
<!-- Het gaat dus enkel nog om plots zonder staande bomen. -->

Daarom heel simpel: obv `plotinfo` - `survey_trees` en `survey_deadw` - nulwaarden toevoegen.


```{r check_add_zeros_werkt_niet, eval = FALSE}
# dendro_by_plot_ <- add_zeros(dataset = dendro_by_plot %>% select(-contains(c("reg", "veg")), -survey_deadw, - data_processed)
#                              , comb_vars = c("plot_id", "period")
#                              , grouping_vars = c("plottype", "forest_reserve")
#                              , add_zero_no_na = c("survey_trees")
#                              )
#   
# nrow(dendro_by_plot)  - nrow(dendro_by_plot_)
# # !! daar zitten ook plots bij die niet opgenomen zijn in één van beide cycli ...
# 
# dendro_by_plot_ %>% anti_join(dendro_by_plot, 
#                               by = c("plot_id", "period", "plottype", "forest_reserve"))
```

Nov 2022: het gaat enkel over 13 plots in Enamebos, die volgens mij permanente 
open ruimte zijn.
Er is een veld in `plotdetails` (`forested`) dat zou kunnen ingeschakeld worden 
om deze plots al dan niet uit de analyseset te filteren.
Momenteel nog niet ingevuld.

```{r check_dendro_plots_zonder_bomen}
# welke plots niet opgenomen in dendro_by_plot?
  
check <- plotinfo %>% 
  filter((survey_trees | survey_deadw) & data_processed) %>% 
  anti_join(dendro_by_plot)

table(check$forest_reserve, check$period)
  #                  2  3
  # Ename           13  0

# Open plekken in Ename bos: best toevoegen, want er zijn ook plots met bv maar één boom
# eerder bij dataverwerking dan uitfilteren

zero_biomass_plots <- dendro_by_plot %>% 
  full_join(plotinfo %>% 
              filter((survey_trees | survey_deadw) & data_processed) %>% 
              select(plot_id, period, year = year_dendro)
  ) %>% 
  filter(is.na(vol_alive_m3_ha) & is.na(vol_log_m3_ha)) %>% 
  replace((is.na(.)), 0)

table(zero_biomass_plots$plot_id)

```

```{r rbind_zero_biomass}
# Ename
dendro_by_plot_ <- rbind(dendro_by_plot, zero_biomass_plots)
summary(dendro_by_plot_)

dendro_by_plot <- dendro_by_plot_

```



## Correctie logs: 0 --> NA - voorlopig OK 20/9/2022

Enkel een probleem in Dendro_by_plot
Dendro_by_plot: functie forrescalc zet deadwood = 0, wanneer er een levend volume gemeten is 
!! FOUT: zou obv survey_deadw_YN moeten gebeuren!!
**Gevraagd in branch AL_deadw (als commit) op 20/9/2022**

Logs_by_decay_plot: OK, want nemen geen NA-waardes mee

Nu voorlopig opvangen door extra code (als géén deadw survey, dan NA): chunck `correctie_deadwood_NA`

```{r check_dead2}
no_deadw <- plotinfo %>% 
  filter(survey_trees == TRUE & survey_deadw == FALSE)
nrow(no_deadw)
table(no_deadw$forest_reserve, no_deadw$period)
# TOCH BEST REKENING MEE HOUDEN!!

```

bv. plot 11000: period 1 en 0 niet opgemeten => moet NA worden ipv 0
Gecheckt, en ook als enkel deadwood ingeladen wordt van plots waar deadwood opgemeten is 
(`deadwoood_survey_YN == TRUE`), dan nog wordt dit op '0' gezet ipv op NA

```{r eval=FALSE}
data_deadwood %>% filter(plot_id == 11000 & period == 1) %>% nrow() == 0
# enkel data van opgemeten plots ingeladen 
# (data_processed = TRUE or FALSE is zelfde resultaat: geen records als er niks opgemeten is)

check11000 <- dendro_by_plot %>% filter(plot_id == 11000 & period == 1)

dendro_by_plot %>% filter(plot_id == 11000 & period == 1) %>% dplyr::pull(vol_log_m3_ha)

logs_by_decay_plot %>% filter(plot_id == 11000 & period == 1) %>% dplyr::pull(vol_log_m3_ha)

# 
table(no_deadw$forest_reserve, no_deadw$period)
# 98 plots zonder deadwood-opname, maar wel volume_alive 
#=> TOCH BEST REKENING MEE HOUDEN!!
```

```{r correctie_deadwood_NA}
dendro_by_plot_ <- dendro_by_plot %>% 
  left_join(plotinfo %>% select(plot_id, period, survey_deadw), by = c("plot_id", "period")) %>% 
  mutate(vol_log_m3_ha = ifelse(survey_deadw, vol_log_m3_ha, NA),
         vol_deadw_m3_ha = ifelse(survey_deadw, vol_deadw_m3_ha, NA))

dendro_by_plot_ %>% filter(plot_id == 11000 & period == 1) %>% dplyr::pull(vol_log_m3_ha)
dendro_by_plot_ %>% filter(plot_id == 11000 & period == 3) %>% dplyr::pull(vol_log_m3_ha)
dendro_by_plot_ %>% filter(plot_id == 1620 & period == 2) %>% dplyr::pull(vol_log_m3_ha)

dendro_by_plot <- dendro_by_plot_ %>% 
  select(-survey_deadw)

#
dendro_by_plot_species_ <- dendro_by_plot_species %>% 
  left_join(plotinfo %>% select(plot_id, period, survey_deadw), by = c("plot_id", "period")) %>% 
  mutate(vol_log_m3_ha = ifelse(survey_deadw, vol_log_m3_ha, NA),
         vol_deadw_m3_ha = ifelse(survey_deadw, vol_deadw_m3_ha, NA))

dendro_by_plot_species_ %>% filter(plot_id == 11000 & period == 1) %>% dplyr::pull(vol_log_m3_ha)
dendro_by_plot_species_ %>% filter(plot_id == 11000 & period == 3) %>% dplyr::pull(vol_log_m3_ha)
dendro_by_plot_species_ %>% filter(plot_id == 1620 & period == 2) %>% dplyr::pull(vol_log_m3_ha)

dendro_by_plot_species <- dendro_by_plot_species_ %>% 
  select(-survey_deadw)

#
dendro_by_diam_plot_ <- dendro_by_diam_plot %>% 
  left_join(plotinfo %>% select(plot_id, period, survey_deadw), by = c("plot_id", "period")) %>% 
  mutate(vol_log_m3_ha = ifelse(survey_deadw, vol_log_m3_ha, NA))

dendro_by_diam_plot_ %>% filter(plot_id == 11000 & period == 1) %>% dplyr::pull(vol_log_m3_ha)
dendro_by_diam_plot_ %>% filter(plot_id == 11000 & period == 3) %>% dplyr::pull(vol_log_m3_ha)
dendro_by_diam_plot_ %>% filter(plot_id == 1620 & period == 2) %>% dplyr::pull(vol_log_m3_ha)

dendro_by_diam_plot <- dendro_by_diam_plot_ %>% 
  select(-survey_deadw)

#
dendro_by_diam_plot_species_ <- dendro_by_diam_plot_species %>% 
  left_join(plotinfo %>% select(plot_id, period, survey_deadw), by = c("plot_id", "period")) %>% 
  mutate(vol_log_m3_ha = ifelse(survey_deadw, vol_log_m3_ha, NA))
# !!? toch zeker dat vol_deadw_m3_ha niet meer bestaat in by_diam?
         

dendro_by_diam_plot_species_ %>% filter(plot_id == 11000 & period == 1) %>% dplyr::pull(vol_log_m3_ha)
dendro_by_diam_plot_species_ %>% filter(plot_id == 11000 & period == 3) %>% dplyr::pull(vol_log_m3_ha)
dendro_by_diam_plot_species_ %>% filter(plot_id == 1620 & period == 2) %>% dplyr::pull(vol_log_m3_ha)
# !!? toch zeker dat vol_deadw_m3_ha niet meer bestaat in by_diam?


dendro_by_diam_plot_species <- dendro_by_diam_plot_species_ %>% 
  select(-survey_deadw)

```

## Logs KV Kersselaerspleyn pas vanaf 40 cm

Geen opnames van logs in 1ste decade (reeds op NA gezet hierboven)
In 2de en 3de decade pas opgemeten vanaf 40 cm diameter.

Om correct te zijn, zouden in de plot-level-resultaten NA's moeten vermeld worden 
bij de volumes liggend dood hout.
En dan eventueel een afzonderlijke kolom met info vanaf 40 cm.

< dataverwerking 2012: "Deadwood: geen volopname van liggend dood hout: daarvoor wordt verwezen naar de 11 cirkels die in KV gelegen zijn"
==> Wat in de cijfers zit, zijn de liggende bomen met > 40 cm diameter (uit BE-kartering).
Idem dito voor 3e decade: in KV pas vanaf 40 cm (CP's vanaf 10 cm)


```{r check_logs_KV_Kerss}
check <- dendro_by_plot %>% 
  filter(plot_id == 11000)
```

```{r correctie_logs_KV_Kerss}
names(dendro_by_plot)
# "vol_log_m3_ha"           "vol_deadw_m3_ha" 

dendro_by_plot_ <- dendro_by_plot %>% 
  mutate(vol_log_m3_ha_min40cm = 
           ifelse(plot_id == 11000, vol_log_m3_ha, NA),
         vol_log_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_log_m3_ha),
         vol_deadw_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_deadw_m3_ha)
           )

dendro_by_plot_ %>% 
  filter(plot_id == 11000)

dendro_by_plot <- dendro_by_plot_

```

```{r}
# ook voor de andere plot-level-resultaten
      # dendro_by_plot_species = dendro_by_plot_species,
      # dendro_by_diam_plot = dendro_by_diam_plot,
      # dendro_by_diam_plot_species = dendro_by_diam_plot_species,

# spec
dendro_by_plot_species_ <- dendro_by_plot_species %>% 
  mutate(vol_log_m3_ha_min40cm = 
           ifelse(plot_id == 11000, vol_log_m3_ha, NA),
         vol_log_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_log_m3_ha),
         vol_deadw_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_deadw_m3_ha)
           )

dendro_by_plot_species_ %>% 
  filter(plot_id == 11000)

dendro_by_plot_species <- dendro_by_plot_species_

```

```{r}
# diam
dendro_by_diam_plot_ <- dendro_by_diam_plot %>% 
  mutate(vol_log_m3_ha_min40cm = 
           ifelse(plot_id == 11000, vol_log_m3_ha, NA),
         vol_log_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_log_m3_ha)
         # vol_deadw_m3_ha = 
         #   ifelse(plot_id == 11000, NA, vol_deadw_m3_ha)
           )

dendro_by_diam_plot_ %>% 
  filter(plot_id == 11000)

dendro_by_diam_plot <- dendro_by_diam_plot_

# diam - spec
dendro_by_diam_plot_species_ <- dendro_by_diam_plot_species %>% 
  mutate(vol_log_m3_ha_min40cm = 
           ifelse(plot_id == 11000, vol_log_m3_ha, NA),
         vol_log_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_log_m3_ha)
         # vol_deadw_m3_ha = 
         #   ifelse(plot_id == 11000, NA, vol_deadw_m3_ha)
           )

dendro_by_diam_plot_species_ %>% 
  filter(plot_id == 11000)

dendro_by_diam_plot_species <- dendro_by_diam_plot_species_
```

!tabellen “dendro_by_diam_plot” en “dendro_by_diam_plot_species”: 
diam-klasses 10-15cm/15-20cm/20-25cm/25-30cm/…: “vol_log_m3_ha_min40cm” = NA ipv “0” 

```{r correctie_logs_KV_Kerss2}
unique(dendro_by_diam_plot$dbh_class_5cm)

check <- dendro_by_diam_plot %>% 
  filter(plot_id == 11000 & year %in% c(2009, 2020))

table(check$dbh_class_5cm)

to_small <- c("5 - 10 cm", "10 - 15 cm", "15 - 20 cm", "20 - 25 cm", "25 - 30 cm", "30 - 35 cm", "35 - 40 cm")

dendro_by_diam_plot_ <- dendro_by_diam_plot %>% 
  mutate(vol_log_m3_ha_min40cm = ifelse(plot_id == 11000 & dbh_class_5cm %in% to_small,
                                        NA,
                                        vol_log_m3_ha_min40cm))

check2 <- dendro_by_diam_plot_ %>% 
  filter(plot_id == 11000 & year %in% c(2009, 2020) & dbh_class_5cm %in% to_small)

dendro_by_diam_plot <- dendro_by_diam_plot_

# idem voor xxxxx_species
dendro_by_diam_plot_species_ <- dendro_by_diam_plot_species %>% 
  mutate(vol_log_m3_ha_min40cm = ifelse(plot_id == 11000 & dbh_class_5cm %in% to_small,
                                        NA,
                                        vol_log_m3_ha_min40cm))

check2 <- dendro_by_diam_plot_species_ %>% 
  filter(plot_id == 11000 & year %in% c(2009, 2020) & dbh_class_5cm %in% to_small)

dendro_by_diam_plot_species <- dendro_by_diam_plot_species_


```


> Ook voor decaystage 
!! als package aangepast is, moet onderstaande code aangepast worden, want
dan ook staand dood hout per decaystage.

```{r}
# ook voor de andere plot-level-resultaten
      # logs_by_decay_plot = logs_by_decay_plot,
      # logs_by_decay_plot_species = logs_by_decay_plot_species

# decay
logs_by_decay_plot_ <- logs_by_decay_plot %>% 
  mutate(vol_log_m3_ha_min40cm = 
           ifelse(plot_id == 11000, vol_log_m3_ha, NA),
         vol_log_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_log_m3_ha)
           )

logs_by_decay_plot_ %>% 
  filter(plot_id == 11000)

logs_by_decay_plot <- logs_by_decay_plot_

# decay - spec
logs_by_decay_plot_species_ <- logs_by_decay_plot_species %>% 
  mutate(vol_log_m3_ha_min40cm = 
           ifelse(plot_id == 11000, vol_log_m3_ha, NA),
         vol_log_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_log_m3_ha)
           )

logs_by_decay_plot_species_ %>% 
  filter(plot_id == 11000)

logs_by_decay_plot_species <- logs_by_decay_plot_species_
```


## Aanmaak list

```{r new_list_dendro}
# opnieuw list van maken om te exporteren en plotinfo aan te koppelen
dendro <- list(
      dendro_by_plot = dendro_by_plot,
      dendro_by_plot_species = dendro_by_plot_species,
      dendro_by_diam_plot = dendro_by_diam_plot,
      dendro_by_diam_plot_species = dendro_by_diam_plot_species,
      logs_by_decay_plot = logs_by_decay_plot,
      logs_by_decay_plot_species = logs_by_decay_plot_species
    )
```


## Plotinfo toevoegen (aan csv-files)

```{r join_plottype_surveynr_BR}
dendro_plotinfo <- lapply(dendro, function(x) left_join(x, plotinfo %>% select(plot_id, forest_reserve, plottype, period, survey_number), by = c("plot_id", "period")))
# lapply: same function over all elements of the list
```

No deadwood survey wordt nu opgevangen door extra parameter in de `load_data_xxx`-functies, nl. `data_processed = TRUE`.
Dit wordt in de code van de functie uitgebreid met `xxx_survey = TRUE`.

> !!FOUT: deadwood wordt weliswaar niet ingeladen, maar er wordt geen NA aan toegekend bij dendro-statistieken waar ook levende bomen opgemeten werden
(zie hoger: nu nog met code gecorrigeerd)


## Export plot-level-data

!!!! ENKEL PLOTS EXPORTEREN WAARVAN DATA PROCESSED ZIJN!!
Is standaard parameter bij inladen dendro-data 

**DUS: zorgen dat dit veld in Fieldmap up-to-date is, zie chunck "plotinfo_processed"**

Issue #58: afgesproken met Els dat standaard enkel processed_data ingeladen worden bij load_data
==> ook bij de dataverwerking enkel deze data mee
  IS OK, opgelost in branch `statistic_and_other_issues`

 
Enkele verduidelijkingen:

* "number_of_tree_species" = aantal soorten obv de levende bomen

* "stems_per_tree" = meerstammigheid (stem_number_ha / number_of_trees_ha): heeft hier geen zin, maar dient als insteek voor berekeningen per soort

* "vol_bole_alive_m3_ha" en "vol_bole_dead_m3_ha": volume zonder crown, 
versus "vol_alive_m3_ha" en "vol_dead_standing_m3_ha"

* "vol_log_m3_ha": liggend dood hout (NA als er geen deadwood survey gebeurd is)

* "vol_deadw_m3_ha": staand en liggend dood hout (NA als er geen deadwood survey gebeurd is)

```{r save_dendro_git, eval = FALSE}
# geen plotinfo naar git
save_results_git(
  results = dendro,
  repo_path = path_to_git_forresdat,
  strict = TRUE
)
```

```{r save_dendro_git_manueel, eval = FALSE}
# manueel - eigen simpele functie - als save_results_git niet werkt
save_results_tsv(dendro, 
                 root = path_to_forresdat_data, 
                 strict = FALSE)
```


```{r save_dendro_access_csv, eval = FALSE}
# hier wel plotinfo (plottyupe, BR, surveynr mee wegschrijven)

# volgende functie heb ik zelf geschreven, zit niet in het package!
save_results_csv (
    results = dendro_plotinfo,
    output_dir = path_to_plotlevel_csv
    )

# afgerond voor export naar access
dendro_round <- dendro_plotinfo %>% 
  lapply(., function(x) round_df(x, 2))

save_results_access (
  results = dendro_round,
  database = path_to_analysis_set_db,
  remove_tables = TRUE
  )

```


Direct naar gdrive exporteren (csv): 
naar **/PRJ_BOSECO_ALGEMEEN/PRJ_BR_AanvraagGegevens/!METADATA-ALL_PLOTS/_plot-level-data/**

```{r save_dendro_gdrive, eval = FALSE}
save_results_csv(
    results = dendro_plotinfo,
    output_dir = path_to_plotlevel_gdrive
    )

```


## Create unique tree-id - 8/4/2022 laatste keer gerund

(bevat nog niet Rodebos 3de decade - sowieso niet in detail gecheckt voor KV's)

`Data_dendro_calc` bevat een unieke `tree_id` per boom (die constant blijft doorheen de tijd),
verschillend van de `tree_measure_id` uit fieldmap, die wel varieert doorheen de tijd.

Deze `tree_id` wordt in het package aangemaakt obv old_id.

**OPGEPAST**
Bij hakhout kan/kon dit soms tot gemiste linken leiden. 
(zie ook "TreeMortalityData_DetailHakhout.Rmd")

Hakhoutstoven worden opgesplitst in een levend en dood deel, 
en elk deel wordt dan als een afzonderlijke boom beschouwd 
(een boom kan immers niet én levend én dood tegelijk zijn)

OldID wordt standaard toegekend aan het levende deel van de hakhoutstoof.
Het dode deel wordt gelinkt via CoppiceID.
Indien er enkel een dood deel is (en geen levend deel), dan wordt daar OldID aan toegekend.

Dat wil zeggen dat er zich enkel een probleem stelt wanneer er in één van de 
twee periodes zowel een levend als een dood deel voorkomt.
In de andere gevallen is de koppeling die gebeurt via OldID correct.

**OPLOSSING**
Daarom wordt in code hierna voor hakhout dat in één van de 
twee periodes uit zowel een levend als een dood deel bestaat, de tree_id bepaald obv coppice_id.

Voor de 11 verwerkte CP's + KV Muizenbos is die koppeling gecheckt en OK bevonden.

Dit houdt in dat tree_id niet meer uniek is per periode.
Dat geeft dan weer problemen wanneer we er een "wijde" tabel van willen maken.

Daarom wordt er een _a of _b toegevoegd, afh. of het om levend of dood deel van een hakhoutstoof gaat.
Indien we toch één ID per hakhout willen, ongeacht levend/dood, dan kunnen we makkelijk de _a en _b verwijderen (= `tree_id_non_unique`).


### Op boomniveau - obv old-id

De branch `statistics_and_other_issues` heeft een manier gevonden om tree-id te berekenen, ook voor 4 decades. 

```{r mbv_oldid_obv_package}
tree_id <- create_unique_tree_id(data_dendro = data_dendro_calc)
# Deze tabel wordt NIET bewaard in forresdat (daar enkel geaggregeerde resultaten op plotniveau)

# check
tree_id %>% filter(is.na(tree_id)) %>% nrow()
tree_id_missing <- tree_id %>% filter(is.na(tree_id))
table(tree_id_missing$forest_reserve, tree_id_missing$period)

# selectie om wijde tabel aan te maken
tree_id_long <- tree_id %>%
  select(plot_id, species, tree_id, period, dbh_mm, vol_tot_m3, alive_dead)

```


### Op boomniveau - obv coppice-id

**EVENTUEEL EXTRA TOEVOEGEN**  
> 21/2/2022: link obv coppice-id, want dat wordt veel gevraagd.
> Zie ook `Euforia_TreePlotData_Flanders_Olalla_2022-01-13.Rmd`.

Uitsplitsen van hakhoutstoven in dood en levend deel is nodig, want een "tree" kan niet zowel levend als dood zijn.
Bovendien kan een `oldID` niet aan twee "trees" toegekend worden, omdat er anders problemen ontstaan met de koppeling die gebaseerd is op OldID (moet een één-op-één relatie zijn tussen de 2 periodes).

In de databank wordt OldID standaard toegekend aan het levende deel van de hakhoutstoof.   
Het dode deel wordt gelinkt via CoppiceID.   
Indien er enkel een dood deel is (en geen levend deel), dan wordt daar OldID aan toegekend.   

Dus bij de hakhoutstoven die (in eenzelfde periode) uit een levend en dood deel bestaan, hebben de twee delen niet dezelfde oldID, maar wel dezelfde coppice_id.    

Dat wil zeggen dat er zich enkel een probleem stelt wanneer er in één van de twee periodes zowel een levend als een dood deel voorkomt.   
In de andere gevallen kan de koppeling gebeuren via OldID.   

Zo werken we dan ook:  

- 2 delen: koppeling via OldID
- 3 of 4 delen: koppeling via CoppiceID  

In kader van het TreeMortality project hebben we nog een extra onderscheid gemaakt tss levend en dood deel van een hakhoutstoof, door _a en _b toe te voegen voor resp. levend of dood deel van een stoof.
Dat was toen nodig omdat we extra records "fallen" toe moesten voegen voor het dood hout dat er niet meer was.

Dat is ook nodig wanneer we er ooit een "wijde" tabel van willen maken.

Het is echter niet zeker dat dat een correcte link is, want beide delen lopen als het ware in elkaar over. 
Bv. - periode 1 levend gekoppeld aan periode 2 levend
    - periode 1 dood gekoppeld aan periode 2 dood
--> mogelijks zijn er van de levende wat extra dood gegaan, en van de dode wat omgevallen (fallen)
maar dat is niet te bepalen (kan vergeleken worden met dode takken in een boom)
(zie ook `TreeMortalityData_DetailHakhout.Rmd`)

Indien we een correcte link willen, moeten we _a en _b terug verwijderen, met als gevolg dat tree-id géén uniek veld meer is.

> !! controle van die coppice_id nodig obv aantal soorten en afwijking van XY
> reeds gedaan voor de 11 CP's in forresdat op 16/2/2022

__Werkwijze:__

* bepalen hoeveel delen er per hakhoutstoof aanwezig zijn

* data opsplitsen:
    (1) een deel waarbij link via OldID behouden blijft (= treeid): **_data_OldID_**
    (individuele bomen en coppice dat uit max. één deel bestaat per periode)
    (2) een deel waarbij link via CoppiceID gecreëerd wordt (= nieuwe tree_id): **_data_CoppID_**
    (coppice met ergens een periode met 2 delen)
 
* in data_CoppID de treeid vervangen door period_plotid_coppiceID_a indien levend 
en period_plotid_coppiceID_b indien dood

* samenvoegen van data_OldID, data_CoppID

--
Vanaf 3 decades wordt het moeilijker.
Dan zouden we moeten kijken of er max. één per decade is, dan obv old_id
Zodra er meer dan één per decade is, dan moeten we werken met coppice_id voor allemaal en dan onderscheid tss levend en dood mbv suffix "a" en "b". 


```{r NumberOfPartsPerCoppicePerDecade}
tree_id %>% filter(coppice_id > 0) %>% nrow()
# [1] 17224 - 18015

# coppice_id en plot_id samen uniek => hoeveel metingen zijn er per stoof en per decade (max.2 - klopt)
summ_coppice_id <- tree_id %>% 
  filter(coppice_id > 0) %>%
  group_by(coppice_id, plot_id, period) %>% 
  summarise(aantal = n()) %>% 
  ungroup()
# 16138

table(summ_coppice_id$aantal)
#     1     2 
# 14261  1877

summ_coppice_id %>% filter(aantal > 2) %>% distinct(plot_id)

summ_coppice_id %>% filter(aantal > 2)

# vb van 3 decades
tree_id %>%  filter(coppice_id == 32 & plot_id == 31000) %>% 
  select(period, tree_measure_id, species, alive_dead, nr_of_stems, x_local, y_local, tree_id, coppice_id)


# summ_coppice_id
summ_coppice_id_def <- summ_coppice_id %>% 
  group_by(coppice_id, plot_id) %>% 
  summarise(max_aantal = max(aantal)) %>% 
  ungroup()
# 9690
```

```{r SplitDataTrees_OldID_CoppID}
tree_id_  <- tree_id %>% 
  left_join(summ_coppice_id_def, by = c("plot_id","coppice_id")) %>% 
  rename (max_nr_parts_coppice = max_aantal) 

str(tree_id_)
str(summ_coppice_id_def)

# tree_data via OldID
tree_data_OldID <- tree_id_ %>% 
  filter (ind_sht_cop != 12 | max_nr_parts_coppice < 2 | is.na(coppice_id))

# tree_data via coppice ID
tree_data_CoppID <- tree_id_ %>% 
  filter (max_nr_parts_coppice > 1)

nrow(tree_data_OldID) + nrow(tree_data_CoppID) - nrow(tree_id) == 0
# [1] 0

```

Daar waar coppice in één van de (twee of drie) decades uit meer dan twee delen bestaat, `tree_id` vervangen door een id obv `coppice_id`.

```{r CreateNewTreeID_TreeData_CoppID}
tree_data_CoppID_ <- tree_data_CoppID %>% 
  rename (treeid_old = tree_id) %>% 
  mutate (tree_id = paste(1, plot_id, coppice_id, sep = "_")) %>%
  mutate (tree_id = ifelse(alive_dead == 11, paste(tree_id, "a", sep = "_"),
                          ifelse(alive_dead == 12, paste(tree_id, "b", sep = "_"),
                                 NA)))

names(tree_data_CoppID_)

check_coppID <- tree_data_CoppID_ %>% 
  select(plot_id, 
         tree_id, tree_measure_id, coppice_id,
         max_nr_parts_coppice,
         x_local, y_local, 
         period, 
         species, 
         alive_dead, intact_snag, ind_sht_cop, decaystage,
         dbh_mm, height_m, calc_height_m, vol_tot_m3
         ) 

tree_data_CoppID <- tree_data_CoppID_
```


```{r Controle_TreeData_OldID}
# str(tree_data_OldID)
nrow(tree_data_OldID)
# [1] 36615
# [1] 75907 - 77402
# summary(tree_data_OldID)

```


```{r Controle_TreeData_CoppID}
# str(tree_data_CoppID)
nrow(tree_data_CoppID)
# [1] 2038
# [1] 3959 - 4892
# summary(tree_data_CoppID)

table(tree_data_CoppID$max_nr_parts_coppice)
#    2 
# 4892 

tree_data_CoppID_check <- tree_data_CoppID_ %>% 
  mutate(tree_id_non_unique = ifelse(max_nr_parts_coppice < 2, tree_id,
                                 str_sub(tree_id, 1, -3)),
         test = (tree_id_non_unique == tree_id)) %>% 
  select(plot_id, 
         tree_id, tree_measure_id, coppice_id, old_id,
         tree_id_non_unique, test,
         max_nr_parts_coppice,
         x_local, y_local, 
         period, 
         species, 
         alive_dead, intact_snag, ind_sht_cop, decaystage,
         dbh_mm, height_m, calc_height_m, vol_tot_m3
         )
  

# 5 => !! 3 periodes opgemeten  (Hannecart, Rodebos) - ?? Harras?

# !! Kerss en Zwaenepoel en Harras (3 decades): heel weinig coppice => daarom nu nog zo geen probleem
# maar het kan wel dat er nu hakhout is dat er al 3 decades staat (bv. 3x levend), dat via coppice_id gekoppeld wordt ipv via oldID, maar dat is geen probleem
# Beter in die richting een afwijking dan andersom

```

Zijn er geen foute linken obv coppice_id? 

```{r check_XY}
# checken obv XY

verschil_XY_coppiceid <- tree_data_CoppID_check %>% 
  group_by(plot_id, tree_id_non_unique, coppice_id) %>% 
  summarize(aantal_records = n(),
            aantal_soorten = n_distinct(species),
            aantal_statussen = n_distinct(alive_dead),
            x1 = first(x_local), 
            x_mean = mean(x_local),
            y1 = first(y_local),
            y_mean = mean(y_local)) %>% 
  ungroup() %>% 
  mutate(verschilX = abs(x1 - x_mean),
         verschily = abs(y1 - y_mean)
  ) %>% 
  filter(verschilX > 0.99 | verschily > 0.99)
  # filter(verschilX > 0.2 | verschily > 0.2)
  
nrow(verschil_XY_coppiceid)
# 25 - 43
# 20 (1m)

verschil_XY_coppiceid_detail <- tree_data_CoppID_check %>% 
  select(plot_id, tree_id,
         tree_id_non_unique, tree_measure_id, 
         coppice_id, old_id,
         x_local, y_local, 
         period, 
         species, 
         alive_dead, intact_snag, ind_sht_cop, decaystage,
         dbh_mm, height_m, calc_height_m, vol_tot_m3
         ) %>% 
  inner_join(verschil_XY_coppiceid, by = c("plot_id", "tree_id_non_unique", "coppice_id")) %>% 
  filter(aantal_soorten < 2) %>%  # deze apart checken zodat er geen overlap is
  select(-decaystage, -height_m, -tree_id_non_unique, 
         -vol_tot_m3, -calc_height_m, -contains("aantal"))
  
names(verschil_XY_coppiceid_detail)
#   pivot_wider(names_from = tree_id, values_from = x_local) 
# 
# %>% 
#   rename(individual = "10", coppice = "12") %>% 
#   mutate(perc_hakhout = round(100*coppice/(individual + coppice), ))

```

```{r check_meerdere_soorten}
verschillende_soorten_coppiceid <- tree_data_CoppID_check %>% 
  group_by(plot_id, tree_id_non_unique, coppice_id) %>% 
  summarize(aantal_records = n(),
            aantal_soorten = n_distinct(species),
            aantal_statussen = n_distinct(alive_dead),
            x1 = first(x_local), 
            x_mean = mean(x_local),
            y1 = first(y_local),
            y_mean = mean(y_local)) %>% 
  ungroup() %>% 
  mutate(verschilX = abs(x1 - x_mean),
         verschily = abs(y1 - y_mean)
  ) %>% 
  filter(aantal_soorten > 1)

# verschillende soorten
meerdere_soorten_zelfde_coppice_id <- tree_data_CoppID_check %>% 
  # select(-x_local, -y_local) %>% 
  inner_join(verschillende_soorten_coppiceid,
             by = c("plot_id", "tree_id_non_unique", "coppice_id")) %>% 
  select(plot_id, 
         tree_id, tree_id_non_unique, tree_measure_id, 
         coppice_id, old_id,
         x_local, y_local, 
         period, 
         species, 
         alive_dead, intact_snag, ind_sht_cop, decaystage,
         dbh_mm, height_m, calc_height_m, vol_tot_m3
         ) %>% 
  select(-decaystage, -height_m, -tree_id_non_unique, -vol_tot_m3, -calc_height_m)

meerdere_soorten_zelfde_coppice_id %>% distinct(plot_id)

```


```{r te_controleren_door_Peter, eval=FALSE}
# write_csv2(meerdere_soorten_zelfde_coppice_id, "Data_controle/nalv_Euforia_2022-02-15/meerdere_soorten_zelfde_coppice_id.csv")
# 
# write_csv2(verschil_XY_coppiceid_detail, "Data_controle/nalv_Euforia_2022-02-15/verschil_XY_coppiceid_detail.csv") 
# 
# # OK, verzonden op 15/2/2022 naar Peter !! enkel data voor Euforia, niet van KV's of 2109 of 723 of 
# # (enkel processed én 2x opgemeten)
# 
# 
# write_csv2(meerdere_soorten_zelfde_coppice_id, "Data_controle/meerdere_soorten_zelfde_coppice_id2.csv")
# # OK, opgelost!!
# 
# write_csv2(verschil_XY_coppiceid_detail, "Data_controle/verschil_XY_coppiceid_detail2.csv") 
# # OK, verzonden op 21/2/2022 naar Peter !! gezegd dat dat geen haast had
# # Bevat ook de niet processed data
# 

write_csv2(meerdere_soorten_zelfde_coppice_id, "Data_controle/meerdere_soorten_zelfde_coppice_id3.csv")

write_csv2(verschil_XY_coppiceid_detail, "Data_controle/verschil_XY_coppiceid_detail3.csv") 
# OK, verzonden op 18/4/2022 naar Peter !! gezegd dat dat geen haast had

```

```{r rbind_tree_data_OldID_CoppID}
tree_data_CoppID <- tree_data_CoppID %>% 
  select(-treeid_old)

tree_data_all <- rbind(tree_data_OldID, tree_data_CoppID)

nrow(tree_data_all) == nrow(tree_id)
names(tree_data_all)
names(tree_id)

# check_a_b <- tree_data_all %>% 
#   select(plot_id, 
#          tree_id, tree_measure_id, coppice_id,
#          nr_parts_coppice,
#          x_local, y_local, 
#          period, 
#          species, 
#          alive_dead, intact_snag, ind_sht_cop, decaystage,
#          dbh_mm, height_m, calc_height_m, vol_tot_m3
#          ) %>% 
#   filter(nr_parts_coppice > 2)

tree_id_ <- tree_data_all %>% 
  mutate(tree_id_non_unique = ifelse(max_nr_parts_coppice < 2 | is.na(max_nr_parts_coppice), tree_id,
                                 str_sub(tree_id, 1, -3)),
         test = (tree_id_non_unique == tree_id))
# %>%
#   select(plot_id,
#          tree_id, tree_measure_id,
#          coppice_id, old_id,
#          tree_id_non_unique, test,
#          max_nr_parts_coppice,
#          x_local, y_local,
#          period,
#          species,
#          alive_dead, intact_snag, ind_sht_cop, decaystage,
#          dbh_mm, height_m, calc_height_m, vol_tot_m3
#          )

tree_id <- tree_id_ %>% 
  select(-test, -max_nr_parts_coppice)

names(tree_id)
```


### Op spilniveau

!! OPGEPAST !! 

Tree-id wordt overgenomen van boomniveau, aangemaakt via `old_id` of `coppice_id` afhankelijk van "delen" hakhout (zie hoger).

```{r copy_tree_id}
names(data_stems_calc)
names(tree_id)

tree_id_ <- tree_id %>% 
  select(plot_id, tree_measure_id, tree_id, tree_id_non_unique, period)
# tree_id_ <- tree_id %>% 
#   select(plot_id, tree_measure_id, tree_id, period)

stem_id <- data_stems_calc %>% 
  filter(tree_measure_id != 0) %>% 
  left_join(tree_id_, by = c("plot_id", "tree_measure_id", "period"))

names(stem_id)
```

```{r check_id_hakhout, eval=FALSE}
stem_id %>% filter(is.na(tree_id)) %>% nrow()
# 0
stem_id %>% filter(is.na(tree_id)) %>% select(plot_id, period)


tree_id_hakhout <- stem_id %>% 
  group_by(plot_id, tree_measure_id, period) %>% 
  summarize(aantal = n()) %>% 
  ungroup()

table(tree_id_hakhout$aantal)
```


## Op boomniveau: wijde tabel met één record per boom doorheen de tijd

```{r tree_id_long}
# selectie om wijde tabel aan te maken
tree_id_long <- tree_id %>%
  select(plot_id, period, tree_id, 
         species, ind_sht_cop,
         dbh_mm, vol_tot_m3, alive_dead) %>% 
  arrange(period) %>% 
  left_join(plotinfo %>% select(plot_id, period, survey_number)) %>% 
  select(-period)

# ? survey_number => joinen met plotinfo
```

Om één record per boom te verkrijgen met info uit beide periodes, dient functie "make_table_wide" gebruikt te worden.
Dit werkt enkel bij een unieke tree_id.

!!Opgepast: soms daalt dbh doorheen de tijd: dat is het geval bij dode bomen.

```{r tree_id_wide_check}
check_dubbele_tree_id <- tree_id %>% 
  group_by(plot_id, tree_id, period) %>% 
  summarize(aantal_per_periode = n()) %>% 
  ungroup() %>% 
  filter(aantal_per_periode > 1) %>% 
  inner_join(tree_data_CoppID_check)

check_dubbele_tree_id
# A tibble: 3 x 4
#   plot_id tree_id       period aantal_per_periode
#     <int> <chr>          <dbl>              <int>
# 1   41000 1_41000_164_a      2                  2
# 2   51000 1_51000_4_a        1                  2
# 3   53000 1_53000_258_b      1                  2

check_dubbele_tree_id %>% distinct(plot_id)

# anti_join met deze die al gecheckt worden obv andere X en/of Y
check_dubbele_tree_id_ <- check_dubbele_tree_id %>% 
  anti_join(verschil_XY_coppiceid_detail %>%  select(plot_id, tree_id)) %>% 
  anti_join(meerdere_soorten_zelfde_coppice_id %>%  select(plot_id, tree_id))

# twee stoven met verschillend afbraakstadium !! afbraak wordt ingevuld op niveau van stems

```

```{r te_controleren_door_Peter2, eval=FALSE}
# write_csv2(check_dubbele_tree_id, "Data_controle/nalv_Euforia_2022-02-15/hakhout_verschillende_id_zelfde_status_levend_dood.csv")

write_csv2(check_dubbele_tree_id_, "Data_controle/hakhout_verschillende_id_zelfde_status_levend_dood3.csv") 
```

```{r tree_id_wide}
# TIJDELIJK
tree_id_long_ <- tree_id_long %>% 
  anti_join(check_dubbele_tree_id %>%  select(plot_id, tree_id))  # tijdelijk de dubbele tree_id's verwijderen

tree_id_long <- tree_id_long_

tree_id_wide <- make_table_wide(table_long = tree_id_long,
                                    column_to_repeat = "survey_number",
                                    columns_for_comparison = c("alive_dead", "dbh_mm", "vol_tot_m3"))

names(tree_id_wide)
```



## Export tree level data

Met unieke en non-unieke (voor hakhout) tree-id én berekende variabelen.
Enkel processed data.

Niet alle variabelen mee exporteren, enkel deze relevant voor de meeste gebruikers.

Enkele verduidelijkingen:

* plotarea_ha = de oppervlakte van resp. A3 of A4, afh. van status en diameter van de boom
(of LxB voor kernvlaktes of volledig BR voor andere plottypes) dus NIET de volledige cirkel


```{r trees_less_variables}
names(tree_id)

tree_id_less_var <- tree_id %>% 
  select(-old_id, -r_A1, -r_A2, -r_A3, -r_A4, -contains(c("dbh_min", "core_area_")), -subcirclearea_ha)

tree_id_less_var <- tree_id_less_var %>% 
  select(forest_reserve, plot_id, plottype, 
         period, 
         tree_measure_id, tree_id, tree_id_non_unique, coppice_id, 
         x_local, y_local, 
         species, 
         dbh_mm, height_m, calc_height_m, 
         alive_dead, ind_sht_cop, intact_snag, 
         iufro_hght, iufro_vital, iufro_socia, 
         decaystage, crown_volume_reduction, branch_length_reduction, 
         remark, common_remark, 
         year, date_dendro, 
         subcircle, plotarea_ha, totalplotarea_ha, 
         dbh_class_5cm, 
         nr_of_stems, 
         basal_area_m2, 
         vol_bole_m3, vol_crown_m3, vol_tot_m3, 
         basal_area_alive_m2_ha, basal_area_dead_m2_ha, 
         vol_alive_m3_ha, vol_dead_standing_m3_ha, 
         vol_bole_alive_m3_ha, vol_bole_dead_m3_ha, 
         number_of_trees_alive_ha, number_of_trees_dead_ha
         )

```


```{r save_trees, eval = FALSE}
# volgende functies heb ik zelf geschreven, zitten niet in het package!!!
save_results_csv (
    results = list(trees_calc = tree_id_less_var),
    output_dir = paste0(path_to_output, "raw-data/")
    )

# afgerond voor export naar access
tree_id_round <- tree_id_less_var %>% 
  mutate(round_df(., 4))

# save_results_access (
#   results = list(trees_calc = data_dendro_calc_round),
#   database = path_to_analysis_set_db,
#   remove_tables = TRUE
#   )

# Functie "save_results_access" (< package) geeft problemen met dates => hierna manueel

con <- odbcConnectAccess2007(path_to_analysis_set_db)

dbtables <- sqlTables(con)
if ("trees_calc" %in% dbtables$TABLE_NAME) {
        sqlDrop(con, "trees_calc")
      }
sqlSave(con, dat = tree_id_round, tablename = "trees_calc", varTypes = c(date_dendro="datetime"))

odbcClose(con)
```


```{r save_trees_wide, eval = FALSE}
# volgende functies heb ik zelf geschreven, zitten niet in het package!!!
save_results_csv (
    results = list(trees_wide = tree_id_wide),
    output_dir = paste0(path_to_output, "raw-data/")
    )

# afgerond voor export naar access
tree_id_wide_round <- tree_id_wide %>% 
  mutate(round_df(., 4))

save_results_access (
  results = list(trees_wide = tree_id_wide_round),
  database = path_to_analysis_set_db,
  remove_tables = TRUE
  )

```


## Export stem level data

Met unieke en non-unieke (voor hakhout) tree-id (uniek op boomniveau, niet op spilniveau) én berekende variabelen.

**!! OPGEPAST !!**
Unieke en non-unieke (voor hakhout) tree-id overgenomen van trees berekend op boomniveau.

<!--  na 16/2/2022: voor hakhout met meer dan twee delen: tree-id obv coppice-id (zie hoger) -->

Niet alle variabelen mee exporteren, enkel deze relevant voor de meeste gebruikers

```{r stems_less_variables}
stem_id_less_var <- stem_id %>% 
  select(-old_id, -r_A1, -r_A2, -r_A3, -r_A4, -contains(c("dbh_min", "core_area_")), -subcirclearea_ha)
## stemnumber_alive werd weggefilterd

stem_id_less_var <- stem_id_less_var %>% 
  select(forest_reserve, plot_id, plottype, 
         period, 
         tree_measure_id, shoot_measure_id, 
         tree_id, tree_id_non_unique, coppice_id, 
         x_local, y_local, 
         species, 
         dbh_mm, height_m, calc_height_m, 
         alive_dead, ind_sht_cop, intact_snag, 
         iufro_hght, iufro_vital, iufro_socia, 
         decaystage, crown_volume_reduction, branch_length_reduction, 
         remark, common_remark, 
         year, date_dendro, 
         subcircle, plotarea_ha, totalplotarea_ha, 
         dbh_class_5cm, 
         basal_area_m2, 
         vol_bole_m3, vol_crown_m3, vol_tot_m3, 
         basal_area_alive_m2_ha, basal_area_dead_m2_ha, 
         vol_alive_m3_ha, vol_dead_standing_m3_ha, 
         vol_bole_alive_m3_ha, vol_bole_dead_m3_ha, 
         stem_number_dead_ha, stem_number_alive_ha
         )

```


```{r save_stems, eval = FALSE}
# volgende functies heb ik zelf geschreven, zitten niet in het package!!!
save_results_csv (
    results = list(stems_calc = stem_id_less_var),
    output_dir = paste0(path_to_output, "raw-data/")
    )

# afgerond voor export naar access
stem_id_round <- stem_id_less_var %>% 
  mutate(round_df(., 4))

# save_results_access (
#   results = list(trees_calc = data_dendro_calc_round),
#   database = path_to_analysis_set_db,
#   remove_tables = TRUE
#   )

# Functie "save_results_access" (< package) geeft problemen met dates => hierna manueel

con <- odbcConnectAccess2007(path_to_analysis_set_db)

dbtables <- sqlTables(con)
if ("stems_calc" %in% dbtables$TABLE_NAME) {
        sqlDrop(con, "stems_calc")
      }
sqlSave(con, dat = stem_id_round, tablename = "stems_calc", varTypes = c(date_dendro="datetime"))

odbcClose(con)
```



# Regeneration - OK - 8/4/2022 - 19/1/2023

## Load regeneration

```{r load_reg}
data_regeneration <-
  load_data_regeneration(
    database = path_to_fieldmap_db,
    processed = TRUE
  )

```

## Opbouw data_regeneration: aantalsklasse vs exact aantal (A1 vs A2)

Het `aantal` zou steeds een aantalsklasse moeten zijn bij seedlings (subcircle = A1) 
en een exact aantal bij established(subcircle = A1) 
=> aanpassen bij datacontrole en voorlopig ook hier in script

Want als allebei ingevuld zijn, dan wordt in package de aantalsklasse genomen
terwijl dat enkel zou mogen bij de seedlings (A1).
Package maakt geen onderscheid tss A1 en A2 voor de berekeningen, ervan uitgaande dat 
alles perfect ingevuld is.
(gebeurt via min_, max_ en approx_ obv de aantalsklasse, enkel als die niet ingevuld zijn, 
wordt exact aantal genomen)

-----
**Aan Els het volgende gevraagd (issue # 106):**
Bij de standaard methodiek is het inderdaad zo dat bij A1-verjonging gewerkt wordt met aantalsklasses en bij A2-verjonging (de iets grotere) met exacte aantallen.
Het is goed om het package in die zin op te bouwen.
MAAR er zijn ook bosreservaten waar de standaard methodiek niet gevolgd werd (bv. Everzwijnbad)
Dat zijn geen fouten, maar gewoon iets ander afspraken toendertijd.

Daarom lijkt het me het meest practische om bij A1-verjonging steeds te vertrekken van de aantalsklasse (NumberClass), maar als die niet ingevuld staat de info uit het exacte aantal (Number) te halen.
En vice versa bij de A2-verjonging.

Want nu is dat ook iets dat ik buiten het package om aanpas ...

Idem dito wanneer er een percentage berekend wordt van rubbing damage: erop letten om ook dan het goede "aantal" te nemen.

----

PRAGMATISCH
soms allebei
soms één van beide, terwijl het de andere zou moeten zijn
==> voor A1, steeds correct, want klasse wordt genomen 
En als klasse NA is, dan wordt exact aantal genomen, wat ook OK is!
==> A2: klasse wordt genomen, ook wanneer er toch een exact aantal ingevuld staat
==> CORRECTIE 1: als A2 én nr_of_regeneration is niet NA,
                dan number_class leegmaken
==> CORRECTIE 2: wegens aanmaak plot-level rubbing_dammage: als aantal NA, dan midwaarde number_class nemen


-----

Velden `data_regeneration`:  

- number_class: 1 tem 1001 (LU-list)
(1, 2-5, 6-10, 11-20, 21-40, 41-60,61-100, >100, >1000 --> 1,3,8,15,30,50,80,101,1001)
- nr_of_regeneration: exact aantal
- rubbing_damage_number
- rubbing_damage_perc: *moet nog aangevuld worden met percentage obv aantalsklassse,*
*nu enkel maar berekend voor exacte aantallen (gevraagd in issue #102)*
**TIJDELIJK: in onderstaande code bijgewerkt**
- approx_nr_regeneration: mid-waarde cfr Kris van interval
- min_number_of_regeneration: exacte waarde OF min-waarde interval
- max_number_of_regeneration: exacte waarde OF max-waarde interval

- subcircle: A1 of A2: seedlings vs established
- subcirclearea_ha: enkel berekend bij CP's (als r_A12 bestaat); NA bij KV's
- plotarea_ha: 
* CP's: steeds gelijk aan subcirclearea_ha
* KV's: (1) length_core_area_m * width_core_area_m OF 
(2) core_area_ha < Area_ha uit Plotdetails OF 
(3) totalplotarea_ha < Area_ha of Area_m2 uit layer Plots
(als (1) niet kan, dan (2) en dan pas (3))


```{r exactnr_vs_class}
names(data_regeneration)

data_regeneration %>% filter(!is.na(nr_of_regeneration) & !is.na(number_class)) %>% nrow()
# 1211 van de 33000
test <- data_regeneration %>% filter(!is.na(nr_of_regeneration) & !is.na(number_class))
table(test$subcircle)
# komt meer voor bij seedlings: daar numberclass verwacht
# niet teveel over nadenken, gewoon corrigeren: als beide voorkomen, dan degene die niet past wegdoen

```


```{r }
# check <- data_regeneration %>% 
#   filter(subcircle == "A1" & is.na(number_class))


check <- data_regeneration %>% 
  filter(subcircle == "A2" & 
           !is.na(nr_of_regeneration) &
           !is.na(number_class))
# 83

check2 <- data_regeneration %>% 
  filter(subcircle == "A2" & 
           is.na(nr_of_regeneration) &
           !is.na(number_class))
# 1574 waar enkel klasse vermeld staat, terwijl het een exact nummer zou moeten zijn
# package zal dan automatisch de klasse gebruiken ==> OK
```


! rubbing_damage bij de plot-level-resultaten (zie verder): er wordt "Inf" gecrëeerd indien bij A2-cirkel geen exact aantal genoteerd werd (wat wel zou moeten volgens methodiek).
=> om dit op te vangen toch in dataset voor A2 nr_regeneration vervangen door midwaarde van number_class

> nog niet zeker of Els dit opgelost krijgt: alvast gevraagd in issue #102


```{r correctie_A2_exactnr}
data_regeneration_ <- data_regeneration %>% 
  # number_class leegmaken als niet van toepassing (A2)
  mutate(number_class = ifelse(subcircle == "A2" & !is.na(nr_of_regeneration), 
                               NA, number_class )) %>% 
  # nr_of_reg overnemen van number_class als niet ingevuld (A2)
  mutate(nr_of_regeneration = ifelse(subcircle == "A2" & is.na(nr_of_regeneration), 
                               number_class, nr_of_regeneration)) 
  

data_regeneration_ %>% filter(subcircle == "A2" & !is.na(nr_of_regeneration) &
           !is.na(number_class)) %>% nrow()

data_regeneration <- data_regeneration_

```


```{r correctie_A1_klasse_NIET, eval = FALSE}
# bij A1 in theorie het tegenovergestelde van A2: obv exact nr de aantalsklasse afleiden

# OPGEPAST: number_class overnemen van nr_of_reg als niet ingevuld (A1): niet zo eenvoudig
  # mutate(number_class = ifelse(subcircle == "A2" & is.na(nr_of_regeneration), 
  #                              number_class, nr_of_regeneration))
    # nr_of_regeneration leegmaken als niet van toepassing (A1)
  # mutate(nr_of_regeneration = ifelse(subcircle == "A1" & !is.na(number_class), 
  #                              NA, nr_of_regeneration))  

data_regeneration_ %>% filter(subcircle == "A1" & !is.na(nr_of_regeneration) &
           is.na(number_class)) %>% nrow()
# 2988 => zijn er veel!
check <- data_regeneration_ %>% filter(subcircle == "A1" & !is.na(nr_of_regeneration) &
           is.na(number_class))



```


```{r check_NA}
# check NA's
col <- c("approx_nr_regeneration", "min_number_of_regeneration", "max_number_of_regeneration")
data_regeneration %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0

# check <- data_regeneration %>% filter_at(col, any_vars(is.na(.)))

```


## Correctie plotarea KV Kerss 

> niet nodig voor regeneration_by_plot(_height_species).csv : alles wordt berekend op subplotniveau, met opp 0.01 ha 
    plotarea_ha wordt aangepast bij begin van elke calc_reg-functie:
      plotarea_ha = ifelse(.data$plottype == "CA", 0.01, .data$plotarea_ha)
      
> wél nodig voor de resultaten op niveau van de core area
  
----
Regeneration: counted in standard height classes in subplots: 750 plots of 10x10m in 2001;
selection of 140 subplots (every 5th row) of 10x10m in 2010/11 and 2020/21 (see transects on
map)
Vegetation : standard relevé on 10x10m subplots: 750 plots, only summer survey in 2001; 140
plots in 2011 and 2021 - spring and summer survey; additional survey in spring 2015 (vernal
flora).


< dataverwerking 2012:
"AFWIJKENDE METHODIEK in de kernvlakte van Kersselaerspleyn  
-   Zeer grote kernvlakte (107485 m² = 10.75 ha) + onregelmatige vorm   
-   verjonging en vegetatie werden uitzonderlijk niet volledig heropgemeten in 2011, aangezien er niet zoveel veranderd was + hoge werkdruk  
-   Er werd geopteerd om een selectie van bandtransecten opnieuw in te meten:  
o    Bandtransekten van 10m breed, telkens NZ-gericht (loodrecht op de verdunningsdreef), telkens de eerste strook ten oosten van de 50x50m gridpunten  
o    Dat zijn dan 3 stroken van 300x10 m, 1 van 250, 1 van 150 en eentje van 100 m lang, oftewel 140 proefvlakjes (ipv 107485 m² / 100 m² = 1074 proefvlakjes //  750 in 2000) 
30*3+25+15+10 == 140

==>    Bijgevolg werd er voor de verjonging eigenlijk gewerkt met een plot van slechts 140*100m² groot = 14000 m² = 1,4 ha => aanpassen   


> Hierna plotarea aanpassen enkel voor berekening van regeneration


```{r }
data_regeneration %>% filter(plot_id == 11000) %>% 
  group_by(core_area_ha) %>% summarize() %>% ungroup() %>% dplyr::pull(core_area_ha)
# 10.7485

data_regeneration_ <- data_regeneration %>% 
  mutate(core_area_ha = ifelse(plot_id == 11000 & period > 1, 
                               1.4,
                               ifelse(plot_id == 11000 & period == 1,
                                      7.5,
                                      core_area_ha)),
         plotarea_ha = ifelse(plot_id == 11000 & period > 1, 
                               1.4,
                               ifelse(plot_id == 11000 & period == 1,
                                      7.5,
                                      plotarea_ha)))

data_regeneration <- data_regeneration_

# reg_CA <- data_regeneration %>% filter(plottype == "CA")
# table(reg_CA$forest_reserve, reg_CA$plotarea_ha)
# table(reg_CA$core_area_ha, reg_CA$plotarea_ha)
```

## Correctie rubbing_damage_perc in data_regeneration

`rubbing_damage_perc` is berekend obv exact aantal, maar soms ook enkel aantalsklasse aanwezig
=> moet obv `number_class` als exact aantal niet beschikbaar is
> package zal in die zin aangepast worden (25/11/2022): #102

Op dit moment wordt rubbing_damage enkel voor A2 berekend
> package zal in die zin aangepast worden (25/11/2022): #102

NA indien bij A2-cirkel geen exact aantal genoteerd werd
=> om dit op te vangen toch in dataset voor A2 nr_regeneration vervangen door midwaarde van number_class (zie hoger)
> package zal *MOGELIJKS* in die zin aangepast worden (25/11/2022): #102

Ook steeds NA, omdat aantalsklasse gebruikt werd, en niet exact aantal.
> package zal in die zin aangepast worden (25/11/2022): #102

Hierna tijdelijke correcie van `rubbing_damage_perc`.

--> EERST `rubbing_damage_number`: soms nog NA ipv 0: KV's Hannecart en Rodebos:
gevraagd aan Peter in mail van 18/1/2023


```{r corr_rubbingnr_NA}
check_rubbingnr_NA <- data_regeneration %>% 
  # select(-contains(c("r_", "core_area"))) %>% 
  left_join(plotinfo %>% select(plot_id, period, game_impact_reg)) %>% 
  filter(is.na(rubbing_damage_number)) %>% 
  filter(game_impact_reg == TRUE) 

table(check_rubbingnr_NA$plot_id, check_rubbingnr_NA$period)
  #          3
  # 31000  309
  # 41000 1242
  # 43000  515

data_regeneration_ <- data_regeneration %>% 
  # select(-contains(c("r_", "core_area"))) %>% 
  left_join(plotinfo %>% select(plot_id, period, game_impact_reg),
            by = c("plot_id", "period")) %>% 
  mutate(rubbing_damage_number = ifelse(is.na(rubbing_damage_number) & game_impact_reg == TRUE,
                                  0,
                                  rubbing_damage_number)) %>% 
  select(-game_impact_reg)


data_regeneration <- data_regeneration_
```


--> VERVOLGENS `rubbing_damage_perc`: 
- NA wegens number = NA ipv 0
- !! ook NA wegens `nr_of_regeneration` leeg (enkel `number_class` ingevuld)


```{r corr_rubbingnr_perc}
check_rubbing_perc <- data_regeneration_ %>% 
  # select(-contains(c("r_", "core_area"))) %>% 
  left_join(plotinfo %>% select(plot_id, period, game_impact_reg)) %>% 
  filter(is.na(rubbing_damage_perc)) %>% 
  filter(game_impact_reg == TRUE) 

# 2de reden voor NA: de verjonging was initieel uitgedrukt als numberclass, en het percentage wordt berekend in load_data_regeneration obv het exacte aantal

head(table(check_rubbing_perc$plot_id, check_rubbing_perc$period))
unique(check_rubbing_perc$rubbing_damage_number)

data_regeneration_ <- data_regeneration %>% 
  # select(-contains(c("r_", "core_area"))) %>% 
  left_join(plotinfo %>% select(plot_id, period, game_impact_reg),
            by = c("plot_id", "period")) %>% 
  # correctie voor deze waar rubbing_nr in vorige chunck op 0 gezet is
  mutate(rubbing_damage_perc = ifelse(is.na(rubbing_damage_perc) & game_impact_reg == TRUE,
                                 100*rubbing_damage_number/nr_of_regeneration,  
                                 rubbing_damage_perc)) %>% 
  # correctie voor deze waar nr_of_reg niet ingevuld staat => daar numberclass gebruiken
  mutate(rubbing_damage_perc = ifelse(is.na(rubbing_damage_perc) & game_impact_reg == TRUE,
                                 100*rubbing_damage_number/number_class,  
                                 rubbing_damage_perc)) %>% 
  select(-game_impact_reg)

# OK, enkel deze met zowel nr_of_reg als rubbing_nr = 0, blijven NA 
# (logisch: 0/0: als er geen verjonging is, kan je ook het percentage schade niet begroten)
data_regeneration <- data_regeneration_
```

## Calculate regeneration 

```{r calc_reg}
regeneration <- calculate_regeneration(data_regeneration)

```


```{r CreateSeparateDataframesReg}
for (tablename in names(regeneration)) {
     assign(tablename, regeneration[[tablename]])
} 

```


## Check KV Kersselaerspleyn

Kloppen de resultaten nu? (voor 25/11/2022 een factor 10.75/1.4 verschil)

**Opbouw functie:**  
- data_regeneration_CA <- data_regeneration %>% filter(.data$plottype == "CA")    
- by_ca_species <- calculate_regeneration_core_area_species(data_regeneration_CA)  

- n_subplots = n_distinct(.data$subplot_id)  

- approx_nr_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$approx_nr_regeneration / .data$plotarea_ha, NA),

==> hogerop plotarea_ha aangepast aan 1.4 ha en 7.5 ha (ipv 10.75 ha)


```{r}
#   data_regeneration_CA <- data_regeneration %>%
#     filter(.data$plottype == "CA")
#   by_ca_species <- calculate_regeneration_core_area_species(data_regeneration_CA)

# is.na(subcircle): komt dat voor?
# data_regeneration %>% filter(is.na(subcircle) & !is.na(species)) %>% nrow() == 0
# NEE

```

```{r check_reg_Kerss_KV}
check_Kerss <- regeneration_by_core_area_species %>% 
  filter(plot_id == 11000)

check_Kerss <- regeneration_by_core_area_height_species %>% 
  filter(plot_id == 11000 & species == 7 & height_class == 3000)
# period = 2, zelfde resultaat als dataverwerking 2010 - OK

check_Kerss <- regeneration_by_core_area_height_species %>% 
  filter(plot_id == 11000 & species == 7 & height_class == 1000)
# period = 2, zelfde resultaat als dataverwerking 2010 - OK
```

Resultaten stemmen overeen met dataverwerking uit 2012.

```{r check_n_subplots_reg}
# controle n_subplots door runnen van deel van de functie -> OK!!
# table(by_plot_species_reg$n_subplots)
#    1   10   34   50   98  105  140  750 
# 5475   40   36  186  324   56   31   15 
```


## Check NA's

### Regeneration_by_plot

```{r}
names(regeneration_by_plot)
```

```{r}
col <- c("number_of_tree_species", "approx_nr_established_ha", "approx_nr_seedlings_ha",
         "mean_number_established_ha", "lci_number_established_ha", "uci_number_established_ha",
         "mean_number_seedlings_ha" , "lci_number_seedlings_ha", "uci_number_seedlings_ha")

regeneration_by_plot %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0

```

```{r}
col <- c("number_of_tree_species", "approx_nr_regeneration_ha",
         "mean_number_of_regeneration_ha", 
         "lci_number_of_regeneration_ha", "uci_number_of_regeneration_ha")

regeneration_by_plot_height %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0

```


```{r}
col <- c("approx_nr_regeneration_ha",
         "mean_number_of_regeneration_ha", 
         "lci_number_of_regeneration_ha", "uci_number_of_regeneration_ha")

regeneration_by_plot_height_species %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0

```

```{r}
col <- c("nr_of_subplots_with_regeneration", "perc_subplots_with_regeneration", 
         "approx_nr_established_ha", "approx_nr_seedlings_ha",
         "mean_number_established_ha", "lci_number_established_ha", "uci_number_established_ha",
         "mean_number_seedlings_ha" , "lci_number_seedlings_ha", "uci_number_seedlings_ha")

regeneration_by_core_area_species %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0

```


```{r}
col <- c("nr_of_subplots_with_regeneration", "perc_subplots_with_regeneration", 
         "approx_nr_regeneration_ha",
         "mean_number_of_regeneration_ha", 
         "lci_number_of_regeneration_ha", "uci_number_of_regeneration_ha")

regeneration_by_core_area_height_species %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0

```


#### TEMP: foute nullen vs NA bij mean_reg_ha - OK 25/11/2022

> blijkt momenteel opgelost te zijn (25/11/2022)

Bv. plot 130 vs 133: 

- als seedlings ingevuld zijn maar established niet (plot 133), dan NA ipv 0
- als niks ingevuld staat, maar wel een reg_date: dan 0 (plot 130) !! lci = 0 en uci = NA)

Data_regeneration bevat voor plot 133 enkel de seedlings en voor plot 130 enkel een lijn met 
heightclass = NA en species = NA (want geen verjonging)

```{r eval=FALSE}
check0 <- data_regeneration %>% filter(period == 1 & plot_id %in% c(133, 130))
# OK!

check <- regeneration_by_plot %>% filter(period == 1 & plot_id %in% c(133, 130))
# uci = NA is fout => aangepast zdd als sum & lci = 0, dan ci ook = 0 (ipv NaN)

check2 <- regeneration_by_plot_height %>% filter(period == 1 & plot_id %in% c(133, 130))
# uci = NA is fout => aangepast zdd als sum & lci = 0, dan ci ook = 0 (ipv NaN)

check3 <- regeneration_by_plot_height_species %>% filter(period == 1 & plot_id %in% c(133, 130))
# idem => misschien beter aanpassen in functie sum_interval!!
```


```{r eval=FALSE}
by_plot1 <- data_regeneration %>%
    mutate(
      plotarea_ha = ifelse(.data$plottype == "CA", 0.01, .data$plotarea_ha),
      min_number_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",  
               # als subcircle = NA, dan is aantal = 0
               # MAAR dit geldt enkel als er géén verjonging is
               # DUS als subcircle A1 is, en er is geen subcircle A2, dan hebben we hier NA!!
               # en omgekeerd ook
               # (subcircle wordt ook ingevuld bij core area's)
               # maar hier kunnen we geen extra lijn aanmaken 
               .data$min_number_of_regeneration / .data$plotarea_ha, NA),
      max_number_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$max_number_of_regeneration / .data$plotarea_ha, NA),
      min_number_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$min_number_of_regeneration / .data$plotarea_ha, NA),
      max_number_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$max_number_of_regeneration / .data$plotarea_ha, NA),
      approx_nr_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$approx_nr_regeneration / .data$plotarea_ha, NA),
      approx_nr_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$approx_nr_regeneration / .data$plotarea_ha, NA)
    ) 

by_plot2 <- data_regeneration %>%
    mutate(
      plotarea_ha = ifelse(.data$plottype == "CA", 0.01, .data$plotarea_ha),
      min_number_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$min_number_of_regeneration / .data$plotarea_ha, NA),
      max_number_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$max_number_of_regeneration / .data$plotarea_ha, NA),
      min_number_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$min_number_of_regeneration / .data$plotarea_ha, NA),
      max_number_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$max_number_of_regeneration / .data$plotarea_ha, NA),
      approx_nr_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$approx_nr_regeneration / .data$plotarea_ha, NA),
      approx_nr_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$approx_nr_regeneration / .data$plotarea_ha, NA)
    ) %>% 
    group_by(
      .data$plot_id, .data$year, .data$period, .data$subplot_id
    ) %>%
    summarise(
      established_interval =
        sum_intervals(
          var_min = .data$min_number_established_ha,
          var_max = .data$max_number_established_ha,
          transformation = "log", na_rm = TRUE
        ),
      seedlings_interval =
        sum_intervals(
          var_min = .data$min_number_seedlings_ha,
          var_max = .data$max_number_seedlings_ha,
          transformation = "log", na_rm = TRUE
        )
    ) %>%
    ungroup() 

by_plot3 <- data_regeneration %>%
    mutate(
      plotarea_ha = ifelse(.data$plottype == "CA", 0.01, .data$plotarea_ha),
      min_number_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$min_number_of_regeneration / .data$plotarea_ha, NA),
      max_number_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$max_number_of_regeneration / .data$plotarea_ha, NA),
      min_number_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$min_number_of_regeneration / .data$plotarea_ha, NA),
      max_number_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$max_number_of_regeneration / .data$plotarea_ha, NA),
      approx_nr_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$approx_nr_regeneration / .data$plotarea_ha, NA),
      approx_nr_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$approx_nr_regeneration / .data$plotarea_ha, NA)
    ) %>% 
    group_by(
      .data$plot_id, .data$year, .data$period, .data$subplot_id
    ) %>%
    summarise(
      established_interval =
        sum_intervals(
          var_min = .data$min_number_established_ha,
          var_max = .data$max_number_established_ha,
          transformation = "log", na_rm = TRUE
        ),
      seedlings_interval =
        sum_intervals(
          var_min = .data$min_number_seedlings_ha,
          var_max = .data$max_number_seedlings_ha,
          transformation = "log", na_rm = TRUE
        ),
      approx_nr_established_ha =
        sum(.data$approx_nr_established_ha, na.rm = TRUE),
      approx_nr_seedlings_ha = sum(.data$approx_nr_seedlings_ha, na.rm = TRUE)
    ) %>%
    ungroup() %>%
    mutate(
      mean_number_established_ha = .data$established_interval$sum,
      lci_number_established_ha = .data$established_interval$lci,
      uci_number_established_ha = .data$established_interval$uci,
      mean_number_seedlings_ha = .data$seedlings_interval$sum,
      lci_number_seedlings_ha = .data$seedlings_interval$lci,
      # uci_number_seedlings_ha = 
      #   ifelse(.data$seedlings_interval$sum == 0 
      #          & .data$seedlings_interval$lci == 0
      #          & is.na(.data$seedlings_interval$uci), 
      #          0, .data$seedlings_interval$uci),
      uci_number_seedlings_ha = .data$seedlings_interval$uci
    ) %>% 
  mutate(mean_number_established_ha = 
           ifelse(is.na(.data$mean_number_established_ha) 
                  & .data$mean_number_seedlings_ha > 0
                  , 0
                  , .data$mean_number_established_ha),
         lci_number_established_ha = 
           ifelse(is.na(.data$lci_number_established_ha) 
                  & .data$mean_number_seedlings_ha > 0
                  , 0
                  , .data$lci_number_established_ha),
         uci_number_established_ha = 
           ifelse(is.na(.data$uci_number_established_ha) 
                  & .data$mean_number_seedlings_ha > 0
                  , 0
                  , .data$uci_number_established_ha),
         mean_number_seedlings_ha = 
           ifelse(is.na(.data$mean_number_seedlings_ha) 
                  & .data$mean_number_established_ha > 0
                  , 0
                  , .data$mean_number_seedlings_ha),
         lci_number_seedlings_ha = 
           ifelse(is.na(.data$lci_number_seedlings_ha) 
                  & .data$mean_number_established_ha > 0
                  , 0
                  , .data$lci_number_seedlings_ha),
         uci_number_seedlings_ha = 
           ifelse(is.na(.data$uci_number_seedlings_ha) 
                  & .data$mean_number_established_ha > 0
                  , 0
                  , .data$uci_number_seedlings_ha),
         approx_nr_established_ha = 
           ifelse(is.na(.data$approx_nr_established_ha) 
                  & .data$approx_nr_seedlings_ha > 0
                  , 0
                  , .data$approx_nr_established_ha),
         approx_nr_seedlings_ha = 
           ifelse(is.na(.data$approx_nr_seedlings_ha) 
                  & .data$approx_nr_established_ha > 0
                  , 0
                  , .data$approx_nr_seedlings_ha)
  )
         

by_plot3 <- calculate_regeneration_plot(data_regeneration)

```

```{r eval=FALSE}
names(by_plot1)

check4 <- by_plot1 %>% filter(period == 1 & plot_id %in% c(133, 130, 138)) %>% 
  select(plot_id, subcircle, date_regeneration, height_class, contains(c("min_number", "max_number", "approx")))

check5 <- by_plot2 %>% filter(period == 1 & plot_id %in% c(133, 130))

check6 <- by_plot3 %>% filter(period == 1 & plot_id %in% c(133, 130, 138))

str(check6)
```



#### TEMP: fout percentage rubbing dammage

`rubbing_damage_perc` is hogerop gecorrigeerd in `data_regeneration`
!! MAAR: bij berekening van plot-resultaten wordt opnieuw teruggegrepen naar 
aantal verjonging en aantal rubbing om dat percentage te berekenen
> package zal aangepast worden (25/11/2022): #102

! er wordt "Inf" gecrëeerd voor A1's, want in code wordt gedeeld door sum(....*A2):
bijgevolg steeds 0 voor A1
> package zal MOGELIJKS in die zin aangepast worden (25/11/2022): #102

in de functies wordt gebruik gemaakt van `rubbing_damage_number`, berekend als som van ...
Maar dat wordt 0 als je enkel NA's optelt 
            # > sum(c(NA, NA), na.rm = TRUE)
            # [1] 0
=> rubbing_damage_perc wordt ook 0 (=> not_na_rubbing wordt TRUE (of 1))
> aanpassen in package (issue #102): gevraagd 19/1/2023
(nu tijdelijk alle gecorrigeerde functies hier runnen)

```{r eval=FALSE}
names(regeneration_by_plot)

check0 <- regeneration_by_plot %>% 
  left_join(plotinfo %>% select(plot_id, period, game_impact_reg)) %>% 
  filter(is.na(rubbing_damage_perc) & number_of_tree_species > 0) %>% 
  filter(game_impact_reg == TRUE) 

# niet gelegen aan data_regeneration, maar perc wordt opnieuw berekend  
data_regeneration %>% filter(plot_id == 707) %>% 
  filter(period == 2) %>% 
  select(plot_id, period, subcircle, date_regeneration, height_class, species, number_class, nr_of_regeneration, contains(c("rubbing", "min_number", "max_number", "approx")))

```

> Tijdelijke correctie van de NA's kan enkel door alle reg-functies lichtjes aangepast 
hier opnieuw te runnen:
  by_plot_height <- calculate_regeneration_plot_height(data_regeneration)
  by_plot <- calculate_regeneration_plot(data_regeneration)
  by_plot_height_species <-
    calculate_regeneration_plot_height_species(data_regeneration)
  data_regeneration_CA <- data_regeneration %>%
    filter(.data$plottype == "CA")
  by_ca_species <- calculate_regeneration_core_area_species(data_regeneration_CA)
  by_ca_height_species <-
    calculate_regeneration_core_area_height_species(data_regeneration_CA)

```{r tmp_fctie_sum_intervals}
sum_intervals <-
  function(var_min, var_max, transformation = NA, na_rm = FALSE) {

  if (na_rm) {
    var_min <- var_min[!is.na(var_min)]
    var_max <- var_max[!is.na(var_max)]
  }
  if (length(var_min) == 0) {
    return(data.frame(n_obs = NA, sum = NA, lci = NA, uci = NA))
  }

  if (!is.na(transformation) & transformation == "log") {
    value <- exp((log(var_min + 1e-10) + log(var_max)) / 2)
    variance <- ((log(var_max) - log(var_min + 1e-10)) / (2 * 1.96)) ^ 2
  } else {
    value <- (var_min + var_max) / 2
    variance <- ((var_max - var_min) / (2 * 1.96)) ^ 2
  }

  result <- data.frame(n_obs = length(value))
  result$sum <-
    ifelse(
      !is.na(transformation) & transformation == "log",
      log(sum(value)),
      sum(value)
    )
  variance <- sum(variance) / result$n_obs
  result$lci <- result$sum - 1.96 * sqrt(variance) / sqrt(result$n_obs)
  result$uci <- result$sum + 1.96 * sqrt(variance) / sqrt(result$n_obs)

  if (!is.na(transformation) & transformation == "log") {
    result$sum <- exp(result$sum)
    result$lci <- exp(result$lci)
    result$uci <- exp(result$uci)
  }


  if (is.na(result$uci) & result$sum == 0 & result$lci == 0) {
    result$uci <- 0
  }

  return(result)
}

```


!! rubbing_damage_number wordt 0 als je NA's optelt 
(`rubbing_damage_nr = sum(.data$rubbing_damage_number, na.rm = TRUE`)
Obv daarvan wordt dan perc berekend en dan not_na_rubbing!!
`not_na_rubbing = sum(!is.na(.data$rubbing_damage_perc))`

=> beter obv `game_impact_reg` 
    
```{r by_plot}
  by_plot <- data_regeneration %>%
   left_join(plotinfo %>% select(plot_id, period, game_impact_reg),
            by = c("plot_id", "period")) %>% 
    mutate(
      plotarea_ha = ifelse(.data$plottype == "CA", 0.01, .data$plotarea_ha),
      min_number_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$min_number_of_regeneration / .data$plotarea_ha, NA),
      max_number_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$max_number_of_regeneration / .data$plotarea_ha, NA),
      min_number_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$min_number_of_regeneration / .data$plotarea_ha, NA),
      max_number_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$max_number_of_regeneration / .data$plotarea_ha, NA),
      approx_nr_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$approx_nr_regeneration / .data$plotarea_ha, NA),
      approx_nr_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$approx_nr_regeneration / .data$plotarea_ha, NA)
    ) %>%
    group_by(
      .data$plot_id, .data$year, .data$period, .data$subplot_id
      , .data$game_impact_reg  ## toegevoegd
    ) %>%
    summarise(
      number_of_tree_species = n_distinct(.data$species, na.rm = TRUE),
      established_interval =
        sum_intervals(
          var_min = .data$min_number_established_ha,
          var_max = .data$max_number_established_ha,
          transformation = "log", na_rm = TRUE
        ),
      seedlings_interval =
        sum_intervals(
          var_min = .data$min_number_seedlings_ha,
          var_max = .data$max_number_seedlings_ha,
          transformation = "log", na_rm = TRUE
        ),
      
      ##### tijdelijk extra toegevoegd ter controle
        #     rubbing_damage_nr =
        # sum(.data$rubbing_damage_number, na.rm = TRUE),
      # !! rubbing_damage_number wordt 0 als je enkel NA's optelt => 
      # rubbing_damage_perc wordt ook 0 => not_na_rubbing wordt TRUE (of 1)
            # > sum(c(NA, NA), na.rm = TRUE)
            # [1] 0
      #####
      
      rubbing_damage_perc =
        sum(.data$rubbing_damage_number, na.rm = TRUE) * 100 /
        sum(.data$approx_nr_regeneration, na.rm = TRUE), 
          #  nr_of_regeneration* (.data$subcircle == "A2"): !! ook in A1 opgemeten
      not_na_rubbing = sum(!is.na(.data$rubbing_damage_perc)),
      approx_nr_established_ha =
        sum(.data$approx_nr_established_ha, na.rm = TRUE),
      approx_nr_seedlings_ha = sum(.data$approx_nr_seedlings_ha, na.rm = TRUE)
    ) %>%
    ungroup() %>%
    mutate(
      mean_number_established_ha = .data$established_interval$sum,
      lci_number_established_ha = .data$established_interval$lci,
      uci_number_established_ha = .data$established_interval$uci,
      mean_number_seedlings_ha = .data$seedlings_interval$sum,
      lci_number_seedlings_ha = .data$seedlings_interval$lci,
      uci_number_seedlings_ha = .data$seedlings_interval$uci,
      # rubbing_damage_perc =
      #   ifelse(
      #     .data$not_na_rubbing > 0 & .data$rubbing_damage_perc > 0,
      #     .data$rubbing_damage_perc,
      #     NA
        # )
      rubbing_damage_perc =
        ifelse(
          .data$game_impact_reg == FALSE & .data$rubbing_damage_perc == 0,
          NA, 
          .data$rubbing_damage_perc
      )
    ) %>%
    mutate(mean_number_established_ha =
             ifelse(is.na(.data$mean_number_established_ha)
                    & .data$mean_number_seedlings_ha > 0
                    , 0
                    , .data$mean_number_established_ha),
           lci_number_established_ha =
             ifelse(is.na(.data$lci_number_established_ha)
                    & .data$mean_number_seedlings_ha > 0
                    , 0
                    , .data$lci_number_established_ha),
           uci_number_established_ha =
             ifelse(is.na(.data$uci_number_established_ha)
                    & .data$mean_number_seedlings_ha > 0
                    , 0
                    , .data$uci_number_established_ha),
           mean_number_seedlings_ha =
             ifelse(is.na(.data$mean_number_seedlings_ha)
                    & .data$mean_number_established_ha > 0
                    , 0
                    , .data$mean_number_seedlings_ha),
           lci_number_seedlings_ha =
             ifelse(is.na(.data$lci_number_seedlings_ha)
                    & .data$mean_number_established_ha > 0
                    , 0
                    , .data$lci_number_seedlings_ha),
           uci_number_seedlings_ha =
             ifelse(is.na(.data$uci_number_seedlings_ha)
                    & .data$mean_number_established_ha > 0
                    , 0
                    , .data$uci_number_seedlings_ha),
           approx_nr_established_ha =
             ifelse(is.na(.data$approx_nr_established_ha)
                    & .data$approx_nr_seedlings_ha > 0
                    , 0
                    , .data$approx_nr_established_ha),
           approx_nr_seedlings_ha =
             ifelse(is.na(.data$approx_nr_seedlings_ha)
                    & .data$approx_nr_established_ha > 0
                    , 0
                    , .data$approx_nr_seedlings_ha)
    ) %>%
    select(
      -.data$established_interval, -.data$seedlings_interval,
      -.data$not_na_rubbing, -.data$game_impact_reg
    )

```


```{r check_reg_rubbing_plot, eval = FALSE}
t <- by_plot %>% filter(not_na_rubbing > 0 & game_impact_reg == FALSE)
# allemaal rubbing_nr = 0 !! is foute som (som van NA's = 1)

by_plot %>% filter(not_na_rubbing == 0 & game_impact_reg == TRUE)                   
# dat zijn deze zonder enige verjonging => deze mogen NA blijven
by_plot %>% filter(not_na_rubbing == 0 & game_impact_reg == TRUE 
                   & approx_nr_established_ha != 0 & approx_nr_seedlings_ha != 0) %>% 
  nrow() == 0


t <- by_plot %>% filter(game_impact_reg == FALSE)
t <- by_plot %>% filter(game_impact_reg == TRUE)
```


```{r by_plot_height}
by_plot_height <- data_regeneration %>%
    left_join(plotinfo %>% select(plot_id, period, game_impact_reg),
            by = c("plot_id", "period")) %>% 
    mutate(
      plotarea_ha = ifelse(.data$plottype == "CA", 0.01, .data$plotarea_ha)
    ) %>%
    group_by(
      .data$plot_id, .data$year, .data$period, .data$height_class,
      .data$subplot_id, .data$plotarea_ha, .data$game_impact_reg
    ) %>%
    summarise(
      number_of_tree_species = n_distinct(.data$species, na.rm = TRUE),
      rubbing_damage_perc =
        sum(.data$rubbing_damage_number, na.rm = TRUE) * 100 /
        sum(.data$approx_nr_regeneration, na.rm = TRUE), 
        # sum(.data$nr_of_regeneration * (.data$subcircle == "A2"), na.rm = TRUE),
      not_na_rubbing = sum(!is.na(.data$rubbing_damage_perc)),
      interval =
        sum_intervals(
          var_min = .data$min_number_of_regeneration,
          var_max = .data$max_number_of_regeneration,
          transformation = "log", na_rm = TRUE
        ),
      approx_nr_regeneration_ha =
        sum(.data$approx_nr_regeneration) / unique(.data$plotarea_ha)
    ) %>%
    ungroup() %>%
    mutate(
      mean_number_of_regeneration_ha = .data$interval$sum / .data$plotarea_ha,
      lci_number_of_regeneration_ha = .data$interval$lci / .data$plotarea_ha,
      uci_number_of_regeneration_ha = .data$interval$uci / .data$plotarea_ha,
      # rubbing_damage_perc =
      #   ifelse(
      #     .data$not_na_rubbing > 0 & .data$rubbing_damage_perc > 0,
      #     .data$rubbing_damage_perc,
      #     NA
      #   )
      rubbing_damage_perc =
        ifelse(
          .data$game_impact_reg == FALSE & .data$rubbing_damage_perc == 0,
          NA, 
          .data$rubbing_damage_perc
      )
    ) %>%
    select(
      -.data$interval, -.data$plotarea_ha,
      -.data$not_na_rubbing, -.data$game_impact_reg
    )
  
```


```{r by_plot_height_species}
by_plot_height_species <- data_regeneration %>%
  left_join(plotinfo %>% select(plot_id, period, game_impact_reg),
            by = c("plot_id", "period")) %>%
    mutate(
      plotarea_ha = ifelse(.data$plottype == "CA", 0.01, .data$plotarea_ha)
    ) %>%
    group_by(
      .data$plot_id, .data$year, .data$period, .data$height_class,
      .data$species, .data$subplot_id, .data$plotarea_ha, .data$game_impact_reg
    ) %>%
    summarise(
      rubbing_damage_perc =
        sum(.data$rubbing_damage_number, na.rm = TRUE) * 100 /
        sum(.data$approx_nr_regeneration, na.rm = TRUE), 
        # sum(.data$nr_of_regeneration * (.data$subcircle == "A2"), na.rm = TRUE),
      not_na_rubbing = sum(!is.na(.data$rubbing_damage_perc)),
      interval =
        sum_intervals(
          var_min = .data$min_number_of_regeneration,
          var_max = .data$max_number_of_regeneration,
          transformation = "log", na_rm = TRUE
        ),
      approx_nr_regeneration_ha =
        sum(.data$approx_nr_regeneration) / unique(.data$plotarea_ha)
    ) %>%
    ungroup() %>%
    mutate(
      mean_number_of_regeneration_ha = .data$interval$sum / .data$plotarea_ha,
      lci_number_of_regeneration_ha = .data$interval$lci / .data$plotarea_ha,
      uci_number_of_regeneration_ha = .data$interval$uci / .data$plotarea_ha,
      # rubbing_damage_perc =
      #   ifelse(
      #     .data$not_na_rubbing > 0 & .data$rubbing_damage_perc > 0,
      #     .data$rubbing_damage_perc,
      #     NA
      #   )
      rubbing_damage_perc =
        ifelse(
          .data$game_impact_reg == FALSE & .data$rubbing_damage_perc == 0,
          NA, 
          .data$rubbing_damage_perc
      )
    ) %>%
    select(
      -.data$interval, -.data$plotarea_ha,
      -.data$not_na_rubbing, -.data$game_impact_reg
    )
```


```{r by_ca_species}
data_regeneration_CA <- data_regeneration %>%
    filter(.data$plottype == "CA")

by_ca_species <- data_regeneration_CA %>%
  left_join(plotinfo %>% select(plot_id, period, game_impact_reg),
            by = c("plot_id", "period")) %>%
    group_by(.data$plot_id, .data$period) %>%
    mutate(
      n_subplots = n_distinct(.data$subplot_id),
      min_number_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$min_number_of_regeneration / .data$plotarea_ha, NA),
      max_number_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$max_number_of_regeneration / .data$plotarea_ha, NA),
      min_number_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$min_number_of_regeneration / .data$plotarea_ha, NA),
      max_number_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$max_number_of_regeneration / .data$plotarea_ha, NA),
      approx_nr_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$approx_nr_regeneration / .data$plotarea_ha, NA),
      approx_nr_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$approx_nr_regeneration / .data$plotarea_ha, NA)
    ) %>%
    ungroup() %>%
    group_by(
      .data$plot_id, .data$year, .data$period, .data$species,
      .data$game_impact_reg
    ) %>%
    summarise(
      nr_of_subplots_with_regeneration = n_distinct(.data$subplot_id),
      perc_subplots_with_regeneration =
        .data$nr_of_subplots_with_regeneration * 100 / unique(.data$n_subplots),
      established_interval =
        sum_intervals(
          var_min = .data$min_number_established_ha,
          var_max = .data$max_number_established_ha,
          transformation = "log", na_rm = TRUE
        ),
      seedlings_interval =
        sum_intervals(
          var_min = .data$min_number_seedlings_ha,
          var_max = .data$max_number_seedlings_ha,
          transformation = "log", na_rm = TRUE
        ),
      rubbing_damage_perc =
        sum(.data$rubbing_damage_number, na.rm = TRUE) * 100 /
        sum(.data$approx_nr_regeneration, na.rm = TRUE), 
        # sum(.data$nr_of_regeneration * (.data$subcircle == "A2"), na.rm = TRUE),
      not_na_rubbing = sum(!is.na(.data$rubbing_damage_perc)),
      approx_nr_established_ha =
        sum(.data$approx_nr_established_ha, na.rm = TRUE),
      approx_nr_seedlings_ha = sum(.data$approx_nr_seedlings_ha, na.rm = TRUE)
    ) %>%
    ungroup() %>%
    mutate(
      mean_number_established_ha = .data$established_interval$sum,
      lci_number_established_ha = .data$established_interval$lci,
      uci_number_established_ha = .data$established_interval$uci,
      mean_number_seedlings_ha = .data$seedlings_interval$sum,
      lci_number_seedlings_ha = .data$seedlings_interval$lci,
      uci_number_seedlings_ha = .data$seedlings_interval$uci,
      # rubbing_damage_perc =
      #   ifelse(
      #     .data$not_na_rubbing > 0 & .data$rubbing_damage_perc > 0,
      #     .data$rubbing_damage_perc,
      #     NA
      #   )
      rubbing_damage_perc =
        ifelse(
          .data$game_impact_reg == FALSE & .data$rubbing_damage_perc == 0,
          NA, 
          .data$rubbing_damage_perc
      )
    ) %>%
    mutate(mean_number_established_ha =
             ifelse(is.na(.data$mean_number_established_ha)
                    & .data$mean_number_seedlings_ha > 0
                    , 0
                    , .data$mean_number_established_ha),
           lci_number_established_ha =
             ifelse(is.na(.data$lci_number_established_ha)
                    & .data$mean_number_seedlings_ha > 0
                    , 0
                    , .data$lci_number_established_ha),
           uci_number_established_ha =
             ifelse(is.na(.data$uci_number_established_ha)
                    & .data$mean_number_seedlings_ha > 0
                    , 0
                    , .data$uci_number_established_ha),
           mean_number_seedlings_ha =
             ifelse(is.na(.data$mean_number_seedlings_ha)
                    & .data$mean_number_established_ha > 0
                    , 0
                    , .data$mean_number_seedlings_ha),
           lci_number_seedlings_ha =
             ifelse(is.na(.data$lci_number_seedlings_ha)
                    & .data$mean_number_established_ha > 0
                    , 0
                    , .data$lci_number_seedlings_ha),
           uci_number_seedlings_ha =
             ifelse(is.na(.data$uci_number_seedlings_ha)
                    & .data$mean_number_established_ha > 0
                    , 0
                    , .data$uci_number_seedlings_ha),
           approx_nr_established_ha =
             ifelse(is.na(.data$approx_nr_established_ha)
                    & .data$approx_nr_seedlings_ha > 0
                    , 0
                    , .data$approx_nr_established_ha),
           approx_nr_seedlings_ha =
             ifelse(is.na(.data$approx_nr_seedlings_ha)
                    & .data$approx_nr_established_ha > 0
                    , 0
                    , .data$approx_nr_seedlings_ha)
    ) %>%
    select(
      -.data$established_interval, -.data$seedlings_interval,
      -.data$not_na_rubbing, -.data$game_impact_reg
    )

```

```{r by_ca_height_species}
data_regeneration_CA <- data_regeneration %>%
    filter(.data$plottype == "CA")

by_ca_height_species <- data_regeneration_CA %>%
  left_join(plotinfo %>% select(plot_id, period, game_impact_reg),
            by = c("plot_id", "period")) %>%
    group_by(.data$plot_id, .data$period) %>%
    mutate(
      n_subplots = n_distinct(.data$subplot_id)
    ) %>%
    ungroup() %>%
    group_by(
      .data$plot_id, .data$year, .data$period, .data$height_class,
      .data$species, .data$plotarea_ha,
      .data$game_impact_reg
    ) %>%
    summarise(
      nr_of_subplots_with_regeneration = n_distinct(.data$subplot_id),
      perc_subplots_with_regeneration =
        .data$nr_of_subplots_with_regeneration * 100 / unique(.data$n_subplots),
      rubbing_damage_perc =
        sum(.data$rubbing_damage_number, na.rm = TRUE) * 100 /
        sum(.data$approx_nr_regeneration, na.rm = TRUE),
        # sum(.data$nr_of_regeneration * (.data$subcircle == "A2"), na.rm = TRUE),
      not_na_rubbing = sum(!is.na(.data$rubbing_damage_perc)),
      interval =
        sum_intervals(
          var_min = .data$min_number_of_regeneration,
          var_max = .data$max_number_of_regeneration,
          transformation = "log", na_rm = TRUE
        ),
      approx_nr_regeneration_ha =
        sum(.data$approx_nr_regeneration) / unique(.data$plotarea_ha)
    ) %>%
    ungroup() %>%
    mutate(
      mean_number_of_regeneration_ha = .data$interval$sum / .data$plotarea_ha,
      lci_number_of_regeneration_ha = .data$interval$lci / .data$plotarea_ha,
      uci_number_of_regeneration_ha = .data$interval$uci / .data$plotarea_ha,
      # rubbing_damage_perc =
      #   ifelse(
      #     .data$not_na_rubbing > 0 & .data$rubbing_damage_perc > 0,
      #     .data$rubbing_damage_perc,
      #     NA
      #   )
      rubbing_damage_perc =
        ifelse(
          .data$game_impact_reg == FALSE & .data$rubbing_damage_perc == 0,
          NA, 
          .data$rubbing_damage_perc
      )
    ) %>%
    select(
      -.data$interval, -.data$plotarea_ha,
      -.data$not_na_rubbing, -.data$game_impact_reg
    )

```

> Alle reg-resultaten terug in een lijst stoppen

```{r combine_reg}
regeneration_ <- list(
      regeneration_by_plot_height = by_plot_height,
      regeneration_by_plot = by_plot,
      regeneration_by_plot_height_species = by_plot_height_species,
      regeneration_by_core_area_species = by_ca_species,
      regeneration_by_core_area_height_species = by_ca_height_species
    )

regeneration <- regeneration_
```


## Export

```{r join_plottype_surveynr_BR_reg}
reg_plotinfo <- lapply(regeneration, function(x) left_join(x, plotinfo %>% select(plot_id, forest_reserve, plottype, period, survey_number), by = c("plot_id", "period")))
# lapply: same function over all elements of the list

```

```{r save_reg_git, eval = FALSE}
save_results_git(
  results = regeneration,
  repo_path = path_to_git_forresdat,
  strict = TRUE,
  # strict = FALSE
)
```


```{r save_reg_git_manueel, eval = FALSE}
# manueel - eigen simpele functie
save_results_tsv(regeneration, 
                 root = path_to_forresdat_data,
                 strict = FALSE)
```


```{r save_reg_access_csv, eval = FALSE}
save_results_csv (
  results = reg_plotinfo,
  output_dir = path_to_plotlevel_csv
)

# afgerond voor export naar access
# de df's van CP mogen op 0 afgerond worden (= 1ste drie dataframes)
# de KV's op 2 cijfers na de komma

reg_CP <- reg_plotinfo[c(1:3)]
reg_CP <- reg_CP %>% 
  lapply(., function(x) round_df(x, 0)) 
  
reg_CA  <- reg_plotinfo[c(4:5)]
reg_CA <- reg_CA %>% 
  lapply(., function(x) round_df(x, 2))

reg_round <- c(reg_CP, reg_CA)

save_results_access(
    results = reg_round,
    database = path_to_analysis_set_db,
    remove_tables = TRUE
  )

```




Direct naar gdrive exporteren (csv): 
naar **/PRJ_BOSECO_ALGEMEEN/PRJ_BR_AanvraagGegevens/!METADATA-ALL_PLOTS/_plot-level-data/**

```{r save_reg_gdrive, eval = FALSE}
save_results_csv(
    results = reg_plotinfo,
    output_dir = path_to_plotlevel_gdrive
    )

```





# Vegetation - OK - 19/1/2023

## Calculate

```{r load_veg}
data_vegetation <-
  load_data_vegetation(
    database = path_to_fieldmap_db,
    processed = TRUE
  )
data_herblayer <-
  load_data_herblayer(
    database = path_to_fieldmap_db,
    processed = TRUE
  )

vegetation <- calculate_vegetation(data_vegetation, data_herblayer)
```

## Controle plot-level-data

```{r CreateSeparateDataframesVeg}
for (tablename in names(vegetation)) {
     assign(tablename, vegetation[[tablename]])
} 

```


```{r}
# plot 1176, periode 1: niet in veg_by_plot => Els gevraagd om dit te corrigeren (nov 2022)

data_vegetation %>% filter(plot_id == 1176)
data_herblayer %>% filter(plot_id == 1176 & period == 1)

vegetation_by_plot %>% filter(plot_id == 1176 & period == 1)

```


## Controle KV Kerss

n_subplots is fout: 710 ipv 750 (2eset wel OK, 140)

calculate_vegetation_core_area_species <- function(data_herblayer, data_vegetation) {
  by_core_area_species <- data_herblayer %>%
    group_by(.data$plot_id, .data$period) %>%
    mutate(
      n_subplots = n_distinct(.data$subplot_id)

OPGEPAST: `n_subplots` zou moeten bepaald worden op "data_vegetation", want in herblayer 
zitten enkel de subplots waar een soort waargenomen werd

> aan els gevraagd om dit aan te passen in PR van reg_AL (29/11/2022)
Hier niet aangepast, geeft geen immens grote afwijking, tijdelijk zo laten ...

Bij regeneration wordt van regeneration-subplots vertrokken, dus daar is het aantal subplots wel correct.

```{r check_n_subplots_veg}
# controle n_subplots door runnen van deel van de functie -> OK!!
table(by_core_area_species$n_subplots)
#     1    10    34    50    97    98   105   140   710 
# 26466   174   101   724    34   917   194   111    76 

# ? 97 
# plot 41000, period 3, subplot 00.60, ID 22 is leeg en wordt daarom niet meegerekend

# ? 710 ipv 750?
# waarom bij reg geen probleem?
table(by_plot_species_reg$n_subplots)
```

```{r check_veg_Kerss_KV}
check_Kerss <- vegetation_by_core_area_species %>% 
  filter(plot_id == 11000)

check_Kerss <- vegetation_by_core_area_species %>% 
  filter(plot_id == 11000 & species == 71)  # beuk
# period = 2, zelfde resultaat als dataverwerking 2010 - OK

```

Resultaten stemmen overeen met dataverwerking uit 2012, muv percentage subplots, period 1.


## Check NA's

```{r}
names(vegetation_by_plot)
summary(vegetation_by_plot)
# veel covers niet ingevuld ...
```

```{r}
col <- c("number_of_species", "cumm_herb_coverage_class_average_perc")

vegetation_by_plot %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0

```

```{r}
names(vegetation_by_core_area_species)

col <- c("number_of_subplots_with_vegetation", "perc_of_subplots", "mean_coverage_class_average_perc")

vegetation_by_core_area_species %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0

```

### TEMP: browse_index niet ingevuld: NA ipv 100 (no browsing)

!! browse_index : NA in herblayer_by_plot, terwijl het 100 (= no browsing) zou moeten zijn (game_impact_veg  = TRUE bij plotinfo )

!! heeft te maken met onvolledig aanvullen van FM-DC: NA zou 100 moeten worden bij voorafgaandelijke datacontrole

? bij welke bosreservaten komt dit voor? 
Enkel 31000 41000 43000 (Hannecart en Rodebos)

> Hierna tijdelijke correctie (gevraagd aan Peter 17/1/2023)

```{r}
check_brows_0 <- data_herblayer %>% 
  left_join(plotinfo %>% select(plot_id, period, game_impact_veg)) %>% 
  filter(is.na(browse_index_id)) %>% 
  filter(game_impact_veg == TRUE) 
           
table(check_brows_0$plot_id, check_brows_0$period)
#           2    3
#   21000 1112    0
#   31000    0  491
#   41000    0  907
#   43000    0  687
```

```{r corr_browseindex_NA}
data_herblayer_ <- data_herblayer %>% 
  left_join(plotinfo %>% select(plot_id, period, game_impact_veg),
            by = c("plot_id", "period")) %>% 
  mutate(browse_index_id = ifelse(is.na(browse_index_id) & game_impact_veg == TRUE,
                                  100,
                                  browse_index_id)) %>% 
  select(-game_impact_veg)


data_herblayer <- data_herblayer_
```

> Na correctie data_herblayer ook veg_by_core_area_species opnieuw laten berekenen
(de andere plot-level-resultaten mbt vegetatie zijn OK, daar komt brwosing niet in voor)

```{r corr_browseindex_CA}
check_CA_browsing <- vegetation_by_core_area_species %>% 
  left_join(plotinfo %>% select(plot_id, period, game_impact_veg),
            by = c("plot_id", "period")) %>% 
  filter(is.na(perc_of_subplots_browsed)) %>% 
  filter(game_impact_veg == TRUE) 

table(check_CA_browsing$plot_id, check_CA_browsing$period)  
  #       2  3
  # 21000 29  0
  # 31000  0 49
  # 41000  0 29
  # 43000  0 56

# herberekenen met gecorrigeerde data_herblayer
data_herblayer_CA <- data_herblayer %>%
    filter(.data$plottype == "CA")

vegetation_by_core_area_species_ <- calculate_vegetation_core_area_species(data_herblayer_CA)

vegetation_by_core_area_species <- vegetation_by_core_area_species_

```

> Alle vegetatie-resultaten terug in een lijst stoppen

```{r combine_veg}
vegetation_ <- list(
      vegetation_by_plot = vegetation_by_plot,
      vegetation_by_core_area_species = vegetation_by_core_area_species
    )

vegetation <- vegetation_
```


## Export

```{r join_plotinfo_veg}
veg_plotinfo <- lapply(vegetation, function(x) left_join(x, plotinfo %>% select(plot_id, forest_reserve, plottype, period, survey_number), by = c("plot_id", "period")))
# lapply: same function over all elements of the list
```


```{r save_veg_git, eval = FALSE}
# geen plotinfo naar git
save_results_git(
  results = vegetation,
  repo_path = path_to_git_forresdat,
  # strict = TRUE, 
  strict = TRUE
)
```

```{r save_veg_git_manueel, eval = FALSE}
# manueel - eigen simpele functie - als save_results_git niet werkt
save_results_tsv(vegetation, 
                 root = path_to_forresdat_data, 
                 strict = FALSE)
```


```{r save_veg_access_csv, eval = FALSE}
# volgende functie heb ik zelf geschreven, zit niet in het package!
save_results_csv (
    results = veg_plotinfo,
    output_dir = path_to_plotlevel_csv
    )

# afgerond voor export naar access
# de df's van CP mogen op 0 afgerond worden (= 1ste drie dataframes)
# de KV's op 2 cijfers na de komma
veg_round <- veg_plotinfo %>% 
  lapply(., function(x) round_df(x, 2))

# save_results_access (
#   results = veg_round,
#   database = path_to_analysis_set_db,
#   remove_tables = TRUE
#   )

# Functie "save_results_access" (< package) geeft problemen met dates => hierna manueel
vegetation_by_plot <- vegetation_by_plot %>% 
  mutate(date_vegetation = as.Date(gsub(' SAST','',date_vegetation))) 
  # gsub (SAST) is om tijdzone weg te halen, anders wordt een dag vroeger weergegeven


con <- odbcConnectAccess2007(path_to_analysis_set_db)

# vegetation_by_plot
dbtables <- sqlTables(con)
if ("vegetation_by_plot" %in% dbtables$TABLE_NAME) {
        sqlDrop(con, "vegetation_by_plot")
      }
sqlSave(con, dat = vegetation_by_plot, tablename = "vegetation_by_plot", varTypes = c(date_vegetation="datetime"))


# vegetation_by_core_area_species
dbtables <- sqlTables(con)
if ("vegetation_by_core_area_species" %in% dbtables$TABLE_NAME) {
        sqlDrop(con, "vegetation_by_core_area_species")
      }
sqlSave(con, dat = vegetation_by_core_area_species, tablename = "vegetation_by_core_area_species")

odbcClose(con)
```



Direct naar gdrive exporteren (csv): 
naar **/PRJ_BOSECO_ALGEMEEN/PRJ_BR_AanvraagGegevens/!METADATA-ALL_PLOTS/_plot-level-data/**

```{r save_veg_gdrive, eval = FALSE}
save_results_csv(
    results = veg_plotinfo,
    output_dir = path_to_plotlevel_gdrive
    )

```


# Herblayer - OK - 19/1/2023

## Export
Ook herblayer naar forresdat wegschrijven

```{r select_variables}
names(data_herblayer)

con <- odbcConnectAccess2007(path_to_fieldmap_db)
qBrowsIndex <- sqlFetch(con, "qBrowsIndex")
# qCoverHerbs <- sqlFetch(con, "qCoverHerbs")
odbcClose(con)

herblayer <- data_herblayer %>%
  select(plot_id, subplot_id, period, 
         date_vegetation, year, 
         species, coverage_class_average_perc, 
         browse_index_id) %>%
  left_join(qBrowsIndex %>% select(ID, Value2), by = c("browse_index_id" = "ID")) %>% 
  rename(browse_index = Value2) %>% 
  # mutate(date_vegetation = as.Date(date_vegetation)) 
  # !! r as.Date returns previous day 
  mutate(date_vegetation = as.Date(gsub(' SAST','',date_vegetation))) 
  # Which will remove the timezone from part of the string and then convert to date.

# save_results_xxxx: gemaakt om list weg te schrijven
# hier maar één dataframe
herblayer_list <- list(herblayer_by_plot = herblayer)
herblayer_list_git <- list(herblayer_by_plot = herblayer %>% select(-browse_index))
# summary(herblayer)

```


```{r join_plotinfo_herb}
herb_plotinfo <- lapply(herblayer_list, function(x) left_join(x, plotinfo %>% select(plot_id, forest_reserve, plottype, period, survey_number), by = c("plot_id", "period")))
# lapply: same function over all elements of the list

```



```{r save_herb_git, eval = FALSE}
# geen plotinfo naar git
save_results_git(
  results = herblayer_list_git,
  repo_path = path_to_git_forresdat,
  strict = TRUE
)

# check: echt niet veranderd??
# check <- read_vc(file = "herblayer_by_plot", root = path_to_forresdat_data)
# check %>% filter(plot_id == 41000 & period == 3 & browse_index_id == 100)
# herblayer %>% filter(plot_id == 41000 & period == 3 & browse_index_id == 100)
```

```{r save_herb_git_manueel, eval = FALSE}
# manueel - eigen simpele functie - als save_results_git niet werkt
save_results_tsv(herblayer_list_git, 
                 root = path_to_forresdat_data, 
                 strict = FALSE)
```


```{r save_herb_access_csv, eval = FALSE}
# volgende functie heb ik zelf geschreven, zit niet in het package!
save_results_csv (
    results = herb_plotinfo,
    output_dir = path_to_plotlevel_csv
    )

# afgerond voor export naar access
herb_round <- herb_plotinfo %>% 
  lapply(., function(x) round_df(x, 2))

# save to access nog steeds niet opgelost, is alsof access date niet herkent
# => manueel gedaan (csv opgeslagen als xlsx en dan geïmporteerd; csv gaf zelfd eproblemen als access)
        # save_results_access(
        #   results = herb_[1],
        #   database = path_to_analysis_set_db,
        #   remove_tables = TRUE
        # )

# probleem met datumvelden => varTypes aanduiden
con <- odbcConnectAccess2007(path_to_analysis_set_db)

dbtables <- sqlTables(con)
if ("herblayer_by_plot" %in% dbtables$TABLE_NAME) {
        sqlDrop(con, "herblayer_by_plot")
      }
# sqlSave(con, dat = herblayer, tablename = "herblayer_by_plot", fast = FALSE)
sqlSave(con, dat = herb_round[[1]], tablename = "herblayer_by_plot", varTypes = c(date_vegetation="datetime"))

odbcClose(con)

```

Direct naar gdrive exporteren (csv): 
naar **/PRJ_BOSECO_ALGEMEEN/PRJ_BR_AanvraagGegevens/!METADATA-ALL_PLOTS/_plot-level-data/**

```{r save_herb_gdrive, eval = FALSE}
save_results_csv(
    results = herb_plotinfo,
    output_dir = path_to_plotlevel_gdrive
    )

```


**Na update van forresdat, project "forresdat" openen en alles naar de cloud pushen**
**Eventueel ook access op gdrive plaatsen**


