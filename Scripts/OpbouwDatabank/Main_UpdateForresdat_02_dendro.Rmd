---
title: "Update forresdat - dendro op plotniveau"
author: "Anja Leyman"
date: "`r Sys.Date()`"
output: 
  html_document:
    keep_md: FALSE
    number_sections: yes
    fig_caption: yes
    code_folding: hide
    toc: TRUE
    toc_float:
      collapsed: yes
      smooth_scroll: yes
---


```{r Rm, eval = FALSE}
rm(list=ls())
```

```{r Setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  eval = FALSE,  # FALSE: dan kan ik knitten zonder dat er iets gebeurt
  message = FALSE,
  warning = FALSE, 
  fig.width = 9,
  fig.align = TRUE)

library(here)

# libraries & invoergegevens & functions
source(here::here("scripts/Setup.R"))

```


# Vraagstelling
DOEL van dit script is een update van forresdat gegevens naar 

- forresdat-folder als tsv (nadien nog te pushen naar github)
- BR_analysedb.accdb
- output-folders "_plot-level-data" en "_tree-level-data" als csv
- gdrive-folders "_plot-level-data" en "_tree-level-data" als csv

Kersselaerspleyn blijkt op meerdere vlakken uitzonderingen te bevatten.
Deze uitzonderingen worden na het inladen van de data gecorrigeerd. 


```{r results='hold', eval=TRUE}
path_to_forresdat_data
path_to_analysis_set_db
path_to_plotlevel_csv
path_to_treelevel_csv
path_to_output_gdrive
path_to_meetgegevens

```

# Load plotinfo

Verder werken met plotinfo uit Main_01, want correcties mbt date_dendro doorgevoerd.

Plotinfo inladen: plottype, naam forest_reserve en info over survey en data al dan niet processed.

```{r }
plotinfo <- read_vc(file = "plotinfo", root = path_to_forresdat_data)
names(plotinfo)
```

```{r check_processed}
# enkel checken bij deze waar er een dendro-opname gebeurd is
# anders ook deze van vorige decades mee, die niet kunne processed zijn
check_processed <- plotinfo %>% 
  filter(survey_trees == TRUE)

table(check_processed$forest_reserve, check_processed$data_processed)
# table(plotinfo$forest_reserve, plotinfo$data_processed)
```

```{r check_not_processed}
plotinfo_check <- plotinfo %>% 
  group_by(forest_reserve, plottype, period, survey_trees, data_processed) %>% 
  summarize(n_plots = n()) %>% 
  ungroup()

plotinfo_check %>% 
  filter(survey_trees == TRUE & data_processed == FALSE)

# omgekeerd geen plots die processed zijn, en géén survey_trees
plotinfo %>%  filter(data_processed & !survey_trees) %>% nrow() == 0
```

Enkel nog CP's derde set Withoefse heide (dd 13/7/2022), is gepland voor 2023.




# Load dendro data - voorlopig OK - 12/5/2023

Standaard wordt enkel processed data ingeladen mbv de load-functies

```{r load_dendro1_processed_or_not}
data_dendro <- load_data_dendrometry(database = path_to_fieldmap_db, 
                                     extra_variables = TRUE, 
                                     processed = TRUE)
# 79866 + 2455 = 82321 (rodebos)
# 83171 (22/11/2022)

# ook éénmalig eens non_processed op 11/3/2022 (ook zo weggeschreven): stems en trees
data_dendro_ <- load_data_dendrometry(database = path_to_fieldmap_db,
                                     extra_variables = TRUE,
                                     processed = FALSE)
#86399 - 2455 = 83944 (11/3/2022)
# 84873 (22/11/2022)

# welke data NIET processed? -----
t <- data_dendro_ %>% 
  anti_join(data_dendro)
table(t$forest_reserve)
# allemaal With heide

```


```{r load_dendro2}
data_shoots <- load_data_shoots(database = path_to_fieldmap_db, extra_variables = TRUE)

data_stems  <- compose_stem_data(data_dendro, data_shoots, extra_variables = TRUE)

height_model <- load_height_models(path_to_height_models)

data_deadwood <- load_data_deadwood(database = path_to_fieldmap_db, processed = TRUE)
```

```{r check_heightmodels}
table(height_model$forest_reserve, height_model$period)
table(plotinfo$forest_reserve)

height_model %>% group_by(forest_reserve) %>% summarise(n = n()) %>% ungroup() %>% anti_join(plotinfo, by = c("forest_reserve"))
# Rodebos	51	- OK, als algemeen voor beide KV's, niet gelinkt aan een feitelijke KV (= Rodebos KV1 en Rodebos KV2)
# Rodebos KV	56 - NIET OK!!! - AANGEPAST
# Walenbos	28	- OK, als algemeen voor beide KV's, niet gelinkt aan een feitelijke KV (= Walenbos KV1 en Walenbos OT)
```

# Correctie year van dendrometrie - NIET MEER NODIG
Gevraagd aan Els (issue #114)

Year = jaar van groeiseizoen
Grens was gelegd op 1/7, nu naar 1/5.
Aangevraagd in issue # 114, OK (27/3/2024)

*Berekening van year en year_dendro aangepast voor load_data_dendrometry() en load_plotinfo(): t.e.m. 30 april wordt nog bij het vorige jaar geteld, vanaf 1 mei wordt bij het nieuwe jaar geteld (1 mei bij huidig jaar).*


Hier geen sluitende code, gewoon deze waarvan ik weet dat het niet klopt, die aanpassen: 

- Bos Terrijst CA: OK
- Heirnisse: 5 plots 9/2014: OK
- enkel Kerss: alle 16 plots 2009 te wijzigen in 2010: CP's en CA

- !! ook Withoefse heide
(gecheckt in dbEls_deel2 op datum dendro in plotdetails en Kerss en With heide zijn enige reservaten in dit geval)


```{r check}
names(data_dendro)

year_range <- data_dendro %>% 
  group_by(forest_reserve, period) %>% 
  summarize(min_year = min(year), 
            max_year = max(year),
            year_range = paste0(min_year, " - ", max_year)) %>% 
  ungroup()

t <- year_range %>% 
  filter(min_year != max_year)

```

Tijdelijk tot update forrescalc

```{r correcte_year_data_dendro_TMP}
data_dendro_ <- data_dendro %>% 
  mutate(year = ifelse(year == 2009 & forest_reserve == "Kersselaerspleyn"
    , year + 1
    , year)
  ) %>% 
  mutate(year = ifelse(year == 1999 & forest_reserve == "Withoefse heide"
    , year + 1
    , year)
  )   

data_dendro <- data_dendro_

data_stems  <- compose_stem_data(data_dendro, data_shoots, extra_variables = TRUE)
```

```{r correcte_year_data_deadw_TMP}
data_deadwood_ <- data_deadwood %>% 
  mutate(year = ifelse(year == 2009 & forest_reserve == "Kersselaerspleyn"
    , year + 1
    , year)
  ) %>% 
  mutate(year = ifelse(year == 1999 & forest_reserve == "Withoefse heide"
    , year + 1
    , year)
  )  

data_deadwood <- data_deadwood_

```




# Liggend dood hout (intact/fragment) volume bijwerken - OK - 23/11/2022

De volumeberekening van liggend dood hout baseert zich op het veld `calc_volume_m3`
uit FM-databank (layer `Deadwood`).

Indien deadwood als fragment opgemeten werd (zie veld `IntactFragment` en 
bijhorende LU-list `qVdagnVfm`), is dit een kopie van het veld `Volume_m3.`
Dit veld wordt in FM-DC automatisch berekend. 
Belangrijk is om te zorgen dat dit volume als "inside plot" berekend wordt.

Indien deadwood als intact aangevinkt staat, moeten er tarieven gebruikt worden om
dit volume te berekenen.
Er werd afgesproken met Peter dit enkel nog te gebruiken voor de BE's of de KV's  
als ze plotgrens niet overschrijden. 

- Enkel in Kerss KV - 2eSET & 3eSET staan nog (veel) intacte bomen: 
klopt wel degelijk...voor KV KP = BEkartering....
- In 1eSET niks meer (aangevuld met fragmenten - copy van 2eSET - door Peter)
- Héél uitzonderlijk in 3e SET: 2 bomen in KV Rodebos (plot 43000)


## Fragmenten - update van volume in FM

**Elke keer te doen bij nieuwe db**

In Fieldmap zijn er twee velden opgenomen, die "manueel" bijgewerkt moeten worden.
Makkelijkste is om dit hier op te vangen in een updatequery.

Het gaat om de velden 
- `calc_volume_m3`
- `calc_length`

Deze velden zijn exacte copies van de velden 
- `volume_m3` (als IntactFragment = 20)
- `length_m`

Maar omdat deze laatste twee velden per ongeluk gewijzigd kunnen worden in FM-DC 
(te berekenen als "Total Volume" of "Volume inside plot"), is het veiliger om 
deze waardes vast te klikken in `calc_volume_m3` & `calc_length`.

Voor 3de set was `calc_volume_m3` niet steeds berekend (in acces).
Dat doen we hier mbv een updatequery, nadat we zeker zijn dat de waardes correct 
berekend zijn in FM-DC ("inside plot").
Dit moet normaliter enkel gebeuren voor periode 3, periode 1 en 2 zijn bijgewerkt 
in de moederdatabank zelf.

```{r sql_update_calc_deadw_inside_plot, eval = FALSE}
# !! ENKEL UITVOEREN NADAT IN DC "volume inside plot" BEREKEND IS
# data_deadwood_old <- data_deadwood

# layers_deadw <- c("Deadwood", "Deadwood_2eSET", "Deadwood_3eSET")
# 
# for (x in layers_deadw){
# 
# qry_update_calc_vol <- "UPDATE x 
#       LEFT JOIN qVdagnVfm ON x.IntactFragment = qVdagnVfm.ID 
#       SET x.CalcVolume_m3 = [Volume_m3] 
#       WHERE (((x.CalcVolume_m3) Is Null) AND ((x.IntactFragment)=20))"
# 
# qry_update_calc_length <- "UPDATE x 
#       LEFT JOIN qVdagnVfm ON x.IntactFragment = qVdagnVfm.ID 
#       SET x.CalcLength_m = [Length_m] 
#       WHERE ((x.CalcLength_m) Is Null)"
#   
# conn <- odbcConnectAccess2007(path_to_fieldmap_db)
# # conn <- odbcConnectAccess2007(path_to_fieldmap_db), rows_at_time = 1)
# 
# sqlQuery(conn,qry_update_calc_vol)
# sqlQuery(conn,qry_update_calc_length)
# 
# odbcClose(conn)
# }

# enkel deadw_3eSET
qry_update_calc_vol <- paste0("UPDATE Deadwood_3eSET SET Deadwood_3eSET.CalcVolume_m3 = Deadwood_3eSET.Volume_m3 WHERE ((Deadwood_3eSET.CalcVolume_m3 Is Null) AND (Deadwood_3eSET.IntactFragment=20))") %>%
           noquote()

qry_update_calc_length <- "UPDATE Deadwood_3eSET SET Deadwood_3eSET.CalcLength_m = Deadwood_3eSET.Length_m WHERE ((Deadwood_3eSET.CalcLength_m) Is Null)" %>%
           noquote()
  
conn <- odbcConnectAccess2007(path_to_fieldmap_db)

sqlQuery(conn,qry_update_calc_vol)
sqlQuery(conn,qry_update_calc_length)

odbcClose(conn)

# opnieuw inladen
data_deadwood_old <- data_deadwood
data_deadwood <- load_data_deadwood(database = path_to_fieldmap_db, processed = TRUE)


data_deadwood %>% filter(is.na(calc_volume_m3)) %>% nrow()
# 2 (intacte)
```

## Intacte bomen - correctie mbv R-code - NIET MEER NODIG

Indien deadwood als intact (veld `IntactFragment`) aangevinkt staat, moeten er 
**tarieven** gebruikt worden om dit volume te berekenen.

> Issue # 105 aangemaakt in forrescalc. Is geïmplementeerd.
Toch nog eens checken of intact-fragment wel klopt!!
(klopte alvast wel bij Wijnendale KV, één intacte kastanje - sp 64)

Er werd afgesproken met Peter `intact` enkel nog te gebruiken voor de BE's of de KV's  
(als bomen tenminste plotgrens van KV niet overschrijden). 

- hier in KV Wijnendale één intacte

In onderstaande code wordt het volume voor intacte bomen (ook indien NIET NA) 
bijgewerkt obv tarieven (stam + kroon), 
BEHALVE wanneer   
- er een substantieel deel buiten de plotgrenzen valt (> 1/2de)  
- decay 14 of 15 => allemaal fragment   
- decay 13: min_diameter > 150 (geen top aanwezig) => fragment (18 van de 42 intacte met decay 13)
 
(dit werd afgesproken met Peter via mail van 24/11/2022:  
  - sowieso alle met decay 14 of 15 = fragment   
  - decay 13: enkel deze met min_diameter > 150 als fragment)

**DUS OP TERMIJN MOET DIE EXTRA FILTER OP DECAYSTAGE EN MIN_DIAM NIET MEER GEBEUREN**

<!-- In 1eSET werd wel nog gebruik gemaakt van intacte bomen. -->
<!-- Peter heeft dit gecheckt: ca 140 bomen van de 4000 in dit geval. -->
<!-- Daarvan veel meer dan de helft sowieso te smal om zware zijtakken (> 10 cm) te hebben.  -->
<!-- Daarenboven ook kroon soms deels buiten CP of KV. -->
<!-- ==> Wellicht zou fout door te werken met enkel fragmenten verwaarloosbaar zijn. -->
<!-- (eventueel eens te checken: volgens Peter enkel KV Pruikenmakers mogelijks afwijking) -->


<!-- 28/11/2019: (c) Peter (zie Trello):   -->
<!-- Aangepast in MDB (update op citrix), alles voor CP's en KV's staat nu op 20 (calc FieldMap),  -->
<!-- dit volgens de besproken werkwijze;  -->
<!-- uiteindelijk werden hiervoor in 7 plots kroontakken uit de 2e set gekopieerd  -->
<!-- naar de 1e Set, afbraak werd op 1 of 2 gezet cfr stam,  -->
<!-- er werd in opmerkingsveld "manueel" genoteerd: -->
<!-- plot 922 : 1 essentak -->
<!-- plot 934 : 1 eikentak -->
<!-- plot 803 : 2 beukentakken -->
<!-- plot 819 : 1 lorkentak -->
<!-- plot 71000 : 4 beukentakken -->
<!-- plot 81000 : 3 eikentakken -->
<!-- plot 12100 : 29 eikentakken (kv pruikemakers)!! -->

<!-- Volumes dood hout kunnen specifiek voor deze plots vgl'en worden met oude berekende data als proef. -->

<!-- Mail Peter 23/11/2022 ivm Kerss KV: -->
<!-- "Nu helemaal gerecapituleerd hoe het zit met dode liggende (zware) bomen kernvlakte Kerselaerspleyn. -->
<!-- Deze werden hermeten in de plot 13100 Natman en mosbomen ifv opstart inventarisatie Glen toen. -->
<!-- Hiervoor werd boomlaag gekopieerd over geheel van Kersselaerspleyn en enkel hermeten/bijgemeten, verkort voor oudere objecten -->
<!-- in de kernvlakte en rond de kernvlakte =bufferzone. Nadien heb ik dan in de plot 11000, de hermeten objecten die voldoen aan de diameter -->
<!-- en volledig of deels binnen de plotsgrens van de kernvlakte liggen ingeladen, vandaar uitzonderlijk hier wel combi intact en afgesneden, -->
<!-- In die natmanbomenplot (13100à zitten/zaten bijvoorbeeld ook bomen met kleine diameters die destijds door onze Ruben werden bemonsterd en een natmanid kregen -->
<!-- en die nu voor Glen zijn werk opnieuw werden bekeken, als ze er nog lagen." -->

```{r posssible_fragment_check, eval = FALSE}
# !! gemerkt dat calc_vol in Kerss KV (plot 11000, 2de en 3de decade) exacte copie 
# is van volume inside plot, terwijl het om intacte bomen gaat
# => volume bijwerken

data_deadwood_intact <- data_deadwood %>% 
  filter(intact_fragm == 10)

# toch nog niet helemaal zoals afgesproken met Peter => file doormailen met mogelijke fragmenten
posssible_fragment <- data_deadwood_intact %>% 
  filter((calc_length_m < total_length_m/2)|
           decaystage == 14|
           (decaystage == 13 & min_diam_mm > 150) |
           min_diam_mm > 150) %>% 
  select(plot_id, plottype, forest_reserve, , period, date_dendro, lying_deadw_id,
         species, decaystage, intact_fragm, calc_volume_m3, calc_length_m, total_length_m,
         min_diam_mm, max_diam_mm)

table(posssible_fragment$decaystage)

write_csv2(posssible_fragment, here::here("output/posssible_fragment_Kerss_KV.csv"))

```


```{r select_intact_deadw}
## TIJDELIK toch nog doen , lijkt nog niet aangepoast in db
data_deadwood_intact_TOCH_NIET <- data_deadwood %>% 
  filter(intact_fragm == 10 & calc_length_m < total_length_m/2) %>%   # korte boompjes/sterk afgesneden
  # enkel de weinig vergane met lage_min_diam (dus met een topje), rest zijn toch fragmenten
  # afgesproken via mail 24/11/2022 van Peter dat hij dit ook zo gaat aanpassen in moederdb
  filter(decaystage < 13 | (decaystage == 13 & min_diam_mm < 150))


data_deadwood_intact <- data_deadwood %>% 
  filter(intact_fragm == 10 & calc_length_m > total_length_m/2) %>%
  # enkel de weinig vergane met lage_min_diam (dus met een topje), rest zijn toch fragmenten
  # afgesproken via mail 24/11/2022 van Peter dat hij dit ook zo gaat aanpassen in moederdb
  filter(decaystage < 13 | (decaystage == 13 & min_diam_mm < 150))
table(data_deadwood_intact$decaystage)
table(data_deadwood_intact$forest_reserve)
# Kersselaerspleyn      Rodebos KV2 
#               49                2 

data_deadwood_intact_db <- data_deadwood %>% 
  filter(intact_fragm == 10)
table(data_deadwood_intact_db$decaystage)
table(data_deadwood_intact_db$forest_reserve)
# Kersselaerspleyn      Rodebos KV2 
#               91                2 

# check: welke beschouw ik als fragment, terwijl ze in db als intact staan?
check <- data_deadwood %>%
  filter(intact_fragm == 10) %>%
  anti_join(data_deadwood_intact)
table(check$decaystage)
# check2 <- data_deadwood_intact_ %>% 
#   filter(intact_fragm == 10 & calc_length_m < total_length_m)

nrow(data_deadwood_intact)
# [1] 51
```

```{r}
data_deadwood_fragm <- data_deadwood %>% 
  anti_join(data_deadwood_intact)

nrow(data_deadwood) == nrow(data_deadwood_intact) + nrow(data_deadwood_fragm)
```


```{r calc_deadw_intact}
# tarieven
data_deadwood_intact_ <- my.CalcVolBA(data_deadwood_intact, tarieven2ing, nIngang = 2, 
             varNameDiameter = "max_diam_mm",
             varNameHeight = "calc_length_m")
data_deadwood_intact_ <- my.CalcVolBranches(data_deadwood_intact_, tarieven1ingKroon, 
             varNameDiameter = "max_diam_mm")

# data_deadwood_intact_ <- data_deadwood_intact_ %>% 
#   mutate(diff_vol = (vol_stem_m3 + vol_crown_m3) - calc_volume_m3,
#          diff_vol_proc = 100*diff_vol/calc_volume_m3)
# !! eigenlijk mag dat niet vergeleken worden, want één intacte boom bestaat uit 
# meerdere fragmenten

data_deadwood_intact_ <- data_deadwood_intact_ %>% 
  mutate(calc_volume_m3 = ifelse(
    intact_fragm == 10,
    vol_stem_m3 + vol_crown_m3,
    calc_volume_m3))

names(data_deadwood_intact_)
names(data_deadwood_fragm)
data_deadwood_intact <- data_deadwood_intact_ %>% 
  select(-basal_area_m2, - vol_stem_m3, -vol_crown_m3)

data_deadwood <- rbind(data_deadwood_intact, data_deadwood_fragm)
```

```{r check_vol_deadw}
check_deadw <- data_deadwood %>% 
  filter(is.na(calc_volume_m3))
nrow(check_deadw) == 0
# waren er 2, nu 0 (intact, plot 43.000, geprogrammeerd mbv tarieven dagnelie)

# summary(check_deadw$period) # enkel periode 3
# unique(check_deadw$plot_id) # enkel plot 43000 
# plotinfo %>% filter(plot_id %in% check_deadw$plot_id) # Rodebos KV

```



# Correctie Kersselaerspleyn staande bomen

## Afwijkingen 

- KV 1986: 
** geen shoots, geen deadwood, reg of veg
** pas vanaf dbh > 30 cm  
** enkel de bomen die in 2000 nog recht stonden, werden geïmporteerd in FieldMap
=> enkel te gebruiken voor volume-aanwas

- KV 2000: 
** pas vanaf dbh 30 cm volopname  
** boompjes met dbh 10-30 cm werden geteld


**Methodiekrapport**:

*Dendrometrics*: 
Full survey of all trees (L+D) with DBH>30cm in 1986-87; revisited in 1991 to
record windthrown trees due to windstorms of february 1991 (Vivian & Wiebke). Volume
calculations with tariffs (Van den Berge et al. 1990; 1992).

In 2000/01 : re-survey of full area, with DBH threshold of 30 cm, trees of 10-30 cm counted,
not positioned; smaller trees not surveyed in full area but in subsamples (see regeneration).

2010 and 2020 : full survey of all trees (L+D) with DBH>5cm.

## Staande bomen 1ste decade KV Kersselaerspleyn pas vanaf 30 cm

*Eigen verwerking*: 

Concreet Kersselaerspleyn_IA_KV1986etc_INBO33: bevat alle jaartallen:
	- 1986 (!! Enkel deze die in 2000 nog recht stonden => enkel te gebruiken voor volume-aanwas)
	- 2000 (!! Pas gebiedsdekkend opgemeten vanaf 30 cm DBH => extra filter toevoegen bij de verwerking)
	- 2010

In 2000 werd gebiedsdekkend gemeten vanaf 30 cm DBH, en twee groepen vanaf 5 cm.
Daarnaast streeplijsten: samen met veg in 750 subsamples: 30-20, 20-10 en < 10 cm.
Afzonderlijk verwerkt: zie `CA_Kerss_5_30_dendro_by_xxx`

**DAAROM in trees en stems deze < 30 cm wegfilteren (want dat zijn er in 2 kleine verjongingsgroepjes en niet representatief) zdd we resultaten hebben van levend > 30 cm**
**(cfr dataverwerking in 2012) **

> We gaan ervanuit dat degene die data gebruiken, het methodiekrapport gelezen hebben en dit dus weten.
Staat ook in metadata

```{r}
data_stems_<- data_stems %>% 
  filter(plot_id != 11000 | 
           period %in% c(2,3) |
           dbh_mm >= 300)

check <- data_stems %>% 
  anti_join(data_stems_)
table(check$period, check$plot_id)   # ok
  #     11000
  # 1   913
data_stems <- data_stems_

data_dendro_ <- data_dendro %>% 
  filter(plot_id != 11000 | 
           period %in% c(2,3) |
           dbh_mm >= 300)
check <- data_dendro %>% 
  anti_join(data_dendro_)
table(check$period, check$plot_id)   # ok
  #     11000
  # 1   913
data_dendro <- data_dendro_

```


```{r}
check_Kerss <- data_stems %>% 
  filter(plot_id == 11000 & period == 1)
min(check_Kerss$dbh_mm) # 300
```

## KV Kerss 1986 - opgepast

In 1986: in FM werden enkel deze die in 2000 nog recht stonden, ingeladen.  
Dus enkel geschikt voor aanwas-berekeningen, niet om staande voorraad te berekenen.

Kan niet (moeilijk) rechtgezet worden.

> We gaan ervanuit dat degene die data gebruiken, het methodiekrapport gelezen hebben en dit dus weten.
Staat ook in metadata


# Calculate dendro data

```{r save_previous, eval = FALSE}
# laatste update: 15/5/2023 (with heide 2000 ipv 1999)
save(data_stems, data_dendro, data_shoots, height_model, data_deadwood,
     file=here::here("RData/main02_dendro_basics.RData"))

# load(here::here("RData/main02_dendro_basics.RData"))
```


```{r calc_stems_tree}
data_stems_calc <- calc_variables_stem_level(data_stems, height_model)

data_dendro_calc <- calc_variables_tree_level(data_dendro, data_stems_calc)

dendro <- calculate_dendrometry(data_dendro, data_deadwood, data_shoots, height_model)
```


```{r CreateSeparateDataframesDendro}
for (tablename in names(dendro)) {
     assign(tablename, dendro[[tablename]])
} 

```


# Check NA's

Niet alle NA's moeten door een 0 vervangen worden.
Een NA wijst vaak op een missing value in FM => dat eerst oplossen

> OPGEPAST
> Als in trees layer het veld `ind_sht_cop` = coppice (12)
én de  shoot zit toch niet in de shoots layer
dan wordt een fout gecreëerd in forrescalc (met NA voor volume als gevolg)
DUS BEST MEENEMEN IN DATACONTROLE

> OOK AANDACHT VOOR MISSING DBH OF HEIGHT VAN SNAGS !!!


## Tree-level

```{r check_NA1, eval = FALSE}
col <- c("dbh_mm", "species", "dbh_class_5cm", "calc_height_m", "vol_crown_m3",
         "vol_bole_m3", "vol_tot_m3", "stem_number_alive_ha", "stem_number_dead_ha",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha",
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha",
         "intact_snag", "alive_dead", "ind_sht_cop")
nrow(data_stems_calc  %>%
       filter_at(col, any_vars(is.na(.)))) == 0

col <- c("dbh_mm", "species", "dbh_class_5cm", "calc_height_m",
         "basal_area_m2", "vol_bole_m3", "vol_crown_m3", "vol_tot_m3",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha",
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha",
         "number_of_trees_alive_ha", "number_of_trees_dead_ha")

nrow(data_dendro_calc  %>%
       filter_at(col, any_vars(is.na(.)))) == 0

# names(data_stems_calc)
# names(data_dendro_calc)
# data_stems_NA <- data_stems_calc %>% 
#   filter_at(col, any_vars(is.na(.))) %>%
#   select(plot_id, period,
#          dbh_mm, species, alive_dead, 
#          height_m, calc_height_m, vol_bole_m3, vol_bole_alive_m3_ha,
#          decaystage, intact_snag,
#          ind_sht_cop,
#          contains(c("iufro", "remark"))
#          ) %>% 
#   left_join(plotinfo, by = c("plot_id", "period")) 
```


## Dendro_by_plot 

```{r check_NA2}
col <- c("year", "number_of_tree_species", "number_of_trees_ha", "stem_number_ha",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha", 
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha",
         "vol_log_m3_ha", "vol_deadw_m3_ha", "stems_per_tree")

dendro_by_plot %>% filter_at(col, any_vars(is.na(.)))
# 1 plot: 475


```

Plot 475, periode 1, bevat geen staande bomen, wel liggende.
> Voorlopig '0' van maken, maar moet in package opgelost worden (opgenomen als issue nov 2022)
!! met uitz. van stems_per_tree!!!

stems_per_tree moet NA blijven

```{r change_NA2}
dendro_by_plot_ <- dendro_by_plot %>% 
  replace((is.na(.)), 0) %>% 
  mutate(vol_deadw_m3_ha = vol_dead_standing_m3_ha + vol_log_m3_ha)

dendro_by_plot_ %>% filter_at(col, any_vars(is.na(.)))
# OK, geen NA's meer

dendro_by_plot <- dendro_by_plot_


# stems_per_tree toch NA!!
dendro_by_plot_ <- dendro_by_plot %>% 
  mutate(stems_per_tree = ifelse(stems_per_tree == 0, NA, stems_per_tree))

dendro_by_plot <- dendro_by_plot_
```


## Dendro_by_plot_species 

Foutje in package: op dit moment NA's als soort niet voorkomt staand, maar wel liggend.
Dat moet 0 worden.

Gevraagd aan Els: Issue #117: 0 vs NA bij dendro_by_plot(_species_diam) 

> In forrescalc aangeduid als te verbeteren.
> Hierna voorlopig corrigeren

stems_per_tree moet NA blijven


```{r}
col <- c("year", "species", "number_of_trees_ha", "stem_number_ha",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha", 
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha",
         "vol_log_m3_ha", "vol_deadw_m3_ha")

dendro_by_plot_species %>% filter_at(col, any_vars(is.na(.))) %>% nrow()
# 765

check <- dendro_by_plot_species %>% filter_at(col, any_vars(is.na(.)))

# deze moeten allemaal 0 worden - !! met uitz van stems_per_tree
dendro_by_plot_species_ <- dendro_by_plot_species %>% 
  replace((is.na(.)), 0) %>% 
  mutate(vol_deadw_m3_ha = vol_dead_standing_m3_ha + vol_log_m3_ha)

dendro_by_plot_species_ %>% filter_at(col, any_vars(is.na(.))) %>% nrow()
# OK, geen NA's meer

dendro_by_plot_species <- dendro_by_plot_species_


# stems_per_tree MOET toch NA blijven!!
dendro_by_plot_species_ <- dendro_by_plot_species %>% 
  mutate(stems_per_tree = ifelse(stems_per_tree == 0, NA, stems_per_tree))

dendro_by_plot_species <- dendro_by_plot_species_

```



# Stems per tree - NA ipv 0  

Momenteel is "stems_per_tree" = 0, wanneer er geen bomen opgemeten werden.
Dat is fout, dat moet NA zijn.
Mag niet verder meegenomen worden in de berekeningen van de statistieken op reservaatsniveau.

Komt voor in `dendro_by_plot` en `dendro_by_plot_species`, als proxy voor de meerstammigheid.

Forrescalc code is OK voor stems_per_tree, maar was/is niet OK voor N, G, V van soorten zonder staande levends bomen.
Die NA's worden hogerop gewijzigd naar 0 (onder ## Dendro_by_plot en ## Dendro_by_plot_species).
Initieel gebeurde dat ook voor stems_per_tree, maar is nu aangepast (zie check hierna)

```{r}
dendro_by_plot %>% filter(is.na(stems_per_tree))
# enkel plot 475 waar geen opname gebeurd is (alles NA)

dendro_by_plot %>% filter( stems_per_tree == 0)
# komt niet voor
# verderop kunstmatig 0 van gemaakt, en terug gecorrigeerd naar NA

```
`dendro_by_plot_species`

```{r}
dendro_by_plot_species %>% filter(is.na(stems_per_tree)) %>% nrow()
# 1235 records
dendro_by_plot_species %>% filter(stem_number_ha == 0) %>% nrow()
# ook 1235 => OK

dendro_by_plot_species %>% filter( stems_per_tree == 0)
# komt niet voor
# verderop kunstmatig 0 van gemaakt, en terug gecorrigeerd naar NA

```


## Dendro_by_diam_plot

Foutje in package dat nu gecorrigeerd is (25/11/2022).

```{r}
col <- c("year", "stem_number_alive_ha", "stem_number_dead_ha",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha", 
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha",
         "vol_log_m3_ha")

dendro_by_diam_plot %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0
# 0

# check <- dendro_by_diam_plot %>% filter_at(col, any_vars(is.na(.)))
# 
# dendro_by_diam_plot_ <- dendro_by_diam_plot %>% 
#   replace((is.na(.)), 0)
# 
# dendro_by_diam_plot_ %>% filter_at(col, any_vars(is.na(.))) %>% nrow()
# # OK, geen NA's meer
# 
# dendro_by_diam_plot <- dendro_by_diam_plot_
```


## Dendro_by_diam_plot_species

Idem als voorgaande.

```{r}
col <- c("year", "species", "stem_number_alive_ha", "stem_number_dead_ha",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha", 
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha",
         "vol_log_m3_ha")

dendro_by_diam_plot_species %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0

# check <- dendro_by_diam_plot_species %>% filter_at(col, any_vars(is.na(.)))
# 
# # enkel vol_dead_standing is NA, rest is 0 zoals het zou moeten zijn
# # dit veld moet ook 0 worden
# dendro_by_diam_plot_species_ <- dendro_by_diam_plot_species %>% 
#   replace((is.na(.)), 0)
# 
# dendro_by_diam_plot_species_ %>% filter_at(col, any_vars(is.na(.))) %>% nrow()
# # OK, geen NA's meer
# 
# dendro_by_diam_plot_species <- dendro_by_diam_plot_species_
```



## Logs_by_decay_plot_species

> moet aangepast worden: op termijn zal dit uitgebreid worden met ook het staand dood hout

```{r}
names(logs_by_decay_plot)

col <- c("year", "decaystage", "vol_log_m3_ha")

logs_by_decay_plot %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0

check <- logs_by_decay_plot %>% filter_at(col, any_vars(is.na(.)))

# deels decaystage missing => ook OK
# na aanpassing verderop: deels KV Kerss (met wel info over min40cm) => OK 
# moet niet aangepast worden
```

## Logs_by_decay_plot_species

Idem als hiervoor.

```{r}
col <- c("year", "decaystage", "species", "vol_log_m3_ha")

logs_by_decay_plot_species %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0

check <- logs_by_decay_plot_species %>% filter_at(col, any_vars(is.na(.)))
# OK, kan vergeten zijn
```



# Add zero's

Sommige plots bevatten geen bomen én geen dood hout (Bv. Ename), en zijn dus 
niet opgenomen in `dendro_by_plot`.
Hoewel het niet zinvol is om in elke dataset nullen toe te voegen (bv. per_species), 
is het wel nuttig bij `dendro_per_plot`.

Functie `add_zero_no_na`  blijkt niet geschikt voor dit. 
<!-- Nadeel is dat er ook gegevens van liggend dood hout opgenomen zijn, en blijkbaar kan er maar één variabele als `add_zero_no_na` opgenomen worden.  -->
<!-- Idealiter zou dataset in twee moeten opgesplits worden: liggend en staand,  -->
<!-- en vervolgens elk onafhankelijk van elkaar mbv add_zeros aangevuld. -->

<!-- Maakt alles vrij complex, voor iets heel simpels. -->
<!-- We weten al dat de nulwaarden voor plots met bomen, maar zonder liggend dood hout, -->
<!-- toegevoegd zijn. -->
<!-- Het gaat dus enkel nog om plots zonder staande bomen. -->

Daarom heel simpel: obv `plotinfo` - `survey_trees` en `survey_deadw` - nulwaarden toevoegen.


```{r check_add_zeros_werkt_niet, eval = FALSE}
# dendro_by_plot_ <- add_zeros(dataset = dendro_by_plot %>% select(-contains(c("reg", "veg")), -survey_deadw, - data_processed)
#                              , comb_vars = c("plot_id", "period")
#                              , grouping_vars = c("plottype", "forest_reserve")
#                              , add_zero_no_na = c("survey_trees")
#                              )
#   
# nrow(dendro_by_plot)  - nrow(dendro_by_plot_)
# # !! daar zitten ook plots bij die niet opgenomen zijn in één van beide cycli ...
# 
# dendro_by_plot_ %>% anti_join(dendro_by_plot, 
#                               by = c("plot_id", "period", "plottype", "forest_reserve"))
```

Nov 2022: het gaat enkel over 13 plots in Enamebos, die volgens mij permanente 
open ruimte zijn.
Er is een veld in `plotdetails` (`forested`) dat zou kunnen ingeschakeld worden 
om deze plots al dan niet uit de analyseset te filteren.
Momenteel nog niet ingevuld.

```{r check_dendro_plots_zonder_bomen}
# welke plots niet opgenomen in dendro_by_plot?
  
check <- plotinfo %>% 
  filter((survey_trees | survey_deadw) & data_processed) %>% 
  anti_join(dendro_by_plot)

table(check$forest_reserve, check$period)
  #                  2  3
  # Ename           13  0

# Open plekken in Ename bos: best toevoegen, want er zijn ook plots met bv maar één boom
# eerder bij dataverwerking dan uitfilteren

zero_biomass_plots <- dendro_by_plot %>% 
  full_join(plotinfo %>% 
              filter((survey_trees | survey_deadw) & data_processed) %>% 
              select(plot_id, period, year = year_dendro)
  ) %>% 
  filter(is.na(vol_alive_m3_ha) & is.na(vol_log_m3_ha)) %>% 
  replace((is.na(.)), 0) %>% 
  mutate(stems_per_tree = ifelse(stems_per_tree == 0, NA, stems_per_tree))

table(zero_biomass_plots$plot_id)

```

```{r rbind_zero_biomass}
# Ename
dendro_by_plot_ <- rbind(dendro_by_plot, zero_biomass_plots)
summary(dendro_by_plot_)

dendro_by_plot <- dendro_by_plot_

```



# Liggend dood hout

## TIJDELIJK: correctie logs: 0 --> NA - voorlopig OK 20/9/2022

Enkel een probleem in `Dendro_by_plot`
> Dendro_by_plot: functie forrescalc zet deadwood = 0, wanneer er een levend volume gemeten is 
!! FOUT: zou obv survey_deadw_YN moeten gebeuren!!
**Gevraagd in branch AL_deadw (als commit) op 20/9/2022**

Logs_by_decay_plot: OK, want nemen geen NA-waardes mee

Nu voorlopig opvangen door extra code (als géén deadw survey, dan NA): chunck `correctie_deadwood_NA`

> eens package aangepast is, zou dit niet meer nodig mogen zijn

```{r check_dead2}
no_deadw <- plotinfo %>% 
  filter(survey_trees == TRUE & survey_deadw == FALSE)
nrow(no_deadw)
table(no_deadw$forest_reserve, no_deadw$period)
# TOCH BEST REKENING MEE HOUDEN!!

```

bv. plot 11000: period 1 en 0 niet opgemeten => moet NA worden ipv 0
Gecheckt, en ook als enkel deadwood ingeladen wordt van plots waar deadwood opgemeten is 
(`deadwoood_survey_YN == TRUE`), dan nog wordt dit op '0' gezet ipv op NA

```{r eval=FALSE}
data_deadwood %>% filter(plot_id == 11000 & period == 1) %>% nrow() == 0
# enkel data van opgemeten plots ingeladen 
# (data_processed = TRUE or FALSE is zelfde resultaat: geen records als er niks opgemeten is)

check11000 <- dendro_by_plot %>% filter(plot_id == 11000 & period == 1)

dendro_by_plot %>% filter(plot_id == 11000 & period == 1) %>% dplyr::pull(vol_log_m3_ha)

logs_by_decay_plot %>% filter(plot_id == 11000 & period == 1) %>% dplyr::pull(vol_log_m3_ha)

# 
table(no_deadw$forest_reserve, no_deadw$period)
# 45 plots zonder deadwood-opname, maar wel volume_alive 
#=> TOCH BEST REKENING MEE HOUDEN!!
```

```{r correctie_deadwood_NA}
dendro_by_plot_ <- dendro_by_plot %>% 
  left_join(plotinfo %>% select(plot_id, period, survey_deadw), by = c("plot_id", "period")) %>% 
  mutate(vol_log_m3_ha = ifelse(survey_deadw, vol_log_m3_ha, NA),
         vol_deadw_m3_ha = ifelse(survey_deadw, vol_deadw_m3_ha, NA))

dendro_by_plot_ %>% filter(plot_id == 11000 & period == 1) %>% dplyr::pull(vol_log_m3_ha)
dendro_by_plot_ %>% filter(plot_id == 11000 & period == 3) %>% dplyr::pull(vol_log_m3_ha)
dendro_by_plot_ %>% filter(plot_id == 1620 & period == 2) %>% dplyr::pull(vol_log_m3_ha)

dendro_by_plot <- dendro_by_plot_ %>% 
  select(-survey_deadw)

#
dendro_by_plot_species_ <- dendro_by_plot_species %>% 
  left_join(plotinfo %>% select(plot_id, period, survey_deadw), by = c("plot_id", "period")) %>% 
  mutate(vol_log_m3_ha = ifelse(survey_deadw, vol_log_m3_ha, NA),
         vol_deadw_m3_ha = ifelse(survey_deadw, vol_deadw_m3_ha, NA))

dendro_by_plot_species_ %>% filter(plot_id == 11000 & period == 1) %>% dplyr::pull(vol_log_m3_ha)
dendro_by_plot_species_ %>% filter(plot_id == 11000 & period == 3) %>% dplyr::pull(vol_log_m3_ha)
dendro_by_plot_species_ %>% filter(plot_id == 1620 & period == 2) %>% dplyr::pull(vol_log_m3_ha)

dendro_by_plot_species <- dendro_by_plot_species_ %>% 
  select(-survey_deadw)

#
dendro_by_diam_plot_ <- dendro_by_diam_plot %>% 
  left_join(plotinfo %>% select(plot_id, period, survey_deadw), by = c("plot_id", "period")) %>% 
  mutate(vol_log_m3_ha = ifelse(survey_deadw, vol_log_m3_ha, NA))

dendro_by_diam_plot_ %>% filter(plot_id == 11000 & period == 1) %>% dplyr::pull(vol_log_m3_ha)
dendro_by_diam_plot_ %>% filter(plot_id == 11000 & period == 3) %>% dplyr::pull(vol_log_m3_ha)
dendro_by_diam_plot_ %>% filter(plot_id == 1620 & period == 2) %>% dplyr::pull(vol_log_m3_ha)

dendro_by_diam_plot <- dendro_by_diam_plot_ %>% 
  select(-survey_deadw)

#
dendro_by_diam_plot_species_ <- dendro_by_diam_plot_species %>% 
  left_join(plotinfo %>% select(plot_id, period, survey_deadw), by = c("plot_id", "period")) %>% 
  mutate(vol_log_m3_ha = ifelse(survey_deadw, vol_log_m3_ha, NA))
# !!? toch zeker dat vol_deadw_m3_ha niet meer bestaat in by_diam?
         

dendro_by_diam_plot_species_ %>% filter(plot_id == 11000 & period == 1) %>% dplyr::pull(vol_log_m3_ha)
dendro_by_diam_plot_species_ %>% filter(plot_id == 11000 & period == 3) %>% dplyr::pull(vol_log_m3_ha)
dendro_by_diam_plot_species_ %>% filter(plot_id == 1620 & period == 2) %>% dplyr::pull(vol_log_m3_ha)
# !!? toch zeker dat vol_deadw_m3_ha niet meer bestaat in by_diam?


dendro_by_diam_plot_species <- dendro_by_diam_plot_species_ %>% 
  select(-survey_deadw)

#
summary(dendro_by_plot_species)
```


# Correctie Kersselaerspleyn liggend dood hout

Correctie op plot-niveau

## Afwijkingen

- KV 1986 en 2000: 
** geen deadwood opgemeten

- CP 2000:
** cijfers overgenomen uit monitoringrapport, zitten niet in fieldmap

- KV 2010 en 2020: 
** deadwood pas vanaf 40 cm 
** 51 intacte liggende dode bomen



## Logs CP's - periode 1 (2000)

Zitten niet in fieldmap, maar er zijn wel gegevens uit het monitoringrapport, zie 
"CP_Kerss_logs_2000.xlsx" (C:/03_BR/1_DataVerwerkingBR/Data/Meetgegevens/logs_CPs_Kerss_2000)

Deze hier implementeren.

```{r load_deadw_Kerss_CP_1}
logs_Kerss_2000 <- read.xlsx(paste0(path_to_meetgegevens, "logs_CPs_Kerss_2000/CP_Kerss_logs_2000.xlsx")
                             ,sheetName = "logs_per_plot") %>% 
  select(plot_id, period, VOLUME_LOG_m3_ha)
names(logs_Kerss_2000)

logs_per_spec_Kerss_2000 <- read.xlsx(paste0(path_to_meetgegevens, "logs_CPs_Kerss_2000/CP_Kerss_logs_2000.xlsx")
                             ,sheetName = "logs_per_plot_species") %>% 
  select(plot_id, species, period, VOLUME_LOG_m3_ha)

```

```{r update_dendro_by_plot}
names(logs_Kerss_2000)
names(dendro_by_plot)
# bevat NA's voor liggend dood hout (Kerss 1eSET)

dendro_by_plot_ %>% left_join(plotinfo %>% select(plot_id, forest_reserve, plottype, period)) %>% filter(forest_reserve == "Kersselaerspleyn" & plottype == "CP" & period == 1) %>% nrow() == 53
# vol_log = 0, want hogerop reeds survey_deadw = TRUE gesteld

# info toevoegen Kerss CPS 2000
dendro_by_plot_ <- dendro_by_plot %>% 
  left_join(logs_Kerss_2000) %>% 
  mutate(vol_log_m3_ha = ifelse(between(plot_id, 2000, 2070) & period == 1 
                                #forest_reserve == "Kersselaerspleyn" & plottype == "CP" 
                                , VOLUME_LOG_m3_ha
                                , vol_log_m3_ha)
         , vol_deadw_m3_ha = vol_log_m3_ha + vol_dead_standing_m3_ha) %>% 
  select(-VOLUME_LOG_m3_ha)

dendro_by_plot_ %>% filter(period == 1 & between(plot_id, 2000, 2070))
# OK

dendro_by_plot <- dendro_by_plot_
```


```{r update_dendro_by_plot_species}
names(logs_per_spec_Kerss_2000)
names(dendro_by_plot_species)
# bevat NA's voor liggend dood hout (Kerss 1eSET)

dendro_by_plot_species %>% left_join(plotinfo %>% select(plot_id, forest_reserve, plottype, period)) %>% filter(forest_reserve == "Kersselaerspleyn" & plottype == "CP" & period == 1) %>% head()
# vol_log = 0, want hogerop reeds survey_deadw = TRUE gesteld

# info toevoegen Kerss CPS 2000
dendro_by_plot_species_ <- dendro_by_plot_species %>% 
  left_join(logs_per_spec_Kerss_2000) %>% 
  # mutate(VOLUME_LOG_m3_ha = ifelse(is.na(VOLUME_LOG_m3_ha) & between(plot_id, 2000, 2070) & period == 1
  #                                  0, 
  #                                  VOLUME_LOG_m3_ha)) %>% 
  mutate(vol_log_m3_ha = ifelse(between(plot_id, 2000, 2070) & period == 1 
                                #forest_reserve == "Kersselaerspleyn" & plottype == "CP" 
                                , ifelse(is.na(VOLUME_LOG_m3_ha), 0, VOLUME_LOG_m3_ha)
                                , vol_log_m3_ha)
         , vol_deadw_m3_ha = vol_log_m3_ha + vol_dead_standing_m3_ha) %>% 
  select(-VOLUME_LOG_m3_ha)

dendro_by_plot_species_ %>% filter(period == 1 & between(plot_id, 2000, 2070))
# OK

dendro_by_plot_species <- dendro_by_plot_species_
```

Niet geweten hoeveel er in welke diameterklasse zit => daar alles op NA zetten

```{r update_dendro_by_diam_plot_species}
names(logs_per_spec_Kerss_2000)
names(dendro_by_diam_plot_species)
# bevat nullen voor liggend dood hout (Kerss 1eSET) want hogerop reeds survey_deadw = TRUE gesteld

dendro_by_diam_plot_species %>% left_join(plotinfo %>% select(plot_id, forest_reserve, plottype, period)) %>% filter(forest_reserve == "Kersselaerspleyn" & plottype == "CP" & period == 1) %>% head()
# vol_log = 0, want hogerop reeds survey_deadw = TRUE gesteld

# NA van maken
dendro_by_diam_plot_species_ <- dendro_by_diam_plot_species %>% 
  mutate(vol_log_m3_ha = ifelse(between(plot_id, 2000, 2070) & period == 1 
                                #forest_reserve == "Kersselaerspleyn" & plottype == "CP" 
                                , NA
                                , vol_log_m3_ha)
         , vol_deadw_m3_ha = vol_log_m3_ha + vol_dead_standing_m3_ha)

dendro_by_diam_plot_species_ %>% filter(period == 1 & between(plot_id, 2000, 2070)) %>% head()
# OK

dendro_by_diam_plot_species <- dendro_by_diam_plot_species_
```

```{r update_dendro_by_diam_plot}
names(dendro_by_diam_plot)
# bevat nullen voor liggend dood hout (Kerss 1eSET) want hogerop reeds survey_deadw = TRUE gesteld

dendro_by_diam_plot %>% left_join(plotinfo %>% select(plot_id, forest_reserve, plottype, period)) %>% filter(forest_reserve == "Kersselaerspleyn" & plottype == "CP" & period == 1) %>% head()
# vol_log = 0, want hogerop reeds survey_deadw = TRUE gesteld

# NA van maken
dendro_by_diam_plot_ <- dendro_by_diam_plot %>% 
  mutate(vol_log_m3_ha = ifelse(between(plot_id, 2000, 2070) & period == 1 
                                #forest_reserve == "Kersselaerspleyn" & plottype == "CP" 
                                , NA
                                , vol_log_m3_ha)
         , vol_deadw_m3_ha = vol_log_m3_ha + vol_dead_standing_m3_ha)

dendro_by_diam_plot_ %>% filter(period == 1 & between(plot_id, 2000, 2070)) %>% head()
# OK

dendro_by_diam_plot <- dendro_by_diam_plot_
```


```{r update_logs_by_decay_NIET_NODIG, eval = FALSE}
# ook voor de andere plot-level-resultaten
      # logs_by_decay_plot = logs_by_decay_plot,
      # logs_by_decay_plot_species = logs_by_decay_plot_species
names(logs_by_decay_plot)

logs_by_decay_plot %>% left_join(plotinfo %>% select(plot_id, forest_reserve, plottype, period)) %>% filter(forest_reserve == "Kersselaerspleyn" & plottype == "CP" & period == 1) %>% nrow() == 0

# deze zitten niet in de file => OK - NA

      # logs_by_decay_plot_ <- logs_by_decay_plot %>% 
      #   mutate(vol_log_m3_ha = ifelse(between(plot_id, 2000, 2070) & period == 1 
      #                                 #forest_reserve == "Kersselaerspleyn" & plottype == "CP" 
      #                                 , NA
      #                                 , vol_log_m3_ha)
      #          )
      # 
      # logs_by_decay_plot_ %>% filter(period == 1 & between(plot_id, 2000, 2070)) %>% head()
      #  
      # logs_by_decay_plot <- logs_by_decay_plot_

# decay - spec
# idem
```



## Logs KV pas vanaf 40 cm (2010 en 2020)

Geen opnames van logs in 1ste decade (reeds op NA gezet hierboven)
In 2de en 3de decade pas opgemeten vanaf 40 cm diameter.

DUS in de plot-level-resultaten 
- NA's bij (standaard) volume liggend dood hout
- extra veld `vol_log_m3_ha_min40cm` met volume vanaf 40 cm

*< dataverwerking 2012: "Deadwood: geen volopname van liggend dood hout: daarvoor wordt verwezen naar de 11 cirkels die in KV gelegen zijn"*
==> Wat in de cijfers zit, zijn de liggende bomen met > 40 cm diameter (uit BE-kartering).
Idem dito voor 3e decade: in KV pas vanaf 40 cm (CP's vanaf 10 cm)


```{r check_logs_KV_Kerss}
check <- dendro_by_plot %>% 
  filter(plot_id == 11000)
```

```{r correctie_logs_KV_Kerss}
names(dendro_by_plot)
# "vol_log_m3_ha"           "vol_deadw_m3_ha" 

dendro_by_plot_ <- dendro_by_plot %>% 
  mutate(vol_log_m3_ha_min40cm = 
           ifelse(plot_id == 11000, vol_log_m3_ha, NA),
         vol_log_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_log_m3_ha),
         vol_deadw_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_deadw_m3_ha)
           )

dendro_by_plot_ %>% 
  filter(plot_id == 11000)

dendro_by_plot <- dendro_by_plot_

```

```{r}
# ook voor de andere plot-level-resultaten
      # dendro_by_plot_species = dendro_by_plot_species,
      # dendro_by_diam_plot = dendro_by_diam_plot,
      # dendro_by_diam_plot_species = dendro_by_diam_plot_species,

# spec
dendro_by_plot_species_ <- dendro_by_plot_species %>% 
  mutate(vol_log_m3_ha_min40cm = 
           ifelse(plot_id == 11000, vol_log_m3_ha, NA),
         vol_log_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_log_m3_ha),
         vol_deadw_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_deadw_m3_ha)
           )

dendro_by_plot_species_ %>% 
  filter(plot_id == 11000)

dendro_by_plot_species <- dendro_by_plot_species_

```

```{r}
# diam
dendro_by_diam_plot_ <- dendro_by_diam_plot %>% 
  mutate(vol_log_m3_ha_min40cm = 
           ifelse(plot_id == 11000, vol_log_m3_ha, NA),
         vol_log_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_log_m3_ha)
         # vol_deadw_m3_ha = 
         #   ifelse(plot_id == 11000, NA, vol_deadw_m3_ha)
           )

dendro_by_diam_plot_ %>% 
  filter(plot_id == 11000)

dendro_by_diam_plot <- dendro_by_diam_plot_

# diam - spec
dendro_by_diam_plot_species_ <- dendro_by_diam_plot_species %>% 
  mutate(vol_log_m3_ha_min40cm = 
           ifelse(plot_id == 11000, vol_log_m3_ha, NA),
         vol_log_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_log_m3_ha)
         # vol_deadw_m3_ha = 
         #   ifelse(plot_id == 11000, NA, vol_deadw_m3_ha)
           )

dendro_by_diam_plot_species_ %>% 
  filter(plot_id == 11000)

dendro_by_diam_plot_species <- dendro_by_diam_plot_species_
```

OPGEPAST: tabellen “dendro_by_diam_plot” en “dendro_by_diam_plot_species”: 
diam-klasses 10-15cm/15-20cm/20-25cm/25-30cm/…: “vol_log_m3_ha_min40cm” = NA ipv “0” 

```{r correctie_logs_KV_Kerss2}
unique(dendro_by_diam_plot$dbh_class_5cm)

check <- dendro_by_diam_plot %>% 
  filter(plot_id == 11000 & year %in% c(2009, 2020))

table(check$dbh_class_5cm)

to_small <- c("5 - 10 cm", "10 - 15 cm", "15 - 20 cm", "20 - 25 cm", "25 - 30 cm", "30 - 35 cm", "35 - 40 cm")

dendro_by_diam_plot_ <- dendro_by_diam_plot %>% 
  mutate(vol_log_m3_ha_min40cm = ifelse(plot_id == 11000 & dbh_class_5cm %in% to_small,
                                        NA,
                                        vol_log_m3_ha_min40cm))

check2 <- dendro_by_diam_plot_ %>% 
  filter(plot_id == 11000 & year %in% c(2009, 2020) & dbh_class_5cm %in% to_small)

dendro_by_diam_plot <- dendro_by_diam_plot_

# idem voor xxxxx_species
dendro_by_diam_plot_species_ <- dendro_by_diam_plot_species %>% 
  mutate(vol_log_m3_ha_min40cm = ifelse(plot_id == 11000 & dbh_class_5cm %in% to_small,
                                        NA,
                                        vol_log_m3_ha_min40cm))

check2 <- dendro_by_diam_plot_species_ %>% 
  filter(plot_id == 11000 & year %in% c(2009, 2020) & dbh_class_5cm %in% to_small)

dendro_by_diam_plot_species <- dendro_by_diam_plot_species_


```

> Ook voor decaystage aanpassingen nodig
!! als package aangepast is, moet onderstaande code aangepast worden, want
dan ook staand dood hout per decaystage.

```{r}
# ook voor de andere plot-level-resultaten
      # logs_by_decay_plot = logs_by_decay_plot,
      # logs_by_decay_plot_species = logs_by_decay_plot_species

# decay
logs_by_decay_plot_ <- logs_by_decay_plot %>% 
  mutate(vol_log_m3_ha_min40cm = 
           ifelse(plot_id == 11000, vol_log_m3_ha, NA),
         vol_log_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_log_m3_ha)
           )

logs_by_decay_plot_ %>% 
  filter(plot_id == 11000)

logs_by_decay_plot <- logs_by_decay_plot_

# decay - spec
logs_by_decay_plot_species_ <- logs_by_decay_plot_species %>% 
  mutate(vol_log_m3_ha_min40cm = 
           ifelse(plot_id == 11000, vol_log_m3_ha, NA),
         vol_log_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_log_m3_ha)
           )

logs_by_decay_plot_species_ %>% 
  filter(plot_id == 11000)

logs_by_decay_plot_species <- logs_by_decay_plot_species_
```

# Vergelijking met oude data

```{r eval = FALSE}
dendro_by_plot_git <- read_vc(file = "dendro_by_plot", root = path_to_forresdat_data)

dendro_by_plot_git <- dendro_by_plot_git %>% 
  select(plot_id, year, everything()) %>% 
  select(names(dendro_by_plot))
nrow(dendro_by_plot) == nrow(dendro_by_plot_git)
summary(dendro_by_plot)
names(dendro_by_plot) == names(dendro_by_plot_git)
summary(dendro_by_plot_git)


dendro_by_plot %>% select(-year) %>% arrange(plot_id, period) == dendro_by_plot_git %>% select(-year) %>% arrange(plot_id, period)
# OK denk ik andere ordening van variabelen
dendro_by_plot == dendro_by_plot_git

head(dendro_by_plot %>% arrange(plot_id, period)); head(dendro_by_plot_git %>% arrange(plot_id, period))


dendro_by_plot_species_git <- read_vc(file = "dendro_by_plot_species", root = path_to_forresdat_data)
nrow(dendro_by_plot_species) == nrow(dendro_by_plot_species_git)

dendro_by_diam_plot_git <- read_vc(file = "dendro_by_diam_plot", root = path_to_forresdat_data)
nrow(dendro_by_diam_plot) == nrow(dendro_by_diam_plot_git)

logs_by_decay_plot_git <- read_vc(file = "logs_by_decay_plot", root = path_to_forresdat_data)
nrow(logs_by_decay_plot) == nrow(logs_by_decay_plot_git)

```

# Aanmaak list

```{r new_list_dendro}
# dendro_by_plot_species <- dendro_by_plot_species %>% 
#   mutate(plot_id = as.integer(plot_id),
#          species = as.integer(species))
# 
# dendro_by_diam_plot_species <- dendro_by_plot_species %>% 
#   mutate(plot_id = as.integer(plot_id),
#          species = as.integer(species))

# opnieuw list van maken om te exporteren en plotinfo aan te koppelen
dendro <- list(
      dendro_by_plot = dendro_by_plot,
      dendro_by_plot_species = dendro_by_plot_species,
      dendro_by_diam_plot = dendro_by_diam_plot,
      dendro_by_diam_plot_species = dendro_by_diam_plot_species,
      logs_by_decay_plot = logs_by_decay_plot,
      logs_by_decay_plot_species = logs_by_decay_plot_species
    )
```


# Plotinfo toevoegen (aan csv-files)

```{r join_plottype_surveynr_BR}
dendro_plotinfo <- lapply(dendro, function(x) left_join(x, plotinfo %>% select(plot_id, forest_reserve, plottype, period, survey_number), by = c("plot_id", "period")))
# lapply: same function over all elements of the list
```


# Export plot-level-data

**!!!! ENKEL PLOTS EXPORTEREN WAARVAN DATA PROCESSED ZIJN!!**
Is standaard parameter bij inladen dendro-data 

**DUS: zorgen dat dit veld in Fieldmap up-to-date is, zie chunck "plotinfo_processed"**


Enkele verduidelijkingen:

* "number_of_tree_species" = aantal soorten obv de levende bomen

* "stems_per_tree" = meerstammigheid (stem_number_ha / number_of_trees_ha): heeft hier geen zin, maar dient als insteek voor berekeningen per soort

* "vol_bole_alive_m3_ha" en "vol_bole_dead_m3_ha": volume zonder crown, 
versus "vol_alive_m3_ha" en "vol_dead_standing_m3_ha"

* "vol_log_m3_ha": liggend dood hout (NA als er geen deadwood survey gebeurd is)

* "vol_deadw_m3_ha": staand en liggend dood hout (NA als er geen deadwood survey gebeurd is)


```{r save_dendro_git, eval = FALSE}
# geen plotinfo naar git
save_results_git(
  results = dendro,
  repo_path = path_to_git_forresdat,
  strict = TRUE
)
```

```{r save_dendro_git_manueel, eval = FALSE}
# manueel - eigen simpele functie - als save_results_git niet werkt
save_results_tsv(dendro, 
                 root = path_to_forresdat_data, 
                 strict = FALSE)
```


```{r save_dendro_access_csv, eval = FALSE}
# hier wel plotinfo (plottype, BR, surveynr mee wegschrijven)

# volgende functie heb ik zelf geschreven, zit niet in het package!
save_results_csv (
    results = dendro_plotinfo,
    output_dir = path_to_plotlevel_csv
    )

# afgerond voor export naar access
dendro_round <- dendro_plotinfo %>% 
  lapply(., function(x) round_df(x, 2))

save_results_access (
  results = dendro_round,
  database = path_to_analysis_set_db,
  remove_tables = TRUE
  )

```

Direct naar gdrive exporteren (csv): 
naar **/PRJ_BOSECO_ALGEMEEN/PRJ_BR_AanvraagGegevens/00_METADATA-ALL_PLOTS/_plot-level-data/**

```{r save_dendro_gdrive, eval = FALSE}
save_results_csv(
    results = dendro_plotinfo,
    output_dir = path_to_plotlevel_gdrive
    )

```


**Na update van forresdat, project "forresdat" openen en alles naar de cloud pushen**
**Eventueel ook access op gdrive plaatsen**