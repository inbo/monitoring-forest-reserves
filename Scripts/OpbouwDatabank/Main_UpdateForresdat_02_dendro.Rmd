---
title: "Update forresdat 2 - dendro op plotniveau"
author: "Anja Leyman"
date: "`r Sys.Date()`"
output: 
  html_document:
    keep_md: FALSE
    number_sections: yes
    fig_caption: yes
    code_folding: hide
    toc: TRUE
    toc_float:
      collapsed: yes
      smooth_scroll: yes
---


```{r Rm, eval = FALSE}
rm(list=ls())
```

```{r Setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  eval = FALSE,  # FALSE: dan kan ik knitten zonder dat er iets gebeurt
  message = FALSE,
  warning = FALSE, 
  fig.width = 9,
  fig.align = TRUE)

library(here)

# libraries & invoergegevens & functions
source(here::here("scripts/Setup.R"))

```


```{r Setup2}
path_to_html_teamdrive <- paste0(path_to_dataverwerking_teamdrive, "25_Overkoepelend")
```


> juiste forrescalc kiezen:   
- om weg te schrijven naar forresdat - branch main => met juiste release van het package: dan `install.packages("forrescalc")`  
- laatste correcties van forrescalc => juiste branch selecteren in forrescalc en opnieuw builden - wegschrijven kan naar forresdat - branch "develop"
(10/3/25: branch 'bugfix' met corr van read_forresdat waarbij we de develop branch kunnen selecteren ipv main)

```{r forrescalc_to_write_to_forresdat, eval = FALSE}
# !!! eerst zeker 'install.packages("forrescalc")
# zodat forresdat-data goede release krijgt!
# zie mail 7/10/24 van Els L.
# soms een andere branch nodig als Els nog iets moet fixen, maar als ik naar forresdat 
# wil wegschrijven, moet ik officiële versie van forrescalc gebruiken

install.packages("forrescalc")

```


# Vraagstelling
DOEL van dit script is een update van forresdat gegevens naar 

- forresdat-folder als tsv (nadien nog te pushen naar github)
- BR_analysedb.accdb
- output-folders "_plot-level-data" en "_tree-level-data" als csv
- gdrive-folders "_plot-level-data" en "_tree-level-data" als csv

Zoniënwoud blijkt op meerdere vlakken uitzonderingen te bevatten.
Deze uitzonderingen worden na het inladen van de data gecorrigeerd. 


```{r results='hold', eval=TRUE}
path_to_forresdat_data
path_to_analysis_set_db
path_to_plotlevel_csv
path_to_treelevel_csv
path_to_output_gdrive
path_to_meetgegevens

```

# SVZ

- 25/9/2024: eerste keer op basis van een kopie van de volledige moederdatabank
(te vinden als zip-file op citrix onder "...\Projects\PRJ_BosEco\PRJ_ALG_FIELDMAP\FM_MDB BOSRESERVATEN")

- 18/12/2024: er werd beslist (nalv Euforia) om **Zoniën** op te splitsen in **4 sites**
(directere link met wanneer ingesteld als bosreservaat).
Naam "forest_reserve" werd in moederdatabank aangepast: Kersselaerspleyn, Harras 
en Zwaenepoel werden vervangen door     

    - Zoniën KERN_1983: bevat KV en 11 CP's (voorheen "Kersselaerspleyn")     
    - Zoniën UITBR_1995: bevat de CP's die NIET in de oude/eerste kernvlakte van 1983 
    liggen (voorheen "Kersselaerspleyn")     
    - Zoniën HARRAS_1995: bevat KV en CP (voorheen "Harras" voor KV en "Zwaenepoel" voor CP's)    
    - Zoniën UITBR_2010: bevat enkel CP's (voorheen "Zwaenepoel", maar zonder deze die nu in "HARRAS_1995" liggen)

- 10/3/2025: update van de reeds verwerkte data, vooral vanuit vraag naar trees wide beuk
(trees_weide_beuk: tabel met ook Wijnendale, Everzwijnbad en Jansheideberg)


# Load plotinfo

Plotinfo inladen: `plottype`, naam `forest_reserve` en info over survey's.
(plotinfo op gdrive en forresdat: enkel processed plots!)

```{r }
# mbv forresdat
# plotinfo <- read_forresdat(file = "plotinfo", root = path_to_forresdat_data)
# names(plotinfo)
# ?read_forresdat

# van c-schijf
plotinfo <- read.csv2(paste0(path_to_plotlevel_csv, "plotinfo.csv")) %>% 
  select(-1)

```


# Load dendro data - voorlopig OK - 10/3/2025

Standaard wordt enkel processed data ingeladen mbv de load-functies.
We willen voor onze output ook enkel deze processed data mee (voor non-processed 
data deze telkens opnieuw inladen en berekenen)

```{r load_dendro1_processed_or_not}
data_dendro <- load_data_dendrometry(database = path_to_fieldmap_db, 
                                     extra_variables = TRUE, 
                                     processed = TRUE) %>% 
  filter(plottype != "OTHER")  # enkel CP of CA
# 79866 + 2455 = 82321 (rodebos)
# 83171 (22/11/2022)
# 87742 (18/12/2024)

```


```{r load_dendro2}
# enkel processed
data_shoots <- load_data_shoots(database = path_to_fieldmap_db, extra_variables = TRUE)

data_stems  <- compose_stem_data(data_dendro, data_shoots, extra_variables = TRUE)

# height_model <- load_height_models()
# sneller en bij problemen met forresheights github, lokale modellen gebruiken
path_to_height_models <- "C:/03_BR/1_DataVerwerkingBR/Data/Hoogtemodellen/"
height_model <- load_height_models_local(path_to_height_models)
# mean(height_model$P1) == mean(height_model2$P1)

data_deadwood <- load_data_deadwood(database = path_to_fieldmap_db, processed = TRUE) %>% 
  filter(plottype != "OTHER")
data_deadwood <- calc_intact_deadwood(data_deadwood)
```

```{r check_heightmodels}
table(height_model$forest_reserve, height_model$period)
table(plotinfo$forest_reserve)

height_model %>% group_by(forest_reserve) %>% summarise(n = n()) %>% ungroup() %>% anti_join(plotinfo, by = c("forest_reserve"))
# prognoses_extra: OK, deze hoeven niet meegenomen worden bij de standaard dataverwerking, 
# want geen deel van monitoring (onbeheerde) BRen
# In moederdb zijn plotdetails niet ingevuld (geen processed en geen "reservaat"forest_reesrve") 
# => trees werden niet ingeladen 
```

# Correctie year van dendrometrie - NIET MEER NODIG

Year = jaar van groeiseizoen
Grens was gelegd op 1/7, nu naar 1/5.
Aangevraagd in issue # 114, OK (27/3/2024)
<!-- Berekening van year en year_dendro aangepast voor load_data_dendrometry() en load_plotinfo():  -->

**T.e.m. 30 april wordt nog bij het vorige jaar geteld, vanaf 1 mei wordt bij het **
**nieuwe jaar geteld (1 mei bij huidig jaar).**

Volgende reservaten daadwerkelijk over twee jaartallen heen opgemeten:

- Bos Terrijst CA - 1eSET: OK
- Heirnisse - 2eSET: 5 plots 9/2014: OK
- Everzwijnbad - 3eSET: 1 plot (118) pas op 5/5/2023 opgemeten
- Wijnendale - 3eSET: 2 plots (425 + 503) pas volgend jaar in nov (07/11/2023) opgemeten => mail naar Peter: moet 7/11/2022 zijn, gecorrigeerd, maar code nog niet opnieuw laten lopen
- Zoniën HARRAS_1995 - 3eSET: 3 plots nog opgemeten 14/5/2020, rest in 2019 opgemeten
- Zoniën UITBR_2010 - 3eSET: 52 plots jan 2020 tot april 2020 en 12 plots in mei 2020


```{r check, results='hide'}
names(data_dendro)

year_range <- data_dendro %>% 
  group_by(forest_reserve, period) %>% 
  summarize(min_year = min(year), 
            max_year = max(year),
            year_range = paste0(min_year, " - ", max_year)) %>% 
  ungroup()

t <- year_range %>% 
  filter(min_year != max_year)

```


```{r results='hide'}
t2 <- data_dendro %>% 
  inner_join(t)

t2 %>% group_by(forest_reserve, period, year) %>% 
  summarize(n_plots = n_distinct(plot_id)) %>% 
  ungroup() %>% 
  filter(period == 3)

t2 %>% filter(forest_reserve == "Everzwijnbad" & year == 2023)
t2 %>% filter(forest_reserve == "Wijnendalebos" & year == 2023)
t2 %>% filter(forest_reserve == "Zoniën HARRAS_1995" & year == 2020)
t2 %>% filter(forest_reserve == "Zoniën UITBR_2010" & year == 2020)
```


# Liggend dood hout (intact/fragment) volume bijwerken - OK - 10/3/2025

De volumeberekening van liggend dood hout baseert zich op het veld `calc_volume_m3`
uit FM-databank (layer `Deadwood`).

Indien deadwood als fragment opgemeten werd (zie veld `IntactFragment` en 
bijhorende LU-list `qVdagnVfm`), is dit een kopie van het veld `Volume_m3.`
Dit veld wordt in FM-DC automatisch berekend. 
Belangrijk is om te zorgen dat dit volume als "inside plot" berekend wordt.

Indien deadwood als intact aangevinkt staat, moeten er tarieven gebruikt worden om
dit volume te berekenen.
Er werd afgesproken met Peter dit enkel nog te gebruiken voor de BE's of de KV's  
als ze plotgrens niet overschrijden. 

- Enkel in Kerss KV - 2eSET & 3eSET staan nog (veel) intacte bomen: 
klopt wel degelijk...voor KV KP = BEkartering....
- In 1eSET niks meer (aangevuld met fragmenten - copy van 2eSET - door Peter)
- Héél uitzonderlijk in 3e SET: 2 bomen in KV Rodebos (plot 43000)


## Fragmenten - update van volume in FM

**Elke keer te doen bij nieuwe db** 

In Fieldmap zijn er twee velden opgenomen, die "manueel" bijgewerkt moeten worden.
Makkelijkste is om dit hier op te vangen in een updatequery.

Het gaat om de velden 
- `calc_volume_m3`
- `calc_length`

Deze velden zijn exacte copies van de velden 
- `volume_m3` (als IntactFragment = 20)
- `length_m`

Maar omdat deze laatste twee velden per ongeluk gewijzigd kunnen worden in FM-DC 
(te berekenen als "Total Volume" of "Volume inside plot"), is het veiliger om 
deze waardes vast te klikken in `calc_volume_m3` & `calc_length`.

Voor 3de set was `calc_volume_m3` niet steeds berekend (in acces).
Dat doen we hier mbv een updatequery, nadat we zeker zijn dat de waardes correct 
berekend zijn in FM-DC ("inside plot").
Dit moet normaliter enkel gebeuren voor periode 3, periode 1 en 2 zijn bijgewerkt 
in de moederdatabank zelf.

**!!! ZEKER WANNEER ER EXTRA PLOTS TOEGEVOEGD ZIJN**
Dan blijkt volume nog niet "inside plot" berekend te zijn!
Zoals nu (10/3/2025) Withoefse heide, Heirnisse en Jansheideberg


```{r sql_update_calc_deadw_inside_plot, eval = FALSE}
# !! ENKEL UITVOEREN NADAT IN DC "volume inside plot" BEREKEND IS
# data_deadwood_old <- data_deadwood

# layers_deadw <- c("Deadwood", "Deadwood_2eSET", "Deadwood_3eSET")
# 
# for (x in layers_deadw){
# 
# qry_update_calc_vol <- "UPDATE x 
#       LEFT JOIN qVdagnVfm ON x.IntactFragment = qVdagnVfm.ID 
#       SET x.CalcVolume_m3 = [Volume_m3] 
#       WHERE (((x.CalcVolume_m3) Is Null) AND ((x.IntactFragment)=20))"
# 
# qry_update_calc_length <- "UPDATE x 
#       LEFT JOIN qVdagnVfm ON x.IntactFragment = qVdagnVfm.ID 
#       SET x.CalcLength_m = [Length_m] 
#       WHERE ((x.CalcLength_m) Is Null)"
#   
# conn <- odbcConnectAccess2007(path_to_fieldmap_db)
# # conn <- odbcConnectAccess2007(path_to_fieldmap_db), rows_at_time = 1)
# 
# sqlQuery(conn,qry_update_calc_vol)
# sqlQuery(conn,qry_update_calc_length)
# 
# odbcClose(conn)
# }

# enkel deadw_3eSET
qry_update_calc_vol <- paste0("UPDATE Deadwood_3eSET SET Deadwood_3eSET.CalcVolume_m3 = Deadwood_3eSET.Volume_m3 WHERE ((Deadwood_3eSET.CalcVolume_m3 Is Null) AND (Deadwood_3eSET.IntactFragment=20))") %>%
           noquote()

qry_update_calc_length <- "UPDATE Deadwood_3eSET SET Deadwood_3eSET.CalcLength_m = Deadwood_3eSET.Length_m WHERE ((Deadwood_3eSET.CalcLength_m) Is Null)" %>%
           noquote()
  
conn <- odbcConnectAccess2007(path_to_fieldmap_db)

sqlQuery(conn,qry_update_calc_vol)
sqlQuery(conn,qry_update_calc_length)

odbcClose(conn)

# opnieuw inladen
data_deadwood_old <- data_deadwood
data_deadwood <- load_data_deadwood(database = path_to_fieldmap_db, processed = TRUE) %>% 
  filter(plottype != "OTHER")
data_deadwood <- calc_intact_deadwood(data_deadwood)

data_deadwood %>% filter(is.na(calc_volume_m3)) %>% nrow()
# 0
```

## Intacte bomen - NIET MEER NODIG

Indien deadwood als intact (veld `IntactFragment`) aangevinkt staat, moeten er 
**tarieven** gebruikt worden om dit volume te berekenen.
(zie issue # 105) 

Er werd afgesproken met Peter `intact` enkel nog te gebruiken voor de BE's of de KV's  
(als bomen tenminste plotgrens van KV niet overschrijden). 

- in KV Wijnendale één intacte

Peter heeft een controle gedaan op oudere data (zie mail 24/11/2022)
Intact kan NIET bij 
- een substantieel deel dat buiten de plotgrenzen valt (> 1/2de)  
- decay 14 of 15 => allemaal fragment   
- decay 13: min_diameter > 150 (geen top aanwezig) => fragment (18 van de 42 intacte met decay 13)
 
Dit werd ook zo afgesproken met Peter voor veldwerk vanaf 24/11/2022:  
  - sowieso alle met decay 14 of 15 = fragment   
  - decay 13: enkel deze met min_diameter > 150 als fragment

<!-- In 1eSET werd wel nog gebruik gemaakt van intacte bomen. -->
<!-- Peter heeft dit gecheckt: ca 140 bomen van de 4000 in dit geval. -->
<!-- Daarvan veel meer dan de helft sowieso te smal om zware zijtakken (> 10 cm) te hebben.  -->
<!-- Daarenboven ook kroon soms deels buiten CP of KV. -->
<!-- ==> Wellicht zou fout door te werken met enkel fragmenten verwaarloosbaar zijn. -->
<!-- (eventueel eens te checken: volgens Peter enkel KV Pruikenmakers mogelijks afwijking) -->


<!-- 28/11/2019: (c) Peter (zie Trello):   -->
<!-- Aangepast in MDB (update op citrix), alles voor CP's en KV's staat nu op 20 (calc FieldMap),  -->
<!-- dit volgens de besproken werkwijze;  -->
<!-- uiteindelijk werden hiervoor in 7 plots kroontakken uit de 2e set gekopieerd  -->
<!-- naar de 1e Set, afbraak werd op 1 of 2 gezet cfr stam,  -->
<!-- er werd in opmerkingsveld "manueel" genoteerd: -->
<!-- plot 922 : 1 essentak -->
<!-- plot 934 : 1 eikentak -->
<!-- plot 803 : 2 beukentakken -->
<!-- plot 819 : 1 lorkentak -->
<!-- plot 71000 : 4 beukentakken -->
<!-- plot 81000 : 3 eikentakken -->
<!-- plot 12100 : 29 eikentakken (kv pruikemakers)!! -->

<!-- Volumes dood hout kunnen specifiek voor deze plots vgl'en worden met oude berekende data als proef. -->

<!-- Mail Peter 23/11/2022 ivm Kerss KV: -->
<!-- "Nu helemaal gerecapituleerd hoe het zit met dode liggende (zware) bomen kernvlakte Kerselaerspleyn. -->
<!-- Deze werden hermeten in de plot 13100 Natman en mosbomen ifv opstart inventarisatie Glen toen. -->
<!-- Hiervoor werd boomlaag gekopieerd over geheel van Kersselaerspleyn en enkel hermeten/bijgemeten, verkort voor oudere objecten -->
<!-- in de kernvlakte en rond de kernvlakte =bufferzone. Nadien heb ik dan in de plot 11000, de hermeten objecten die voldoen aan de diameter -->
<!-- en volledig of deels binnen de plotsgrens van de kernvlakte liggen ingeladen, vandaar uitzonderlijk hier wel combi intact en afgesneden, -->
<!-- In die natmanbomenplot (13100à zitten/zaten bijvoorbeeld ook bomen met kleine diameters die destijds door onze Ruben werden bemonsterd en een natmanid kregen -->
<!-- en die nu voor Glen zijn werk opnieuw werden bekeken, als ze er nog lagen." -->

```{r posssible_fragment_check, eval = FALSE}
# !! gemerkt dat calc_vol in Kerss KV (plot 11000, 2de en 3de decade) exacte copie 
# is van volume inside plot, terwijl het om intacte bomen gaat
# => volume bijwerken

data_deadwood_intact <- data_deadwood %>% 
  filter(intact_fragm == 10)

# toch nog niet helemaal zoals afgesproken met Peter => file doormailen met mogelijke fragmenten
posssible_fragment <- data_deadwood_intact %>% 
  filter((calc_length_m < total_length_m/2)|
           decaystage == 14|
           (decaystage == 13 & min_diam_mm > 150) |
           min_diam_mm > 150) %>% 
  select(plot_id, plottype, forest_reserve, , period, date_dendro, lying_deadw_id,
         species, decaystage, intact_fragm, calc_volume_m3, calc_length_m, total_length_m,
         min_diam_mm, max_diam_mm)

table(posssible_fragment$decaystage)

write_csv2(posssible_fragment, here::here("output/posssible_fragment_Kerss_KV.csv"))

```


```{r check_vol_deadw}
check_deadw <- data_deadwood %>% 
  filter(is.na(calc_volume_m3))
nrow(check_deadw) == 0
# waren er 2, nu 0 (intact, plot 43.000, geprogrammeerd mbv tarieven dagnelie)

# summary(check_deadw$period) # enkel periode 3
# unique(check_deadw$plot_id) # enkel plot 43000 
# plotinfo %>% filter(plot_id %in% check_deadw$plot_id) # Rodebos KV

```

# Correctie staande bomen - Zoniën KERN_1983  

- Zoniën KERN_1983 - KV - 1986: 
** geen shoots, geen deadwood, reg of veg
** pas vanaf dbh 30 cm   


- Zoniën KERN_1983 - KV - 2000: 
** pas vanaf dbh 30 cm volopname  
** boompjes met dbh 10-30 cm werden geteld


**Methodiekrapport**:

*Dendrometrics*: 
Full survey of all trees (L+D) with DBH>30cm in 1986-87; revisited in 1991 to
record windthrown trees due to windstorms of february 1991 (Vivian & Wiebke). Volume
calculations with tariffs (Van den Berge et al. 1990; 1992).

In 2000/01 : re-survey of full area, with DBH threshold of 30 cm, trees of 10-30 cm counted,
not positioned; smaller trees not surveyed in full area but in subsamples (see regeneration).

2010 and 2020 : full survey of all trees (L+D) with DBH>5cm.

## Staande bomen 1ste decade KV Kersselaerspleyn pas vanaf 30 cm

*Eigen verwerking*: 

Concreet Kersselaerspleyn_IA_KV1986etc_INBO33: bevat alle jaartallen:
	- 1986 
	- 2000 (!! Pas gebiedsdekkend opgemeten vanaf 30 cm DBH => extra filter toevoegen bij de verwerking)
	- 2010

In 2000 werd gebiedsdekkend gemeten vanaf 30 cm DBH, en in twee verjongingsgroepen vanaf 5 cm.
Daarnaast streeplijsten: samen met veg in 750 subsamples: 30-20, 20-10 en < 10 cm.
Afzonderlijk verwerkt: zie `CA_Kerss_5_30_dendro_by_xxx`

**DAAROM in trees en stems deze < 30 cm wegfilteren (want dat zijn bomen in 2 kleine **
**verjongingsgroepjes, bijgevolg niet representatief) zdd we resultaten hebben van levend > 30 cm**
**(cfr dataverwerking in 2012) **

> We gaan ervanuit dat degene die data gebruiken, het methodiekrapport gelezen hebben en dit dus weten.
Staat ook in metadata

```{r}
data_stems_<- data_stems %>% 
  filter(plot_id != 11000 | 
           period %in% c(2,3) |
           dbh_mm >= 300)

check <- data_stems %>% 
  anti_join(data_stems_)
table(check$period, check$plot_id)   # ok
  #     11000
  # 1   913
data_stems <- data_stems_

data_dendro_ <- data_dendro %>% 
  filter(plot_id != 11000 | 
           period %in% c(2,3) |
           dbh_mm >= 300)
check <- data_dendro %>% 
  anti_join(data_dendro_)
table(check$period, check$plot_id)   # ok
  #     11000
  # 1   913
data_dendro <- data_dendro_

```


```{r}
check_Kerss <- data_stems %>% 
  filter(plot_id == 11000 & period == 1)
min(check_Kerss$dbh_mm) == 300 # 300
```

# Calculate dendro data

```{r save_previous, eval = FALSE}
# laatste update: 10/3/2025
save(data_stems, data_dendro, data_shoots, height_model, data_deadwood,
     file=here::here("RData/main02_dendro_basics.RData"))

# load(here::here("RData/main02_dendro_basics.RData"))
```


```{r calc_stems_tree}
data_stems_calc <- calc_variables_stem_level(data_stems, height_model)

data_dendro_calc <- calc_variables_tree_level(data_dendro, data_stems_calc)

# onderstaande functie bevat reeds berekening van data_stems_calc/data_trees_calc
# en ook data_deadwood <- calc_intact_deadwood(data_deadwood)
dendro <- calculate_dendrometry(data_dendro, data_deadwood, data_shoots, height_model, plotinfo)
```


```{r CreateSeparateDataframesDendro}
for (tablename in names(dendro)) {
     assign(tablename, dendro[[tablename]])
} 

```


# Check NA's

Niet alle NA's moeten door een 0 vervangen worden.
Een NA wijst vaak op een missing value in FM => dat eerst oplossen

> OPGEPAST
> Als in trees layer het veld `ind_sht_cop` = coppice (12)
én de  shoot zit toch niet in de shoots layer
dan wordt een fout gecreëerd in forrescalc (met NA voor volume als gevolg)
DUS BEST MEENEMEN IN DATACONTROLE

> OOK AANDACHT VOOR MISSING DBH OF HEIGHT VAN SNAGS !!!


## Tree-level

```{r check_NA1, eval = FALSE}
names(data_stems_calc)
col <- c("dbh_mm", "species", "dbh_class_5cm", "calc_height_m", "vol_crown_m3",
         "vol_bole_m3", "vol_tot_m3", "stem_number_alive_ha", "stem_number_dead_ha",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha",
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha",
         "intact_snag", "alive_dead", "ind_sht_cop")
nrow(data_stems_calc  %>%
       filter_at(col, any_vars(is.na(.)))) == 0

col <- c("dbh_mm", "species", "dbh_class_5cm", "calc_height_m",
         "basal_area_m2", "vol_bole_m3", "vol_crown_m3", "vol_tot_m3",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha",
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha",
         "number_of_trees_alive_ha", "number_of_trees_dead_ha")

nrow(data_dendro_calc  %>%
       filter_at(col, any_vars(is.na(.)))) == 0

# bij problemen ---
# names(data_stems_calc)
# names(data_dendro_calc)
# data_stems_NA <- data_stems_calc %>%
#   filter_at(col, any_vars(is.na(.))) %>%
#   select(plot_id, period,
#          tree_measure_id, shoot_measure_id, 
#          dbh_mm, species, alive_dead,
#          height_m, calc_height_m, vol_bole_m3, vol_bole_alive_m3_ha,
#          decaystage, intact_snag,
#          ind_sht_cop,
#          contains(c("iufro", "remark"))
#          ) %>%
#   left_join(plotinfo, by = c("plot_id", "period"))
# 
# data_stems_whyNA <- data_stems_calc %>%
#   filter(intact_snag == 10 & ind_sht_cop == 12 & is.na(height_m)) %>%
#   select(plot_id, period,
#          tree_measure_id, shoot_measure_id, 
#          dbh_mm, species, alive_dead,
#          height_m, calc_height_m, vol_bole_m3, vol_bole_alive_m3_ha,
#          decaystage, intact_snag,
#          ind_sht_cop,
#          contains(c("iufro", "remark"))
#          ) %>%
#   left_join(plotinfo, by = c("plot_id", "period"))
```

Mogelijk probleem kan zijn dat er geen hoogte ingevuld staat bij snag, dan wordt geen volume berekend.

## Dendro_by_plot 

```{r check_NA2}
col <- c("year", "number_of_tree_species", "number_of_trees_ha", "stem_number_ha",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha", 
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha",
         "vol_log_m3_ha", "vol_deadw_m3_ha", "stems_per_tree")

t <- dendro_by_plot %>% filter_at(col, any_vars(is.na(.)))
# 59 records: "vol_log" = NA: 11000, 15xx: klopt survey_deadw = FALSE 
# of geen bomen en daardoor "stems_per_tree" = Inf (Ename + plot 475) 

# beperkter
col <- c("year", "number_of_tree_species", "number_of_trees_ha", "stem_number_ha",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha", 
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha")

dendro_by_plot %>% filter_at(col, any_vars(is.na(.))) %>% nrow == 0
```

## Dendro_by_plot_species 

```{r}
col <- c("year", "number_of_trees_ha", "stem_number_ha",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha", 
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha",
         "vol_log_m3_ha", "vol_deadw_m3_ha")

dendro_by_plot_species %>% filter_at(col, any_vars(is.na(.))) %>% nrow()
# 100/101

check <- dendro_by_plot_species %>% filter_at(col, any_vars(is.na(.)))
# is OK, zijn alle waar geen liggend dood hout gemeten is
```


# Stems per tree - NA 

Komt voor in `dendro_by_plot` en `dendro_by_plot_species`, als proxy voor de meerstammigheid.
NA als er geen bomen zijn, is OK.

```{r}
dendro_by_plot %>% filter(is.na(stems_per_tree)) %>% nrow() == 14
# ename en plot 475 waar geen bomen staan; plot 52000: gevraagd aan Peter in mail (10/3/2025)

dendro_by_plot %>% filter( stems_per_tree == 0) %>% nrow() == 0
# komt niet voor

```
`dendro_by_plot_species`

```{r}
dendro_by_plot_species %>% filter(is.na(stems_per_tree)) %>% nrow()
# 1389 records / 1479
dendro_by_plot_species %>% filter(stem_number_ha == 0) %>% nrow()
# ook 1389 /1479 => OK

dendro_by_plot_species %>% filter( stems_per_tree == 0)
# komt niet voor

```


## Dendro_by_diam_plot

```{r}
col <- c("year", "stem_number_alive_ha", "stem_number_dead_ha",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha", 
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha",
         "vol_log_m3_ha")

dendro_by_diam_plot %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0
# 280 / 281

check <- dendro_by_diam_plot %>% filter_at(col, any_vars(is.na(.)))
# klopt, geen opname liggend dood hout
# 110000, 52000, beheerd deel kluisbos
# unique(check$plot_id)
```


## Dendro_by_diam_plot_species

Idem als voorgaande.

```{r}
col <- c("year", "species", "stem_number_alive_ha", "stem_number_dead_ha",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha", 
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha",
         "vol_log_m3_ha")

dendro_by_diam_plot_species %>% filter_at(col, any_vars(is.na(.))) %>% nrow() 

check <- dendro_by_diam_plot_species %>% filter_at(col, any_vars(is.na(.)))
# deadwood geen opname, ename: geen species en dbh_clss, 734: geen levende bomen in dbhclass 35-40cm 

# beperkter
col <- c("year", "stem_number_alive_ha", "stem_number_dead_ha",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha", 
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha")

dendro_by_diam_plot_species %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0
# 
# # enkel vol_dead_standing is NA, rest is 0 zoals het zou moeten zijn
# # dit veld moet ook 0 worden
# dendro_by_diam_plot_species_ <- dendro_by_diam_plot_species %>% 
#   replace((is.na(.)), 0)
# 
# dendro_by_diam_plot_species_ %>% filter_at(col, any_vars(is.na(.))) %>% nrow()
# # OK, geen NA's meer
# 
# dendro_by_diam_plot_species <- dendro_by_diam_plot_species_
```

## Deadw_by_decay_plot

```{r}
names(deadw_by_decay_plot)

col <- c("year", "decaystage", "vol_log_m3_ha", "vol_bole_dead_m3_ha")

deadw_by_decay_plot %>% filter_at(col, any_vars(is.na(.))) %>% 
  filter(vol_bole_dead_m3_ha != 0 | vol_log_m3_ha != 0) %>% nrow() == 0

check <- deadw_by_decay_plot %>% filter_at(col, any_vars(is.na(.))) %>% 
  filter(vol_bole_dead_m3_ha != 0 | vol_log_m3_ha != 0)
# deels decaystage missing => ook OK
# deels geen liggend dood hout opname => ok
```

## Deadw_by_decay_plot_species

```{r}
col <- c("year", "decaystage", "species", "vol_log_m3_ha", "vol_bole_dead_m3_ha")

deadw_by_decay_plot_species %>% filter_at(col, any_vars(is.na(.))) %>% 
  filter(vol_bole_dead_m3_ha != 0 | vol_log_m3_ha != 0) %>% nrow() == 0

check <- deadw_by_decay_plot_species %>% filter_at(col, any_vars(is.na(.))) %>% 
  filter(vol_bole_dead_m3_ha != 0 | vol_log_m3_ha != 0)
# OK, kan vergeten zijn
```



# Add zero's - NIET MEER NODIG

Sommige plots bevatten geen bomen én geen dood hout (Bv. Ename). 

Sinds 18/12/2024: nulwaardes automatisch toegevoegd aan `dendro_by_plot` obv 
`plotinfo` - `survey_trees` en `survey_deadw`.

```{r eval = FALSE}
dendro_by_plot %>% left_join(plotinfo) %>% 
  filter(forest_reserve == "Ename" & vol_alive_m3_ha == 0) %>% 
  nrow() == 13
```

# Liggend dood hout

`vol_log_m3_ha` zit zowel in `dendro_by_plot` als in `deadw_by_plot`.

In zowel `dendro_by_plot` als `deadw_by_plot` zijn NA's OK 
Ze worden correct opgevangen in forrescalc: NA versus 0: enkel 0 als survey_deadw = TRUE

```{r check_dead2}
no_deadw <- plotinfo %>% 
  filter(survey_trees == TRUE & survey_deadw == FALSE)
nrow(no_deadw)
table(no_deadw$forest_reserve, no_deadw$period)
```
bv. plot 11000 (Zoniën KERN_1983): period 1 en 0 niet opgemeten => moet NA worden ipv 0

```{r eval=FALSE}
data_deadwood %>% filter(plot_id == 11000 & period == 1) %>% nrow() == 0
# enkel data van opgemeten plots ingeladen 
# (data_processed = TRUE or FALSE is zelfde resultaat: geen records als er niks opgemeten is)

dendro_by_plot %>% filter(plot_id == 11000 & period == 1) %>% dplyr::pull(vol_log_m3_ha)
# NA ==> OK

deadw_by_decay_plot %>% filter(plot_id == 11000 & period == 1) %>% dplyr::pull(vol_log_m3_ha)
# [1] NA NA NA NA NA NA => OK
```

```{r eval = FALSE}
# check - OK
dendro_by_plot %>% filter(plot_id == 11000 & period == 1) %>% dplyr::pull(vol_log_m3_ha)
dendro_by_plot %>% filter(plot_id == 1620 & period == 2) %>% dplyr::pull(vol_deadw_m3_ha)
# OK

dendro_by_plot_species %>% filter(plot_id == 11000 & period == 1) %>% dplyr::pull(vol_log_m3_ha)
dendro_by_plot_species %>% filter(plot_id == 1620 & period == 2) %>% dplyr::pull(vol_deadw_m3_ha)

dendro_by_diam_plot %>% filter(plot_id == 11000 & period == 1) %>% dplyr::pull(vol_log_m3_ha)
dendro_by_diam_plot %>% filter(plot_id == 1620 & period == 2) %>% dplyr::pull(vol_log_m3_ha)

dendro_by_diam_plot_species %>% filter(plot_id == 11000 & period == 1) %>% dplyr::pull(vol_log_m3_ha)
dendro_by_diam_plot_species %>% filter(plot_id == 1620 & period == 2) %>% dplyr::pull(vol_log_m3_ha)

deadw_by_decay_plot %>% filter(plot_id == 11000 & period == 1) %>% dplyr::pull(vol_log_m3_ha)
deadw_by_decay_plot %>% filter(plot_id == 1620 & period == 2) %>% dplyr::pull(vol_log_m3_ha)
# OK

deadw_by_decay_plot_species %>% filter(plot_id == 11000 & period == 1) %>% dplyr::pull(vol_log_m3_ha)
deadw_by_decay_plot_species %>% filter(plot_id == 1620 & period == 2) %>% dplyr::pull(vol_log_m3_ha)

```


# Correctie Kersselaerspleyn liggend dood hout

Correctie op plot-niveau


Naam "forest_reserve" werd in moederdatabank aangepast: Kersselaerspleyn, Harras 
en Zwaenepoel werden vervangen door     

    - Zoniën KERN_1983: bevat KV en 11 CP's (voorheen "Kersselaerspleyn")     
    - Zoniën UITBR_1995: bevat de CP's die NIET in de oude/eerste kernvlakte van 1983 
    liggen (voorheen "Kersselaerspleyn")     
    - Zoniën HARRAS_1995: bevat KV en CP (voorheen "Harras" voor KV en "Zwaenepoel" voor CP's)    
    - Zoniën UITBR_2010: bevat enkel CP's (voorheen "Zwaenepoel", maar zonder deze die nu in "HARRAS_1995" liggen)
    

## Afwijkingen

- Zoniën KERN_1983 - CA - 1986 en 2000: 
** geen deadwood opgemeten

- Zoniën KERN_1983 & Zoniën KERN_1995 - CP - 2000:
** cijfers overgenomen uit monitoringrapport, zitten niet in fieldmap

- Zoniën KERN_1983 - CA - KV 2010 en 2020: 
** deadwood pas vanaf 40 cm 
** 51 intacte liggende dode bomen



## Logs in de CP's van Zoniën KERN_1983 & Zoniën UITBR_1995 - periode 1 (2000)

Zitten niet in fieldmap, maar er zijn wel gegevens uit het monitoringrapport, zie 
"CP_Kerss_logs_2000.xlsx" (C:/03_BR/1_DataVerwerkingBR/Data/Meetgegevens/logs_CPs_Kerss_2000)

Deze hier implementeren.

```{r load_deadw_Kerss_CP_1}
logs_Kerss_2000 <- read.xlsx(paste0(path_to_meetgegevens, "logs_CPs_Kerss_2000/CP_Kerss_logs_2000.xlsx")
                             ,sheetName = "logs_per_plot") %>% 
  select(plot_id, period, VOLUME_LOG_m3_ha)
names(logs_Kerss_2000)

logs_per_spec_Kerss_2000 <- read.xlsx(paste0(path_to_meetgegevens, "logs_CPs_Kerss_2000/CP_Kerss_logs_2000.xlsx")
                             ,sheetName = "logs_per_plot_species") %>% 
  select(plot_id, species, period, VOLUME_LOG_m3_ha)

```

```{r update_dendro_by_plot}
names(logs_Kerss_2000)
names(dendro_by_plot)
# bevat NA's voor liggend dood hout (Kerss 1eSET)

dendro_by_plot %>% left_join(plotinfo %>% select(plot_id, forest_reserve, plottype, period)) %>% filter(forest_reserve %in% c("Zoniën KERN_1983", "Zoniën UITBR_1995") & plottype == "CP" & period == 1) %>% nrow() == 53
# vol_log = 0, want hogerop reeds survey_deadw = TRUE gesteld

# info toevoegen CP's van Zoniën KERN_1983 & Zoniën UITBR_1995 - jaar 2000
dendro_by_plot_ <- dendro_by_plot %>% 
  left_join(logs_Kerss_2000) %>% 
  mutate(vol_log_m3_ha = ifelse(between(plot_id, 2000, 2070) & period == 1 
                                #forest_reserve %in% c("Zoniën KERN_1983", "Zoniën UITBR_1995") & plottype == "CP" 
                                , VOLUME_LOG_m3_ha
                                , vol_log_m3_ha)
         , vol_deadw_m3_ha = vol_log_m3_ha + vol_dead_standing_m3_ha) %>% 
  select(-VOLUME_LOG_m3_ha)

dendro_by_plot_ %>% filter(period == 1 & between(plot_id, 2000, 2070))
# OK

dendro_by_plot <- dendro_by_plot_
```


```{r update_dendro_by_plot_species}
names(logs_per_spec_Kerss_2000)
names(dendro_by_plot_species)
# bevat NA's voor liggend dood hout (Kerss 1eSET)

dendro_by_plot_species %>% left_join(plotinfo %>% select(plot_id, forest_reserve, plottype, period)) %>% filter(forest_reserve %in% c("Zoniën KERN_1983", "Zoniën UITBR_1995") & plottype == "CP" & period == 1) %>% head()
# vol_log = 0, want hogerop reeds survey_deadw = TRUE gesteld

# info toevoegen Kerss CPS 2000
dendro_by_plot_species_ <- dendro_by_plot_species %>% 
  left_join(logs_per_spec_Kerss_2000) %>% 
  # mutate(VOLUME_LOG_m3_ha = ifelse(is.na(VOLUME_LOG_m3_ha) & between(plot_id, 2000, 2070) & period == 1
  #                                  0, 
  #                                  VOLUME_LOG_m3_ha)) %>% 
  mutate(vol_log_m3_ha = ifelse(between(plot_id, 2000, 2070) & period == 1 
                                #forest_reserve %in% c("Zoniën KERN_1983", "Zoniën UITBR_1995") & plottype == "CP" 
                                , ifelse(is.na(VOLUME_LOG_m3_ha), 0, VOLUME_LOG_m3_ha)
                                , vol_log_m3_ha)
         , vol_deadw_m3_ha = vol_log_m3_ha + vol_dead_standing_m3_ha) %>% 
  select(-VOLUME_LOG_m3_ha)

dendro_by_plot_species_ %>% filter(period == 1 & between(plot_id, 2000, 2070))
# OK

dendro_by_plot_species <- dendro_by_plot_species_
```

Niet geweten hoeveel er in welke diameterklasse of afbraakklasse zit => daar alles op NA zetten

```{r update_dendro_by_diam_plot_species}
names(logs_per_spec_Kerss_2000)
names(dendro_by_diam_plot_species)
# bevat nullen voor liggend dood hout (Kerss 1eSET) want hogerop reeds survey_deadw = TRUE gesteld

dendro_by_diam_plot_species %>% left_join(plotinfo %>% select(plot_id, forest_reserve, plottype, period)) %>% filter(forest_reserve %in% c("Zoniën KERN_1983", "Zoniën UITBR_1995") & plottype == "CP" & period == 1) %>% head()
# vol_log = 0, want hogerop reeds survey_deadw = TRUE gesteld

# NA van maken
dendro_by_diam_plot_species_ <- dendro_by_diam_plot_species %>% 
  mutate(vol_log_m3_ha = ifelse(between(plot_id, 2000, 2070) & period == 1 
                                #forest_reserve == "Kersselaerspleyn" & plottype == "CP" 
                                , NA
                                , vol_log_m3_ha)
         , vol_deadw_m3_ha = vol_log_m3_ha + vol_dead_standing_m3_ha)

dendro_by_diam_plot_species_ %>% filter(period == 1 & between(plot_id, 2000, 2070)) %>% head()
# OK

dendro_by_diam_plot_species <- dendro_by_diam_plot_species_
```

```{r update_dendro_by_diam_plot}
names(dendro_by_diam_plot)
# bevat nullen voor liggend dood hout (Kerss 1eSET) want hogerop reeds survey_deadw = TRUE gesteld

dendro_by_diam_plot %>% left_join(plotinfo %>% select(plot_id, forest_reserve, plottype, period)) %>% filter(forest_reserve %in% c("Zoniën KERN_1983", "Zoniën UITBR_1995") & plottype == "CP" & period == 1) %>% head()
# vol_log = 0, want hogerop reeds survey_deadw = TRUE gesteld

# NA van maken
dendro_by_diam_plot_ <- dendro_by_diam_plot %>% 
  mutate(vol_log_m3_ha = ifelse(between(plot_id, 2000, 2070) & period == 1 
                                #forest_reserve %in% c("Zoniën KERN_1983", "Zoniën UITBR_1995") & plottype == "CP" 
                                , NA
                                , vol_log_m3_ha)
         , vol_deadw_m3_ha = vol_log_m3_ha + vol_dead_standing_m3_ha)

dendro_by_diam_plot_ %>% filter(period == 1 & between(plot_id, 2000, 2070)) %>% head()
# OK

dendro_by_diam_plot <- dendro_by_diam_plot_
```


```{r update_deadw_by_decay}
names(deadw_by_decay_plot)

deadw_by_decay_plot %>% 
  left_join(plotinfo %>% 
              select(plot_id, forest_reserve, plottype, period)) %>% 
  filter(forest_reserve %in% c("Zoniën KERN_1983", "Zoniën UITBR_1995") & 
           plottype == "CP" & period == 1) %>% 
  nrow()

# NA van maken
deadw_by_decay_plot_ <- deadw_by_decay_plot %>% 
  mutate(vol_log_m3_ha = ifelse(between(plot_id, 2000, 2070) & period == 1 
                                #forest_reserve %in% c("Zoniën KERN_1983", "Zoniën UITBR_1995") & plottype == "CP" 
                                , NA
                                , vol_log_m3_ha))

deadw_by_decay_plot_ %>% filter(period == 1 & between(plot_id, 2000, 2070)) %>% head()
# OK

deadw_by_decay_plot <- deadw_by_decay_plot_

```

```{r update_deadw_by_decay_species}
names(deadw_by_decay_plot_species)

deadw_by_decay_plot_species %>% 
  left_join(plotinfo %>% 
              select(plot_id, forest_reserve, plottype, period)) %>% 
  filter(forest_reserve %in% c("Zoniën KERN_1983", "Zoniën UITBR_1995") & 
           plottype == "CP" & period == 1) %>% 
  nrow()

# NA van maken
deadw_by_decay_plot_species_ <- deadw_by_decay_plot_species %>% 
  mutate(vol_log_m3_ha = ifelse(between(plot_id, 2000, 2070) & period == 1 
                                #forest_reserve %in% c("Zoniën KERN_1983", "Zoniën UITBR_1995") & plottype == "CP" 
                                , NA
                                , vol_log_m3_ha))

deadw_by_decay_plot_species_ %>% filter(period == 1 & between(plot_id, 2000, 2070)) %>% head()
# OK

deadw_by_decay_plot_species <- deadw_by_decay_plot_species_

```



## Logs in de KV van Zoniën KERN_1983 pas vanaf 40 cm opgemeten (2010 en 2020)

Geen opnames van logs in 1ste decade (survey_deadw = FALSE).
In 2de en 3de decade pas opgemeten vanaf 40 cm diameter.

DUS in de plot-level-resultaten 
- NA's bij (standaard) volume liggend dood hout
- extra veld `vol_log_m3_ha_min40cm` met volume vanaf 40 cm

*< dataverwerking 2012: "Deadwood: geen volopname van liggend dood hout: *
*daarvoor wordt verwezen naar de 11 cirkels die in KV gelegen zijn"*
==> Wat in de cijfers zit, zijn de liggende bomen met > 40 cm diameter (uit BE-kartering).
Idem dito voor 3e decade: in KV pas vanaf 40 cm (CP's vanaf 10 cm)


```{r check_logs_KV_Kerss}
check <- dendro_by_plot %>% 
  filter(plot_id == 11000)
```

```{r correctie_logs_KV_Kerss}
names(dendro_by_plot)
# "vol_log_m3_ha"           "vol_deadw_m3_ha" 

dendro_by_plot_ <- dendro_by_plot %>% 
  mutate(vol_log_m3_ha_min40cm = 
           ifelse(plot_id == 11000, vol_log_m3_ha, NA),
         vol_log_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_log_m3_ha),
         vol_deadw_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_deadw_m3_ha)
           )

dendro_by_plot_ %>% 
  filter(plot_id == 11000)

dendro_by_plot <- dendro_by_plot_

```

```{r}
# ook voor de andere plot-level-resultaten
      # dendro_by_plot_species = dendro_by_plot_species,
      # dendro_by_diam_plot = dendro_by_diam_plot,
      # dendro_by_diam_plot_species = dendro_by_diam_plot_species,

# spec
dendro_by_plot_species_ <- dendro_by_plot_species %>% 
  mutate(vol_log_m3_ha_min40cm = 
           ifelse(plot_id == 11000, vol_log_m3_ha, NA),
         vol_log_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_log_m3_ha),
         vol_deadw_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_deadw_m3_ha)
           )

dendro_by_plot_species_ %>% 
  filter(plot_id == 11000)

dendro_by_plot_species <- dendro_by_plot_species_

```

```{r}
# diam
dendro_by_diam_plot_ <- dendro_by_diam_plot %>% 
  mutate(vol_log_m3_ha_min40cm = 
           ifelse(plot_id == 11000, vol_log_m3_ha, NA),
         vol_log_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_log_m3_ha)
         # vol_deadw_m3_ha = 
         #   ifelse(plot_id == 11000, NA, vol_deadw_m3_ha)
           )

dendro_by_diam_plot_ %>% 
  filter(plot_id == 11000)

dendro_by_diam_plot <- dendro_by_diam_plot_

# diam - spec
dendro_by_diam_plot_species_ <- dendro_by_diam_plot_species %>% 
  mutate(vol_log_m3_ha_min40cm = 
           ifelse(plot_id == 11000, vol_log_m3_ha, NA),
         vol_log_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_log_m3_ha)
         # vol_deadw_m3_ha = 
         #   ifelse(plot_id == 11000, NA, vol_deadw_m3_ha)
           )

dendro_by_diam_plot_species_ %>% 
  filter(plot_id == 11000)

dendro_by_diam_plot_species <- dendro_by_diam_plot_species_
```

**OPGEPAST**: tabellen `dendro_by_diam_plot` en `dendro_by_diam_plot_species`: 
diam-klasses 10-15cm/15-20cm/20-25cm/25-30cm/…: `vol_log_m3_ha_min40cm = NA` ipv `0` 

We zouden kunnen opteren om `vol_log_m3_ha` aan te vullen voor de hogere diameterklasses, maar dat geeft enkel verwarring => DOEN WE NIET, alle diameterklasses blijven daar NA!

```{r correctie_logs_KV_Kerss2}
unique(dendro_by_diam_plot$dbh_class_5cm)

check <- dendro_by_diam_plot %>% 
  filter(plot_id == 11000 & year %in% c(2009, 2020))

table(check$dbh_class_5cm)

to_small <- c("5 - 10 cm", "10 - 15 cm", "15 - 20 cm", "20 - 25 cm", "25 - 30 cm", "30 - 35 cm", "35 - 40 cm")

dendro_by_diam_plot_ <- dendro_by_diam_plot %>% 
  mutate(vol_log_m3_ha_min40cm = ifelse(plot_id == 11000 & dbh_class_5cm %in% to_small,
                                        NA,
                                        vol_log_m3_ha_min40cm))

check2 <- dendro_by_diam_plot_ %>% 
  filter(plot_id == 11000 & year %in% c(2009, 2020) & dbh_class_5cm %in% to_small)

dendro_by_diam_plot <- dendro_by_diam_plot_

# idem voor xxxxx_species
dendro_by_diam_plot_species_ <- dendro_by_diam_plot_species %>% 
  mutate(vol_log_m3_ha_min40cm = ifelse(plot_id == 11000 & dbh_class_5cm %in% to_small,
                                        NA,
                                        vol_log_m3_ha_min40cm))

check2 <- dendro_by_diam_plot_species_ %>% 
  filter(plot_id == 11000 & year %in% c(2009, 2020) & dbh_class_5cm %in% to_small)

dendro_by_diam_plot_species <- dendro_by_diam_plot_species_

```


```{r}
names(deadw_by_decay_plot)
# ook voor de andere plot-level-resultaten
      # deadw_by_decay_plot = logs_by_decay_plot,
      # deadw_by_decay_plot_species = logs_by_decay_plot_species

# decay
deadw_by_decay_plot_ <- deadw_by_decay_plot %>% 
  mutate(vol_log_m3_ha_min40cm = 
           ifelse(plot_id == 11000, vol_log_m3_ha, NA),
         vol_log_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_log_m3_ha)
           )

deadw_by_decay_plot_ %>% 
  filter(plot_id == 11000)

deadw_by_decay_plot <- deadw_by_decay_plot_

# decay - spec
deadw_by_decay_plot_species_ <- deadw_by_decay_plot_species %>% 
  mutate(vol_log_m3_ha_min40cm = 
           ifelse(plot_id == 11000, vol_log_m3_ha, NA),
         vol_log_m3_ha = 
           ifelse(plot_id == 11000, NA, vol_log_m3_ha)
           )

deadw_by_decay_plot_species_ %>% 
  filter(plot_id == 11000)

deadw_by_decay_plot_species <- deadw_by_decay_plot_species_
```


# Vergelijking met oude data

```{r eval = FALSE}
# onderstaande code werkt nog niet, want nog geen data opgeladen
dendro_by_plot_git <- read_forresdat_table(tablename = "dendro_by_plot"
                                           , join_plotinfo = TRUE
                                           , plottype = "all"
                                           , git_ref_type = "branch"
                                           , git_reference = "develop")
# Error: table dendro_by_plot is not present in forresdat

qintact_snag_git <- read_forresdat_table(tablename = "qintact_snag"
                                           , join_plotinfo = FALSE
                                           # , plottype = "all"
                                           , git_ref_type = "branch"
                                           , git_reference = "develop")

# vgl
dendro_by_plot_git <- dendro_by_plot_git %>% 
  select(plot_id, year, everything()) %>% 
  select(names(dendro_by_plot))
nrow(dendro_by_plot) == nrow(dendro_by_plot_git)
summary(dendro_by_plot)
names(dendro_by_plot) == names(dendro_by_plot_git)
summary(dendro_by_plot_git)


dendro_by_plot %>% select(-year) %>% arrange(plot_id, period) == dendro_by_plot_git %>% select(-year) %>% arrange(plot_id, period)
# OK denk ik andere ordening van variabelen
dendro_by_plot == dendro_by_plot_git

head(dendro_by_plot %>% arrange(plot_id, period)); head(dendro_by_plot_git %>% arrange(plot_id, period))


dendro_by_plot_species_git <- read_forresdat_table(tablename = "dendro_by_plot_species"
                                           , join_plotinfo = TRUE
                                           , plottype = "all"
                                           , git_ref_type = "branch"
                                           , git_reference = "develop")
nrow(dendro_by_plot_species) == nrow(dendro_by_plot_species_git)

dendro_by_diam_plot_git <- read_forresdat_table(tablename = "dendro_by_diam_plot"
                                           , join_plotinfo = TRUE
                                           , plottype = "all"
                                           , git_ref_type = "branch"
                                           , git_reference = "develop")
nrow(dendro_by_diam_plot) == nrow(dendro_by_diam_plot_git)

logs_by_decay_plot_git <- read_forresdat_table(tablename = "logs_by_decay_plot"
                                           , join_plotinfo = TRUE
                                           , plottype = "all"
                                           , git_ref_type = "branch"
                                           , git_reference = "develop")
nrow(logs_by_decay_plot) == nrow(logs_by_decay_plot_git)

```

# Aanmaak list

```{r new_list_dendro}
# opnieuw list van maken om te exporteren en plotinfo aan te koppelen
dendro <- list(
      dendro_by_plot = dendro_by_plot,
      dendro_by_plot_species = dendro_by_plot_species,
      dendro_by_diam_plot = dendro_by_diam_plot,
      dendro_by_diam_plot_species = dendro_by_diam_plot_species,
      deadw_by_decay_plot = deadw_by_decay_plot,
      deadw_by_decay_plot_species = deadw_by_decay_plot_species
    )
```


# Plotinfo toevoegen (aan csv-files)

```{r join_plottype_surveynr_BR}
dendro_plotinfo <- lapply(dendro, function(x) left_join(x, plotinfo %>% select(plot_id, forest_reserve, period, survey_number), by = c("plot_id", "period")))
# lapply: same function over all elements of the list
```


# Export plot-level-data

**!!!! ENKEL PLOTS EXPORTEREN WAARVAN DATA PROCESSED ZIJN!!**
Is standaard parameter bij inladen dendro-data 

**DUS: zorgen dat dit veld in Fieldmap up-to-date is, zie chunck "plotinfo_processed"**


Enkele verduidelijkingen:

* "number_of_tree_species" = aantal soorten obv de levende bomen

* "stems_per_tree" = meerstammigheid (stem_number_ha / number_of_trees_ha): heeft hier geen zin, maar dient als insteek voor berekeningen per soort

* "vol_bole_alive_m3_ha" en "vol_bole_dead_m3_ha": volume zonder crown, 
versus "vol_alive_m3_ha" en "vol_dead_standing_m3_ha"

* "vol_log_m3_ha": liggend dood hout (NA als er geen deadwood survey gebeurd is)

* "vol_deadw_m3_ha": staand en liggend dood hout (NA als er geen deadwood survey gebeurd is)


```{r save_dendro_git, eval = FALSE}
# geen plotinfo naar git
save_results_forresdat(
  results = dendro,
  repo_path = path_to_git_forresdat,
  metadata_path = paste0(path_to_metadata, "_metadata_plotlevel_results_dendro.xlsx"),
  push = FALSE,
  strict = TRUE,
  branch = "develop"
)

```

```{r save_dendro_git_manueel, eval = FALSE}
# manueel - eigen simpele functie - als save_results_git niet werkt
save_results_tsv(dendro, 
                 root = path_to_forresdat_data, 
                 strict = FALSE)
```


```{r save_dendro_access_csv, eval = FALSE}
# hier wel plotinfo (plottype, BR, surveynr mee wegschrijven)

# volgende functie heb ik zelf geschreven, zit niet in het package!
save_results_csv (
    results = dendro_plotinfo,
    output_dir = path_to_plotlevel_csv
    )

# afgerond voor export naar access
round_df <- function(df, digits) {
  df[] <- lapply(df, function(x) if(is.numeric(x)) round(x, digits) else x)
  return(df)
}

dendro_round <- dendro_plotinfo %>% 
  lapply(., function(x) round_df(x, 2))

save_results_access (
  results = dendro_round,
  database = path_to_analysis_set_db,
  remove_tables = TRUE
  )

```

Direct naar gdrive exporteren (csv): 
naar **/PRJ_BOSECO_ALGEMEEN/PRJ_BR_AanvraagGegevens/00_METADATA-ALL_PLOTS/_plot-level-data/**

```{r save_dendro_gdrive, eval = FALSE}
save_results_csv(
    results = dendro_plotinfo,
    output_dir = path_to_plotlevel_gdrive
    )

```


**Na update van forresdat, project "forresdat" openen en alles naar de cloud pushen**
**Eventueel ook access op gdrive plaatsen**


# Copy html to teamdrive

Na knitting - manueel

```{r eval = FALSE}
# Specify the path of the file you want to copy
source_file <- here::here(paste0("Scripts/OpbouwDatabank/Main_UpdateForresdat_02_dendro.html"))

# Specify the destination directory where you want to copy the file
destination_dir <- path_to_html_teamdrive

# Copy the file to the destination directory
file.copy(from = source_file, to = destination_dir, overwrite = TRUE)
# ? file.copy
```
