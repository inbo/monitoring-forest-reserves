---
title: "Update forresdat"
author: "Anja Leyman"
date: "`r Sys.Date()`"
output: 
  html_document:
    keep_md: FALSE
    number_sections: yes
    fig_caption: yes
    code_folding: hide
    toc: TRUE
    toc_float:
      collapsed: yes
      smooth_scroll: yes
---


```{r Rm, eval = FALSE}
rm(list=ls())
```

```{r Setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  eval = FALSE,
  message = FALSE,
  warning = FALSE, 
  fig.width = 9,
  fig.align = TRUE)

library(here)

# libraries & invoergegevens
source(here::here("scripts/Setup.R"))
source(here::here("scripts/ExtraFunctions.R"))
source(here::here("scripts/ExtraFunctions_volume.R"))
```


# Vraagstelling

DOEL van dit script is een update van tree-wide, met inbegrip van de `tree_meuasure_id`'s per decade. 


```{r results='hold', eval=TRUE}
path_to_forresdat_data
path_to_analysis_set_db
path_to_plotlevel_csv
path_to_treelevel_csv
path_to_output_gdrive
```

# Load data

## Plotinfo

Plotinfo samenstellen, zijnde plottype, naam forest_reserve en info over survey en data al dan niet processed.
Wegschrijven naar git, access en opslaan als csv

```{r plotinfo_load}
plotinfo <- load_plotinfo(database = path_to_fieldmap_db)
names(plotinfo)
```


## Dendro data

```{r load_dendro1_processed_or_not}
data_dendro <- load_data_dendrometry(database = path_to_fieldmap_db, 
                                     extra_variables = TRUE, 
                                     processed = TRUE)
# 79866 + 2455 = 82321 (rodebos)
# 83171 (22/11/2022)


```


```{r load_dendro2}
data_shoots <- load_data_shoots(database = path_to_fieldmap_db, extra_variables = TRUE)

data_stems  <- compose_stem_data(data_dendro, data_shoots, extra_variables = TRUE)

height_model <- load_height_models(path_to_height_models)

```

```{r check_heightmodels}
table(height_model$forest_reserve, height_model$period)
table(plotinfo$forest_reserve)

height_model %>% group_by(forest_reserve) %>% summarise(n = n()) %>% ungroup() %>% anti_join(plotinfo, by = c("forest_reserve"))
# Rodebos	51	- OK, als algemeen voor beide KV's, niet gelinkt aan een feitelijke KV	
# Rodebos KV	56 - NIET OK!!! - AANGEPAST
# Walenbos	28	- OK, als algemeen voor beide KV's, niet gelinkt aan een feitelijke KV
```

KV Kerss 2000 pas vanaf 30 cm DBH

```{r}
data_stems_<- data_stems %>% 
  filter(plot_id != 11000 | 
           period %in% c(2,3) |
           dbh_mm >= 300)

check <- data_stems %>% 
  anti_join(data_stems_)
table(check$period, check$plot_id)   # ok
  #     11000
  # 1   913
data_stems <- data_stems_

data_dendro_ <- data_dendro %>% 
  filter(plot_id != 11000 | 
           period %in% c(2,3) |
           dbh_mm >= 300)
check <- data_dendro %>% 
  anti_join(data_dendro_)
table(check$period, check$plot_id)   # ok
  #     11000
  # 1   913
data_dendro <- data_dendro_

```


```{r}
check_Kerss <- data_stems %>% 
  filter(plot_id == 11000 & period == 1)
min(check_Kerss$dbh_mm) # 300
```


# Calculate dendro data

```{r calc_dendro}
data_stems_calc <- calc_variables_stem_level(data_stems, height_model)

data_dendro_calc <- calc_variables_tree_level(data_dendro, data_stems_calc)

```


## Check NA's (tree-level)

Niet alle NA's moeten door een 0 vervangen worden.
Een NA wijst vaak op een missing value in FM => dat eerst oplossen

> OPGEPAST
> Als in trees layer het veld `ind_sht_cop` = coppice (12)
én de  shoot zit toch niet in de shoots layer
dan wordt een fout gecreëerd in forrescalc (met NA voor volume als gevolg)
DUS BEST MEENEMEN IN DATACONTROLE

> OOK AANDACHT VOOR MISSING DBH OF HEIGHT VAN SNAGS !!!

```{r check_NA1, eval = FALSE}
col <- c("dbh_mm", "species", "dbh_class_5cm", "calc_height_m", "vol_crown_m3",
         "vol_bole_m3", "vol_tot_m3", "stem_number_alive_ha", "stem_number_dead_ha",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha",
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha",
         "intact_snag", "alive_dead", "ind_sht_cop")
nrow(data_stems_calc  %>%
       filter_at(col, any_vars(is.na(.)))) == 0

col <- c("dbh_mm", "species", "dbh_class_5cm", "calc_height_m",
         "basal_area_m2", "vol_bole_m3", "vol_crown_m3", "vol_tot_m3",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha",
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha",
         "number_of_trees_alive_ha", "number_of_trees_dead_ha")

nrow(data_dendro_calc  %>%
       filter_at(col, any_vars(is.na(.)))) == 0

```

# Create unique tree-id - 8/4/2022 laatste keer gerund

(bevat nog niet Rodebos 3de decade - sowieso niet in detail gecheckt voor KV's)

`Data_dendro_calc` bevat een unieke `tree_id` per boom (die constant blijft doorheen de tijd),
verschillend van de `tree_measure_id` uit fieldmap, die wel varieert doorheen de tijd.

Deze `tree_id` wordt in het package aangemaakt obv old_id.

**OPGEPAST**
Bij hakhout kan/kon dit soms tot gemiste linken leiden. 
(zie ook "TreeMortalityData_DetailHakhout.Rmd")

Hakhoutstoven worden opgesplitst in een levend en dood deel, 
en elk deel wordt dan als een afzonderlijke boom beschouwd 
(een boom kan immers niet én levend én dood tegelijk zijn)

OldID wordt standaard toegekend aan het levende deel van de hakhoutstoof.
Het dode deel wordt gelinkt via CoppiceID.
Indien er enkel een dood deel is (en geen levend deel), dan wordt daar OldID aan toegekend.

Dat wil zeggen dat er zich enkel een probleem stelt wanneer er in één van de 
twee periodes zowel een levend als een dood deel voorkomt.
In de andere gevallen is de koppeling die gebeurt via OldID correct.

**OPLOSSING**
Daarom wordt in code hierna voor hakhout dat in één van de 
twee periodes uit zowel een levend als een dood deel bestaat, de tree_id bepaald obv coppice_id.

Voor de 11 verwerkte CP's + KV Muizenbos is die koppeling gecheckt en OK bevonden.

Dit houdt in dat tree_id niet meer uniek is per periode.
Dat geeft dan weer problemen wanneer we er een "wijde" tabel van willen maken.

Daarom wordt er een _a of _b toegevoegd, afh. of het om levend of dood deel van een hakhoutstoof gaat.
Indien we toch één ID per hakhout willen, ongeacht levend/dood, dan kunnen we makkelijk de _a en _b verwijderen (= `tree_id_non_unique`).


## Op boomniveau - obv old-id

De branch `statistics_and_other_issues` heeft een manier gevonden om tree-id te berekenen, ook voor 4 decades. 

```{r mbv_oldid_obv_package}
tree_id <- create_unique_tree_id(data_dendro = data_dendro_calc)
# Deze tabel wordt NIET bewaard in forresdat (daar enkel geaggregeerde resultaten op plotniveau)

# check
tree_id %>% filter(is.na(tree_id)) %>% nrow()
tree_id_missing <- tree_id %>% filter(is.na(tree_id))
table(tree_id_missing$forest_reserve, tree_id_missing$period)

# selectie om wijde tabel aan te maken
tree_id_long <- tree_id %>%
  select(plot_id, species, tree_id, period, tree_measure_id, dbh_mm, vol_tot_m3, alive_dead)

```


### Op boomniveau - obv coppice-id

**EVENTUEEL EXTRA TOEVOEGEN**  
> 21/2/2022: link obv coppice-id, want dat wordt veel gevraagd.
> Zie ook `Euforia_TreePlotData_Flanders_Olalla_2022-01-13.Rmd`.

Uitsplitsen van hakhoutstoven in dood en levend deel is nodig, want een "tree" kan niet zowel levend als dood zijn.
Bovendien kan een `oldID` niet aan twee "trees" toegekend worden, omdat er anders problemen ontstaan met de koppeling die gebaseerd is op OldID (moet een één-op-één relatie zijn tussen de 2 periodes).

In de databank wordt OldID standaard toegekend aan het levende deel van de hakhoutstoof.   
Het dode deel wordt gelinkt via CoppiceID.   
Indien er enkel een dood deel is (en geen levend deel), dan wordt daar OldID aan toegekend.   

Dus bij de hakhoutstoven die (in eenzelfde periode) uit een levend en dood deel bestaan, hebben de twee delen niet dezelfde oldID, maar wel dezelfde coppice_id.    

Dat wil zeggen dat er zich enkel een probleem stelt wanneer er in één van de twee periodes zowel een levend als een dood deel voorkomt.   
In de andere gevallen kan de koppeling gebeuren via OldID.   

Zo werken we dan ook:  

- 2 delen: koppeling via OldID
- 3 of 4 delen: koppeling via CoppiceID  

In kader van het TreeMortality project hebben we nog een extra onderscheid gemaakt tss levend en dood deel van een hakhoutstoof, door _a en _b toe te voegen voor resp. levend of dood deel van een stoof.
Dat was toen nodig omdat we extra records "fallen" toe moesten voegen voor het dood hout dat er niet meer was.

Dat is ook nodig wanneer we er ooit een "wijde" tabel van willen maken.

Het is echter niet zeker dat dat een correcte link is, want beide delen lopen als het ware in elkaar over. 
Bv. - periode 1 levend gekoppeld aan periode 2 levend
    - periode 1 dood gekoppeld aan periode 2 dood
--> mogelijks zijn er van de levende wat extra dood gegaan, en van de dode wat omgevallen (fallen)
maar dat is niet te bepalen (kan vergeleken worden met dode takken in een boom)
(zie ook `TreeMortalityData_DetailHakhout.Rmd`)

Indien we een correcte link willen, moeten we _a en _b terug verwijderen, met als gevolg dat tree-id géén uniek veld meer is.

> !! controle van die coppice_id nodig obv aantal soorten en afwijking van XY
> reeds gedaan voor de 11 CP's in forresdat op 16/2/2022

__Werkwijze:__

* bepalen hoeveel delen er per hakhoutstoof aanwezig zijn

* data opsplitsen:
    (1) een deel waarbij link via OldID behouden blijft (= treeid): **_data_OldID_**
    (individuele bomen en coppice dat uit max. één deel bestaat per periode)
    (2) een deel waarbij link via CoppiceID gecreëerd wordt (= nieuwe tree_id): **_data_CoppID_**
    (coppice met ergens een periode met 2 delen)
 
* in data_CoppID de treeid vervangen door period_plotid_coppiceID_a indien levend 
en period_plotid_coppiceID_b indien dood

* samenvoegen van data_OldID, data_CoppID

--
Vanaf 3 decades wordt het moeilijker.
Dan zouden we moeten kijken of er max. één per decade is, dan obv old_id
Zodra er meer dan één per decade is, dan moeten we werken met coppice_id voor allemaal en dan onderscheid tss levend en dood mbv suffix "a" en "b". 


```{r NumberOfPartsPerCoppicePerDecade}
tree_id %>% filter(coppice_id > 0) %>% nrow()
# [1] 17224 - 18015

# coppice_id en plot_id samen uniek => hoeveel metingen zijn er per stoof en per decade (max.2 - klopt)
summ_coppice_id <- tree_id %>% 
  filter(coppice_id > 0) %>%
  group_by(coppice_id, plot_id, period) %>% 
  summarise(aantal = n()) %>% 
  ungroup()
# 16138

table(summ_coppice_id$aantal)
#     1     2 
# 14261  1877

summ_coppice_id %>% filter(aantal > 2) %>% distinct(plot_id)

summ_coppice_id %>% filter(aantal > 2)

# vb van 3 decades
tree_id %>%  filter(coppice_id == 32 & plot_id == 31000) %>% 
  select(period, tree_measure_id, species, alive_dead, nr_of_stems, x_local, y_local, tree_id, coppice_id)


# summ_coppice_id
summ_coppice_id_def <- summ_coppice_id %>% 
  group_by(coppice_id, plot_id) %>% 
  summarise(max_aantal = max(aantal)) %>% 
  ungroup()
# 9690
```

```{r SplitDataTrees_OldID_CoppID}
tree_id_  <- tree_id %>% 
  left_join(summ_coppice_id_def, by = c("plot_id","coppice_id")) %>% 
  rename(max_nr_parts_coppice = max_aantal) 

str(tree_id_)
str(summ_coppice_id_def)

# tree_data via OldID
tree_data_OldID <- tree_id_ %>% 
  filter(ind_sht_cop != 12 | max_nr_parts_coppice < 2 | is.na(coppice_id))

# tree_data via coppice ID
tree_data_CoppID <- tree_id_ %>% 
  filter(max_nr_parts_coppice > 1)

nrow(tree_data_OldID) + nrow(tree_data_CoppID) - nrow(tree_id) == 0
# [1] 0

```

Daar waar coppice in één van de (twee of drie) decades uit meer dan twee delen bestaat, `tree_id` vervangen door een id obv `coppice_id`.

```{r CreateNewTreeID_TreeData_CoppID}
tree_data_CoppID_ <- tree_data_CoppID %>% 
  rename (treeid_old = tree_id) %>% 
  mutate (tree_id = paste(1, plot_id, coppice_id, sep = "_")) %>%
  mutate (tree_id = ifelse(alive_dead == 11, paste(tree_id, "a", sep = "_"),
                          ifelse(alive_dead == 12, paste(tree_id, "b", sep = "_"),
                                 NA)))

names(tree_data_CoppID_)

check_coppID <- tree_data_CoppID_ %>% 
  select(plot_id, 
         tree_id, tree_measure_id, coppice_id,
         max_nr_parts_coppice,
         x_local, y_local, 
         period, 
         species, 
         alive_dead, intact_snag, ind_sht_cop, decaystage,
         dbh_mm, height_m, calc_height_m, vol_tot_m3
         ) 

tree_data_CoppID <- tree_data_CoppID_
```


```{r Controle_TreeData_OldID}
# str(tree_data_OldID)
nrow(tree_data_OldID)
# [1] 36615
# [1] 75907 - 77402
# summary(tree_data_OldID)

```


```{r Controle_TreeData_CoppID}
# str(tree_data_CoppID)
nrow(tree_data_CoppID)
# [1] 2038
# [1] 3959 - 4892
# summary(tree_data_CoppID)

table(tree_data_CoppID$max_nr_parts_coppice)
#    2 
# 4892 

tree_data_CoppID_check <- tree_data_CoppID_ %>% 
  mutate(tree_id_non_unique = ifelse(max_nr_parts_coppice < 2, tree_id,
                                 str_sub(tree_id, 1, -3)),
         test = (tree_id_non_unique == tree_id)) %>% 
  select(plot_id, 
         tree_id, tree_measure_id, coppice_id, old_id,
         tree_id_non_unique, test,
         max_nr_parts_coppice,
         x_local, y_local, 
         period, 
         species, 
         alive_dead, intact_snag, ind_sht_cop, decaystage,
         dbh_mm, height_m, calc_height_m, vol_tot_m3
         )
  

# 5 => !! 3 periodes opgemeten  (Hannecart, Rodebos) - ?? Harras?

# !! Kerss en Zwaenepoel en Harras (3 decades): heel weinig coppice => daarom nu nog zo geen probleem
# maar het kan wel dat er nu hakhout is dat er al 3 decades staat (bv. 3x levend), dat via coppice_id gekoppeld wordt ipv via oldID, maar dat is geen probleem
# Beter in die richting een afwijking dan andersom

```

Zijn er geen foute linken obv coppice_id? 

```{r check_XY}
# checken obv XY

verschil_XY_coppiceid <- tree_data_CoppID_check %>% 
  group_by(plot_id, tree_id_non_unique, coppice_id) %>% 
  summarize(aantal_records = n(),
            aantal_soorten = n_distinct(species),
            aantal_statussen = n_distinct(alive_dead),
            x1 = first(x_local), 
            x_mean = mean(x_local),
            y1 = first(y_local),
            y_mean = mean(y_local)) %>% 
  ungroup() %>% 
  mutate(verschilX = abs(x1 - x_mean),
         verschily = abs(y1 - y_mean)
  ) %>% 
  filter(verschilX > 0.99 | verschily > 0.99)
  # filter(verschilX > 0.2 | verschily > 0.2)
  
nrow(verschil_XY_coppiceid)
# 25 - 43
# 20 (1m)

verschil_XY_coppiceid_detail <- tree_data_CoppID_check %>% 
  select(plot_id, tree_id,
         tree_id_non_unique, tree_measure_id, 
         coppice_id, old_id,
         x_local, y_local, 
         period, 
         species, 
         alive_dead, intact_snag, ind_sht_cop, decaystage,
         dbh_mm, height_m, calc_height_m, vol_tot_m3
         ) %>% 
  inner_join(verschil_XY_coppiceid, by = c("plot_id", "tree_id_non_unique", "coppice_id")) %>% 
  filter(aantal_soorten < 2) %>%  # deze apart checken zodat er geen overlap is
  select(-decaystage, -height_m, -tree_id_non_unique, 
         -vol_tot_m3, -calc_height_m, -contains("aantal"))
  
names(verschil_XY_coppiceid_detail)
#   pivot_wider(names_from = tree_id, values_from = x_local) 
# 
# %>% 
#   rename(individual = "10", coppice = "12") %>% 
#   mutate(perc_hakhout = round(100*coppice/(individual + coppice), ))

```

```{r check_meerdere_soorten}
verschillende_soorten_coppiceid <- tree_data_CoppID_check %>% 
  group_by(plot_id, tree_id_non_unique, coppice_id) %>% 
  summarize(aantal_records = n(),
            aantal_soorten = n_distinct(species),
            aantal_statussen = n_distinct(alive_dead),
            x1 = first(x_local), 
            x_mean = mean(x_local),
            y1 = first(y_local),
            y_mean = mean(y_local)) %>% 
  ungroup() %>% 
  mutate(verschilX = abs(x1 - x_mean),
         verschily = abs(y1 - y_mean)
  ) %>% 
  filter(aantal_soorten > 1)

# verschillende soorten
meerdere_soorten_zelfde_coppice_id <- tree_data_CoppID_check %>% 
  # select(-x_local, -y_local) %>% 
  inner_join(verschillende_soorten_coppiceid,
             by = c("plot_id", "tree_id_non_unique", "coppice_id")) %>% 
  select(plot_id, 
         tree_id, tree_id_non_unique, tree_measure_id, 
         coppice_id, old_id,
         x_local, y_local, 
         period, 
         species, 
         alive_dead, intact_snag, ind_sht_cop, decaystage,
         dbh_mm, height_m, calc_height_m, vol_tot_m3
         ) %>% 
  select(-decaystage, -height_m, -tree_id_non_unique, -vol_tot_m3, -calc_height_m)

meerdere_soorten_zelfde_coppice_id %>% distinct(plot_id)

```


```{r te_controleren_door_Peter, eval=FALSE}
# write_csv2(meerdere_soorten_zelfde_coppice_id, "Data_controle/nalv_Euforia_2022-02-15/meerdere_soorten_zelfde_coppice_id.csv")
# 
# write_csv2(verschil_XY_coppiceid_detail, "Data_controle/nalv_Euforia_2022-02-15/verschil_XY_coppiceid_detail.csv") 
# 
# # OK, verzonden op 15/2/2022 naar Peter !! enkel data voor Euforia, niet van KV's of 2109 of 723 of 
# # (enkel processed én 2x opgemeten)
# 
# 
# write_csv2(meerdere_soorten_zelfde_coppice_id, "Data_controle/meerdere_soorten_zelfde_coppice_id2.csv")
# # OK, opgelost!!
# 
# write_csv2(verschil_XY_coppiceid_detail, "Data_controle/verschil_XY_coppiceid_detail2.csv") 
# # OK, verzonden op 21/2/2022 naar Peter !! gezegd dat dat geen haast had
# # Bevat ook de niet processed data
# 

write_csv2(meerdere_soorten_zelfde_coppice_id, "Data_controle/meerdere_soorten_zelfde_coppice_id3.csv")

write_csv2(verschil_XY_coppiceid_detail, "Data_controle/verschil_XY_coppiceid_detail3.csv") 
# OK, verzonden op 18/4/2022 naar Peter !! gezegd dat dat geen haast had

```

```{r rbind_tree_data_OldID_CoppID}
tree_data_CoppID <- tree_data_CoppID %>% 
  select(-treeid_old)

tree_data_all <- rbind(tree_data_OldID, tree_data_CoppID)

nrow(tree_data_all) == nrow(tree_id)
names(tree_data_all)
names(tree_id)

# check_a_b <- tree_data_all %>% 
#   select(plot_id, 
#          tree_id, tree_measure_id, coppice_id,
#          nr_parts_coppice,
#          x_local, y_local, 
#          period, 
#          species, 
#          alive_dead, intact_snag, ind_sht_cop, decaystage,
#          dbh_mm, height_m, calc_height_m, vol_tot_m3
#          ) %>% 
#   filter(nr_parts_coppice > 2)

tree_id_ <- tree_data_all %>% 
  mutate(tree_id_non_unique = ifelse(max_nr_parts_coppice < 2 | is.na(max_nr_parts_coppice), tree_id,
                                 str_sub(tree_id, 1, -3)),
         test = (tree_id_non_unique == tree_id))
# %>%
#   select(plot_id,
#          tree_id, tree_measure_id,
#          coppice_id, old_id,
#          tree_id_non_unique, test,
#          max_nr_parts_coppice,
#          x_local, y_local,
#          period,
#          species,
#          alive_dead, intact_snag, ind_sht_cop, decaystage,
#          dbh_mm, height_m, calc_height_m, vol_tot_m3
#          )

tree_id <- tree_id_ %>% 
  select(-test, -max_nr_parts_coppice)

names(tree_id)
```


### Op spilniveau

!! OPGEPAST !! 

Tree-id wordt overgenomen van boomniveau, aangemaakt via `old_id` of `coppice_id` afhankelijk van "delen" hakhout (zie hoger).

```{r copy_tree_id}
names(data_stems_calc)
names(tree_id)

tree_id_ <- tree_id %>% 
  select(plot_id, tree_measure_id, tree_id, tree_id_non_unique, period)
# tree_id_ <- tree_id %>% 
#   select(plot_id, tree_measure_id, tree_id, period)

stem_id <- data_stems_calc %>% 
  filter(tree_measure_id != 0) %>% 
  left_join(tree_id_, by = c("plot_id", "tree_measure_id", "period"))

names(stem_id)
```

```{r check_id_hakhout, eval=FALSE}
stem_id %>% filter(is.na(tree_id)) %>% nrow()
# 0
stem_id %>% filter(is.na(tree_id)) %>% select(plot_id, period)


tree_id_hakhout <- stem_id %>% 
  group_by(plot_id, tree_measure_id, period) %>% 
  summarize(aantal = n()) %>% 
  ungroup()

table(tree_id_hakhout$aantal)
```


## Op boomniveau: wijde tabel met één record per boom doorheen de tijd

```{r tree_id_long}
# selectie om wijde tabel aan te maken
tree_id_long <- tree_id %>%
  select(plot_id, period, tree_id, 
         species, ind_sht_cop,
         dbh_mm, vol_tot_m3, alive_dead) %>% 
  arrange(period) %>% 
  left_join(plotinfo %>% select(plot_id, period, survey_number)) %>% 
  select(-period)

# ? survey_number => joinen met plotinfo
```

Om één record per boom te verkrijgen met info uit beide periodes, dient functie "make_table_wide" gebruikt te worden.
Dit werkt enkel bij een unieke tree_id.

!!Opgepast: soms daalt dbh doorheen de tijd: dat is het geval bij dode bomen.

```{r tree_id_wide_check}
check_dubbele_tree_id <- tree_id %>% 
  group_by(plot_id, tree_id, period) %>% 
  summarize(aantal_per_periode = n()) %>% 
  ungroup() %>% 
  filter(aantal_per_periode > 1) %>% 
  inner_join(tree_data_CoppID_check)

check_dubbele_tree_id
# A tibble: 3 x 4
#   plot_id tree_id       period aantal_per_periode
#     <int> <chr>          <dbl>              <int>
# 1   41000 1_41000_164_a      2                  2
# 2   51000 1_51000_4_a        1                  2
# 3   53000 1_53000_258_b      1                  2

check_dubbele_tree_id %>% distinct(plot_id)

# anti_join met deze die al gecheckt worden obv andere X en/of Y
check_dubbele_tree_id_ <- check_dubbele_tree_id %>% 
  anti_join(verschil_XY_coppiceid_detail %>%  select(plot_id, tree_id)) %>% 
  anti_join(meerdere_soorten_zelfde_coppice_id %>%  select(plot_id, tree_id))

# twee stoven met verschillend afbraakstadium !! afbraak wordt ingevuld op niveau van stems

```

```{r te_controleren_door_Peter2, eval=FALSE}
# write_csv2(check_dubbele_tree_id, "Data_controle/nalv_Euforia_2022-02-15/hakhout_verschillende_id_zelfde_status_levend_dood.csv")

write_csv2(check_dubbele_tree_id_, "Data_controle/hakhout_verschillende_id_zelfde_status_levend_dood3.csv") 
```

```{r tree_id_wide}
# TIJDELIJK
tree_id_long_ <- tree_id_long %>% 
  anti_join(check_dubbele_tree_id %>%  select(plot_id, tree_id))  # tijdelijk de dubbele tree_id's verwijderen

tree_id_long <- tree_id_long_

tree_id_wide <- make_table_wide(table_long = tree_id_long,
                                    column_to_repeat = "survey_number",
                                    columns_for_comparison = c("alive_dead", "dbh_mm", "vol_tot_m3"))

names(tree_id_wide)
```



## Export tree level data

Met unieke en non-unieke (voor hakhout) tree-id én berekende variabelen.
Enkel processed data.

Niet alle variabelen mee exporteren, enkel deze relevant voor de meeste gebruikers.

Enkele verduidelijkingen:

* plotarea_ha = de oppervlakte van resp. A3 of A4, afh. van status en diameter van de boom
(of LxB voor kernvlaktes of volledig BR voor andere plottypes) dus NIET de volledige cirkel


```{r trees_less_variables}
names(tree_id)

tree_id_less_var <- tree_id %>% 
  select(-old_id, -r_A1, -r_A2, -r_A3, -r_A4, -contains(c("dbh_min", "core_area_")), -subcirclearea_ha)

tree_id_less_var <- tree_id_less_var %>% 
  select(forest_reserve, plot_id, plottype, 
         period, 
         tree_measure_id, tree_id, tree_id_non_unique, coppice_id, 
         x_local, y_local, 
         species, 
         dbh_mm, height_m, calc_height_m, 
         alive_dead, ind_sht_cop, intact_snag, 
         iufro_hght, iufro_vital, iufro_socia, 
         decaystage, crown_volume_reduction, branch_length_reduction, 
         remark, common_remark, 
         year, date_dendro, 
         subcircle, plotarea_ha, totalplotarea_ha, 
         dbh_class_5cm, 
         nr_of_stems, 
         basal_area_m2, 
         vol_bole_m3, vol_crown_m3, vol_tot_m3, 
         basal_area_alive_m2_ha, basal_area_dead_m2_ha, 
         vol_alive_m3_ha, vol_dead_standing_m3_ha, 
         vol_bole_alive_m3_ha, vol_bole_dead_m3_ha, 
         number_of_trees_alive_ha, number_of_trees_dead_ha
         )

```


```{r save_trees, eval = FALSE}
# volgende functies heb ik zelf geschreven, zitten niet in het package!!!
save_results_csv (
    results = list(trees_calc = tree_id_less_var),
    output_dir = paste0(path_to_output, "raw-data/")
    )

# afgerond voor export naar access
tree_id_round <- tree_id_less_var %>% 
  mutate(round_df(., 4))

# save_results_access (
#   results = list(trees_calc = data_dendro_calc_round),
#   database = path_to_analysis_set_db,
#   remove_tables = TRUE
#   )

# Functie "save_results_access" (< package) geeft problemen met dates => hierna manueel

con <- odbcConnectAccess2007(path_to_analysis_set_db)

dbtables <- sqlTables(con)
if ("trees_calc" %in% dbtables$TABLE_NAME) {
        sqlDrop(con, "trees_calc")
      }
sqlSave(con, dat = tree_id_round, tablename = "trees_calc", varTypes = c(date_dendro="datetime"))

odbcClose(con)
```


```{r save_trees_wide, eval = FALSE}
# volgende functies heb ik zelf geschreven, zitten niet in het package!!!
save_results_csv (
    results = list(trees_wide = tree_id_wide),
    output_dir = paste0(path_to_output, "raw-data/")
    )

# afgerond voor export naar access
tree_id_wide_round <- tree_id_wide %>% 
  mutate(round_df(., 4))

save_results_access (
  results = list(trees_wide = tree_id_wide_round),
  database = path_to_analysis_set_db,
  remove_tables = TRUE
  )

```


## Export stem level data

Met unieke en non-unieke (voor hakhout) tree-id (uniek op boomniveau, niet op spilniveau) én berekende variabelen.

**!! OPGEPAST !!**
Unieke en non-unieke (voor hakhout) tree-id overgenomen van trees berekend op boomniveau.

<!--  na 16/2/2022: voor hakhout met meer dan twee delen: tree-id obv coppice-id (zie hoger) -->

Niet alle variabelen mee exporteren, enkel deze relevant voor de meeste gebruikers

```{r stems_less_variables}
stem_id_less_var <- stem_id %>% 
  select(-old_id, -r_A1, -r_A2, -r_A3, -r_A4, -contains(c("dbh_min", "core_area_")), -subcirclearea_ha)
## stemnumber_alive werd weggefilterd

stem_id_less_var <- stem_id_less_var %>% 
  select(forest_reserve, plot_id, plottype, 
         period, 
         tree_measure_id, shoot_measure_id, 
         tree_id, tree_id_non_unique, coppice_id, 
         x_local, y_local, 
         species, 
         dbh_mm, height_m, calc_height_m, 
         alive_dead, ind_sht_cop, intact_snag, 
         iufro_hght, iufro_vital, iufro_socia, 
         decaystage, crown_volume_reduction, branch_length_reduction, 
         remark, common_remark, 
         year, date_dendro, 
         subcircle, plotarea_ha, totalplotarea_ha, 
         dbh_class_5cm, 
         basal_area_m2, 
         vol_bole_m3, vol_crown_m3, vol_tot_m3, 
         basal_area_alive_m2_ha, basal_area_dead_m2_ha, 
         vol_alive_m3_ha, vol_dead_standing_m3_ha, 
         vol_bole_alive_m3_ha, vol_bole_dead_m3_ha, 
         stem_number_dead_ha, stem_number_alive_ha
         )

```


```{r save_stems, eval = FALSE}
# volgende functies heb ik zelf geschreven, zitten niet in het package!!!
save_results_csv (
    results = list(stems_calc = stem_id_less_var),
    output_dir = paste0(path_to_output, "raw-data/")
    )

# afgerond voor export naar access
stem_id_round <- stem_id_less_var %>% 
  mutate(round_df(., 4))

# save_results_access (
#   results = list(trees_calc = data_dendro_calc_round),
#   database = path_to_analysis_set_db,
#   remove_tables = TRUE
#   )

# Functie "save_results_access" (< package) geeft problemen met dates => hierna manueel

con <- odbcConnectAccess2007(path_to_analysis_set_db)

dbtables <- sqlTables(con)
if ("stems_calc" %in% dbtables$TABLE_NAME) {
        sqlDrop(con, "stems_calc")
      }
sqlSave(con, dat = stem_id_round, tablename = "stems_calc", varTypes = c(date_dendro="datetime"))

odbcClose(con)
```



# Regeneration - OK - 8/4/2022

## Load regeneration

```{r load_reg}
data_regeneration <-
  load_data_regeneration(
    database = path_to_fieldmap_db,
    processed = TRUE
  )

```

## Opbouw data_regeneration: aantalsklasse vs exact aantal (A1 vs A2)

Het `aantal` zou steeds een aantalsklasse moeten zijn bij seedlings (subcircle = A1) 
en een exact aantal bij established(subcircle = A1) 
=> aanpassen bij datacontrole en voorlopig ook hier in script

Want als allebei ingevuld zijn, dan wordt in package de aantalsklasse genomen
terwijl dat enkel zou mogen bij de seedlings (A1).
Package maakt geen onderscheid tss A1 en A2 voor de berekeningen, ervan uitgaande dat 
alles perfect ingevuld is.
(gebeurt via min_, max_ en approx_ obv de aantalsklasse, enkel als die niet ingevuld zijn, 
wordt exact aantal genomen)

-----
**Aan Els het volgende gevraagd (issue # 106):**
Bij de standaard methodiek is het inderdaad zo dat bij A1-verjonging gewerkt wordt met aantalsklasses en bij A2-verjonging (de iets grotere) met exacte aantallen.
Het is goed om het package in die zin op te bouwen.
MAAR er zijn ook bosreservaten waar de standaard methodiek niet gevolgd werd (bv. Everzwijnbad)
Dat zijn geen fouten, maar gewoon iets ander afspraken toendertijd.

Daarom lijkt het me het meest practische om bij A1-verjonging steeds te vertrekken van de aantalsklasse (NumberClass), maar als die niet ingevuld staat de info uit het exacte aantal (Number) te halen.
En vice versa bij de A2-verjonging.

Want nu is dat ook iets dat ik buiten het package om aanpas ...

Idem dito wanneer er een percentage berekend wordt van rubbing damage: erop letten om ook dan het goede "aantal" te nemen.

----

PRAGMATISCH
soms allebei
soms één van beide, terwijl het de andere zou moeten zijn
==> voor A1, steeds correct, want klasse wordt genomen 
En als klasse NA is, dan wordt exact aantal genomen, wat ook OK is!
==> A2: klasse wordt genomen, ook wanneer er toch een exact aantal ingevuld staat
==> CORRECTIE 1: als A2 én nr_of_regeneration is niet NA,
                dan number_class leegmaken
==> CORRECTIE 2: wegens aanmaak plot-level rubbing_dammage: als aantal NA, dan midwaarde number_class nemen


-----

Velden `data_regeneration`:  

- number_class: 1 tem 1001 (LU-list)
(1, 2-5, 6-10, 11-20, 21-40, 41-60,61-100, >100, >1000 --> 1,3,8,15,30,50,80,101,1001)
- nr_of_regeneration: exact aantal
- rubbing_damage_number
- rubbing_damage_perc: *moet nog aangevuld worden met percentage obv aantalsklassse,*
*nu enkel maar berekend voor exacte aantallen (gevraagd in issue #102)*
- approx_nr_regeneration: mid-waarde cfr Kris van interval
- min_number_of_regeneration: exacte waarde OF min-waarde interval
- max_number_of_regeneration: exacte waarde OF max-waarde interval

- subcircle: A1 of A2: seedlings vs established
- subcirclearea_ha: enkel berekend bij CP's (als r_A12 bestaat); NA bij KV's
- plotarea_ha: 
* CP's: steeds gelijk aan subcirclearea_ha
* KV's: (1) length_core_area_m * width_core_area_m OF 
(2) core_area_ha < Area_ha uit Plotdetails OF 
(3) totalplotarea_ha < Area_ha of Area_m2 uit layer Plots
(als (1) niet kan, dan (2) en dan pas (3))


```{r exactnr_vs_class}
names(data_regeneration)

data_regeneration %>% filter(!is.na(nr_of_regeneration) & !is.na(number_class)) %>% nrow()
# 1211 van de 33000
test <- data_regeneration %>% filter(!is.na(nr_of_regeneration) & !is.na(number_class))
table(test$subcircle)
# komt meer voor bij seedlings: daar numberclass verwacht
# niet teveel over nadenken, gewoon corrigeren: als beide voorkomen, dan degene die niet past wegdoen

```


```{r }
# check <- data_regeneration %>% 
#   filter(subcircle == "A1" & is.na(number_class))


check <- data_regeneration %>% 
  filter(subcircle == "A2" & 
           !is.na(nr_of_regeneration) &
           !is.na(number_class))
# 83

check2 <- data_regeneration %>% 
  filter(subcircle == "A2" & 
           is.na(nr_of_regeneration) &
           !is.na(number_class))
# 1574 waar enkel klasse vermeld staat, terwijl het een exact nummer zou moeten zijn
# package zal dan automatisch de klasse gebruiken ==> OK
```

! rubbing_damage bij de plot-level-resultaten (zie verder): er wordt "Inf" gecrëeerd indien bij A2-cirkel geen exact aantal genoteerd werd
=> om dit op te vangen toch in dataset voor A2 nr_regeneration vervangen door midwaarde van number_class


```{r correctie_A2_exactnr}
data_regeneration_ <- data_regeneration %>% 
  # number_class leegmaken als niet van toepassing (A2)
  mutate(number_class = ifelse(subcircle == "A2" & !is.na(nr_of_regeneration), 
                               NA, number_class )) %>% 
  # nr_of_reg overnemen van number_class als niet ingevuld (A2)
  mutate(nr_of_regeneration = ifelse(subcircle == "A2" & is.na(nr_of_regeneration), 
                               number_class, nr_of_regeneration)) 
  

data_regeneration_ %>% filter(subcircle == "A2" & !is.na(nr_of_regeneration) &
           !is.na(number_class)) %>% nrow()

data_regeneration <- data_regeneration_

```


```{r correctie_A1_klasse_NIET, eval = FALSE}
# OPGEPAST: number_class overnemen van nr_of_reg als niet ingevuld (A1): niet zo eenvoudig
  # mutate(number_class = ifelse(subcircle == "A2" & is.na(nr_of_regeneration), 
  #                              number_class, nr_of_regeneration))
    # nr_of_regeneration leegmaken als niet van toepassing (A1)
  # mutate(nr_of_regeneration = ifelse(subcircle == "A1" & !is.na(number_class), 
  #                              NA, nr_of_regeneration))  

data_regeneration_ %>% filter(subcircle == "A1" & !is.na(nr_of_regeneration) &
           is.na(number_class)) %>% nrow()
# 2988 => zijn er veel!
check <- data_regeneration_ %>% filter(subcircle == "A1" & !is.na(nr_of_regeneration) &
           is.na(number_class))



```


```{r check_NA}
# check NA's
col <- c("approx_nr_regeneration", "min_number_of_regeneration", "max_number_of_regeneration")
data_regeneration %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0

# check <- data_regeneration %>% filter_at(col, any_vars(is.na(.)))

```


## Correctie plotarea KV Kerss 

> niet nodig voor regeneration_by_plot(_height_species).csv : alles wordt berekend op subplotniveau, met opp 0.01 ha 
    plotarea_ha wordt aangepast bij begin van elke calc_reg-functie:
      plotarea_ha = ifelse(.data$plottype == "CA", 0.01, .data$plotarea_ha)
      
> wél nodig voor de resultaten op niveau van de core area
  
----
Regeneration: counted in standard height classes in subplots: 750 plots of 10x10m in 2001;
selection of 140 subplots (every 5th row) of 10x10m in 2010/11 and 2020/21 (see transects on
map)
Vegetation : standard relevé on 10x10m subplots: 750 plots, only summer survey in 2001; 140
plots in 2011 and 2021 - spring and summer survey; additional survey in spring 2015 (vernal
flora).


< dataverwerking 2012:
"AFWIJKENDE METHODIEK in de kernvlakte van Kersselaerspleyn  
-   Zeer grote kernvlakte (107485 m² = 10.75 ha) + onregelmatige vorm   
-   verjonging en vegetatie werden uitzonderlijk niet volledig heropgemeten in 2011, aangezien er niet zoveel veranderd was + hoge werkdruk  
-   Er werd geopteerd om een selectie van bandtransecten opnieuw in te meten:  
o    Bandtransekten van 10m breed, telkens NZ-gericht (loodrecht op de verdunningsdreef), telkens de eerste strook ten oosten van de 50x50m gridpunten  
o    Dat zijn dan 3 stroken van 300x10 m, 1 van 250, 1 van 150 en eentje van 100 m lang, oftewel 140 proefvlakjes (ipv 107485 m² / 100 m² = 1074 proefvlakjes //  750 in 2000) 
30*3+25+15+10 == 140

==>    Bijgevolg werd er voor de verjonging eigenlijk gewerkt met een plot van slechts 140*100m² groot = 14000 m² = 1,4 ha => aanpassen   


> Hierna plotarea aanpassen enkel voor berekening van regeneration


```{r }
data_regeneration %>% filter(plot_id == 11000) %>% 
  group_by(core_area_ha) %>% summarize() %>% ungroup() %>% dplyr::pull(core_area_ha)
# 10.7485

data_regeneration_ <- data_regeneration %>% 
  mutate(core_area_ha = ifelse(plot_id == 11000 & period > 1, 
                               1.4,
                               ifelse(plot_id == 11000 & period == 1,
                                      7.5,
                                      core_area_ha)),
         plotarea_ha = ifelse(plot_id == 11000 & period > 1, 
                               1.4,
                               ifelse(plot_id == 11000 & period == 1,
                                      7.5,
                                      plotarea_ha)))

data_regeneration <- data_regeneration_

# reg_CA <- data_regeneration %>% filter(plottype == "CA")
# table(reg_CA$forest_reserve, reg_CA$plotarea_ha)
# table(reg_CA$core_area_ha, reg_CA$plotarea_ha)
```



## Calculate regeneration 

```{r calc_reg}
regeneration <- calculate_regeneration(data_regeneration)

```


```{r CreateSeparateDataframesReg}
for (tablename in names(regeneration)) {
     assign(tablename, regeneration[[tablename]])
} 

```


## Check KV Kersselaerspleyn

Kloppen de resultaten nu? (voor 25/11/2022 een factor 10.75/1.4 verschil)

**Opbouw functie:**  
- data_regeneration_CA <- data_regeneration %>% filter(.data$plottype == "CA")    
- by_ca_species <- calculate_regeneration_core_area_species(data_regeneration_CA)  

- n_subplots = n_distinct(.data$subplot_id)  

- approx_nr_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$approx_nr_regeneration / .data$plotarea_ha, NA),

==> hogerop plotarea_ha aangepast aan 1.4 ha en 7.5 ha (ipv 10.75 ha)


```{r}
#   data_regeneration_CA <- data_regeneration %>%
#     filter(.data$plottype == "CA")
#   by_ca_species <- calculate_regeneration_core_area_species(data_regeneration_CA)

# is.na(subcircle): komt dat voor?
# data_regeneration %>% filter(is.na(subcircle) & !is.na(species)) %>% nrow() == 0
# NEE

```

```{r check_reg_Kerss_KV}
check_Kerss <- regeneration_by_core_area_species %>% 
  filter(plot_id == 11000)

check_Kerss <- regeneration_by_core_area_height_species %>% 
  filter(plot_id == 11000 & species == 7 & height_class == 3000)
# period = 2, zelfde resultaat als dataverwerking 2010 - OK

check_Kerss <- regeneration_by_core_area_height_species %>% 
  filter(plot_id == 11000 & species == 7 & height_class == 1000)
# period = 2, zelfde resultaat als dataverwerking 2010 - OK
```

Resultaten stemmen overeen met dataverwerking uit 2012.

```{r check_n_subplots_reg}
# controle n_subplots door runnen van deel van de functie -> OK!!
# table(by_plot_species_reg$n_subplots)
#    1   10   34   50   98  105  140  750 
# 5475   40   36  186  324   56   31   15 
```


## Check NA's

### Regeneration_by_plot

```{r}
names(regeneration_by_plot)
```

```{r}
col <- c("number_of_tree_species", "approx_nr_established_ha", "approx_nr_seedlings_ha",
         "mean_number_established_ha", "lci_number_established_ha", "uci_number_established_ha",
         "mean_number_seedlings_ha" , "lci_number_seedlings_ha", "uci_number_seedlings_ha")

regeneration_by_plot %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0

```

```{r}
col <- c("number_of_tree_species", "approx_nr_regeneration_ha",
         "mean_number_of_regeneration_ha", 
         "lci_number_of_regeneration_ha", "uci_number_of_regeneration_ha")

regeneration_by_plot_height %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0

```


```{r}
col <- c("approx_nr_regeneration_ha",
         "mean_number_of_regeneration_ha", 
         "lci_number_of_regeneration_ha", "uci_number_of_regeneration_ha")

regeneration_by_plot_height_species %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0

```

```{r}
col <- c("nr_of_subplots_with_regeneration", "perc_subplots_with_regeneration", 
         "approx_nr_established_ha", "approx_nr_seedlings_ha",
         "mean_number_established_ha", "lci_number_established_ha", "uci_number_established_ha",
         "mean_number_seedlings_ha" , "lci_number_seedlings_ha", "uci_number_seedlings_ha")

regeneration_by_core_area_species %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0

```


```{r}
col <- c("nr_of_subplots_with_regeneration", "perc_subplots_with_regeneration", 
         "approx_nr_regeneration_ha",
         "mean_number_of_regeneration_ha", 
         "lci_number_of_regeneration_ha", "uci_number_of_regeneration_ha")

regeneration_by_core_area_height_species %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0

```


#### TEMP: foute nullen vs NA bij mean_reg_ha - OK 25/11/2022

> blijkt momenteel opgelost te zijn (25/11/2022)

Bv. plot 130 vs 133: 

- als seedlings ingevuld zijn maar established niet (plot 133), dan NA ipv 0
- als niks ingevuld staat, maar wel een reg_date: dan 0 (plot 130) !! lci = 0 en uci = NA)

Data_regeneration bevat voor plot 133 enkel de seedlings en voor plot 130 enkel een lijn met heightclass en species = NA

```{r eval=FALSE}
check0 <- data_regeneration %>% filter(period == 1 & plot_id %in% c(133, 130))
# OK!

check <- regeneration_by_plot %>% filter(period == 1 & plot_id %in% c(133, 130))
# uci = NA is fout => aangepast zdd als sum & lci = 0, dan ci ook = 0 (ipv NaN)

check2 <- regeneration_by_plot_height %>% filter(period == 1 & plot_id %in% c(133, 130))
# uci = NA is fout => aangepast zdd als sum & lci = 0, dan ci ook = 0 (ipv NaN)

check3 <- regeneration_by_plot_height_species %>% filter(period == 1 & plot_id %in% c(133, 130))
# idem => misschien beter aanpassen in functie sum_interval!!
```


```{r eval=FALSE}
by_plot1 <- data_regeneration %>%
    mutate(
      plotarea_ha = ifelse(.data$plottype == "CA", 0.01, .data$plotarea_ha),
      min_number_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",  
               # als subcircle = NA, dan is aantal = 0
               # MAAR dit geldt enkel als er géén verjonging is
               # DUS als subcircle A1 is, en er is geen subcircle A2, dan hebben we hier NA!!
               # en omgekeerd ook
               # (subcircle wordt ook ingevuld bij core area's)
               # maar hier kunnen we geen extra lijn aanmaken 
               .data$min_number_of_regeneration / .data$plotarea_ha, NA),
      max_number_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$max_number_of_regeneration / .data$plotarea_ha, NA),
      min_number_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$min_number_of_regeneration / .data$plotarea_ha, NA),
      max_number_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$max_number_of_regeneration / .data$plotarea_ha, NA),
      approx_nr_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$approx_nr_regeneration / .data$plotarea_ha, NA),
      approx_nr_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$approx_nr_regeneration / .data$plotarea_ha, NA)
    ) 

by_plot2 <- data_regeneration %>%
    mutate(
      plotarea_ha = ifelse(.data$plottype == "CA", 0.01, .data$plotarea_ha),
      min_number_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$min_number_of_regeneration / .data$plotarea_ha, NA),
      max_number_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$max_number_of_regeneration / .data$plotarea_ha, NA),
      min_number_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$min_number_of_regeneration / .data$plotarea_ha, NA),
      max_number_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$max_number_of_regeneration / .data$plotarea_ha, NA),
      approx_nr_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$approx_nr_regeneration / .data$plotarea_ha, NA),
      approx_nr_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$approx_nr_regeneration / .data$plotarea_ha, NA)
    ) %>% 
    group_by(
      .data$plot_id, .data$year, .data$period, .data$subplot_id
    ) %>%
    summarise(
      established_interval =
        sum_intervals(
          var_min = .data$min_number_established_ha,
          var_max = .data$max_number_established_ha,
          transformation = "log", na_rm = TRUE
        ),
      seedlings_interval =
        sum_intervals(
          var_min = .data$min_number_seedlings_ha,
          var_max = .data$max_number_seedlings_ha,
          transformation = "log", na_rm = TRUE
        )
    ) %>%
    ungroup() 

by_plot3 <- data_regeneration %>%
    mutate(
      plotarea_ha = ifelse(.data$plottype == "CA", 0.01, .data$plotarea_ha),
      min_number_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$min_number_of_regeneration / .data$plotarea_ha, NA),
      max_number_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$max_number_of_regeneration / .data$plotarea_ha, NA),
      min_number_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$min_number_of_regeneration / .data$plotarea_ha, NA),
      max_number_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$max_number_of_regeneration / .data$plotarea_ha, NA),
      approx_nr_established_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A2",
               .data$approx_nr_regeneration / .data$plotarea_ha, NA),
      approx_nr_seedlings_ha =
        ifelse(is.na(.data$subcircle) | .data$subcircle == "A1",
               .data$approx_nr_regeneration / .data$plotarea_ha, NA)
    ) %>% 
    group_by(
      .data$plot_id, .data$year, .data$period, .data$subplot_id
    ) %>%
    summarise(
      established_interval =
        sum_intervals(
          var_min = .data$min_number_established_ha,
          var_max = .data$max_number_established_ha,
          transformation = "log", na_rm = TRUE
        ),
      seedlings_interval =
        sum_intervals(
          var_min = .data$min_number_seedlings_ha,
          var_max = .data$max_number_seedlings_ha,
          transformation = "log", na_rm = TRUE
        ),
      approx_nr_established_ha =
        sum(.data$approx_nr_established_ha, na.rm = TRUE),
      approx_nr_seedlings_ha = sum(.data$approx_nr_seedlings_ha, na.rm = TRUE)
    ) %>%
    ungroup() %>%
    mutate(
      mean_number_established_ha = .data$established_interval$sum,
      lci_number_established_ha = .data$established_interval$lci,
      uci_number_established_ha = .data$established_interval$uci,
      mean_number_seedlings_ha = .data$seedlings_interval$sum,
      lci_number_seedlings_ha = .data$seedlings_interval$lci,
      # uci_number_seedlings_ha = 
      #   ifelse(.data$seedlings_interval$sum == 0 
      #          & .data$seedlings_interval$lci == 0
      #          & is.na(.data$seedlings_interval$uci), 
      #          0, .data$seedlings_interval$uci),
      uci_number_seedlings_ha = .data$seedlings_interval$uci
    ) %>% 
  mutate(mean_number_established_ha = 
           ifelse(is.na(.data$mean_number_established_ha) 
                  & .data$mean_number_seedlings_ha > 0
                  , 0
                  , .data$mean_number_established_ha),
         lci_number_established_ha = 
           ifelse(is.na(.data$lci_number_established_ha) 
                  & .data$mean_number_seedlings_ha > 0
                  , 0
                  , .data$lci_number_established_ha),
         uci_number_established_ha = 
           ifelse(is.na(.data$uci_number_established_ha) 
                  & .data$mean_number_seedlings_ha > 0
                  , 0
                  , .data$uci_number_established_ha),
         mean_number_seedlings_ha = 
           ifelse(is.na(.data$mean_number_seedlings_ha) 
                  & .data$mean_number_established_ha > 0
                  , 0
                  , .data$mean_number_seedlings_ha),
         lci_number_seedlings_ha = 
           ifelse(is.na(.data$lci_number_seedlings_ha) 
                  & .data$mean_number_established_ha > 0
                  , 0
                  , .data$lci_number_seedlings_ha),
         uci_number_seedlings_ha = 
           ifelse(is.na(.data$uci_number_seedlings_ha) 
                  & .data$mean_number_established_ha > 0
                  , 0
                  , .data$uci_number_seedlings_ha),
         approx_nr_established_ha = 
           ifelse(is.na(.data$approx_nr_established_ha) 
                  & .data$approx_nr_seedlings_ha > 0
                  , 0
                  , .data$approx_nr_established_ha),
         approx_nr_seedlings_ha = 
           ifelse(is.na(.data$approx_nr_seedlings_ha) 
                  & .data$approx_nr_established_ha > 0
                  , 0
                  , .data$approx_nr_seedlings_ha)
  )
         

by_plot3 <- calculate_regeneration_plot(data_regeneration)

```

```{r eval=FALSE}
names(by_plot1)

check4 <- by_plot1 %>% filter(period == 1 & plot_id %in% c(133, 130, 138)) %>% 
  select(plot_id, subcircle, date_regeneration, height_class, contains(c("min_number", "max_number", "approx")))

check5 <- by_plot2 %>% filter(period == 1 & plot_id %in% c(133, 130))

check6 <- by_plot3 %>% filter(period == 1 & plot_id %in% c(133, 130, 138))

str(check6)
```



#### TEMP: foutje in percentage rubbing dammage

Is berekend obv exact aantal, maar soms ook bij aantalsklasse => moet obv approx_nr als exact aantal niet beschikbaar is
> package zal in die zin aangepast worden (25/11/2022): #102

Op dit moment wordt ubbing_damage enkel voor A2 berekend
> package zal in die zin aangepast worden (25/11/2022): #102


! er wordt "Inf" gecrëeerd voor A1's, want in code wordt gedeeld door sum(....*A2):
bijgevolg steeds 0 voor A1
> package zal in die zin aangepast worden (25/11/2022): #102

Na indien bij A2-cirkel geen exact aantal genoteerd werd
=> om dit op te vangen toch in dataset voor A2 nr_regeneration vervangen door midwaarde van number_class (zie hoger)


```{r eval=FALSE}
names(data_regeneration)

check0 <- data_regeneration %>% 
  filter(period == 2 & !is.na(rubbing_damage_number)) %>% 
  select(plot_id, period, subcircle, date_regeneration, height_class, species, number_class, nr_of_regeneration, contains(c("rubbing", "min_number", "max_number", "approx")))

# er zijn er veel mét aantal, maar zonder percentage
t <- check0 %>% 
  filter(is.na(rubbing_damage_perc) & !is.na(rubbing_damage_number))
nrow(t) # 5519

# een deel zijn '0' => die mogen NA zijn (niet geweten hoeveel rubbing, als er geen verjonging is)
t1 <- check0 %>% 
  filter(is.na(rubbing_damage_perc) & !is.na(rubbing_damage_number)
         & rubbing_damage_number != 0)
nrow(t1)  #47

# over alle hoogteklasses wordt number genoteerd
t2 <- check0 %>% 
  filter(!is.na(rubbing_damage_number))

table(t2$height_class)
```



## Export

```{r join_plottype_surveynr_BR_reg}
reg_plotinfo <- lapply(regeneration, function(x) left_join(x, plotinfo %>% select(plot_id, forest_reserve, plottype, period, survey_number), by = c("plot_id", "period")))
# lapply: same function over all elements of the list

```

```{r save_reg_git, eval = FALSE}
save_results_git(
  results = regeneration,
  repo_path = path_to_git_forresdat,
  strict = TRUE,
  # strict = FALSE
)
```


```{r save_reg_git_manueel, eval = FALSE}
# manueel - eigen simpele functie
save_results_tsv(regeneration, 
                 root = path_to_forresdat_data,
                 strict = FALSE)
```


```{r save_reg_access_csv, eval = FALSE}
save_results_csv (
  results = reg_plotinfo,
  output_dir = path_to_plotlevel_csv
)

# afgerond voor export naar access
# de df's van CP mogen op 0 afgerond worden (= 1ste drie dataframes)
# de KV's op 2 cijfers na de komma

reg_CP <- reg_plotinfo[c(1:3)]
reg_CP <- reg_CP %>% 
  lapply(., function(x) round_df(x, 0)) 
  
reg_CA  <- reg_plotinfo[c(4:5)]
reg_CA <- reg_CA %>% 
  lapply(., function(x) round_df(x, 2))

reg_round <- c(reg_CP, reg_CA)

save_results_access(
    results = reg_round,
    database = path_to_analysis_set_db,
    remove_tables = TRUE
  )

```


# Vegetation - OK - 8/4/2022

## Calculate

```{r load_veg}
data_vegetation <-
  load_data_vegetation(
    database = path_to_fieldmap_db,
    processed = TRUE
  )
data_herblayer <-
  load_data_herblayer(
    database = path_to_fieldmap_db,
    processed = TRUE
  )

vegetation <- calculate_vegetation(data_vegetation, data_herblayer)
```

## Controle plot-level-data

```{r CreateSeparateDataframesVeg}
for (tablename in names(vegetation)) {
     assign(tablename, vegetation[[tablename]])
} 

```


```{r}
# plot 1176, periode 1: niet in veg_by_plot => Els gevraagd om dit te corrigeren (nov 2022)

data_vegetation %>% filter(plot_id == 1176)
data_herblayer %>% filter(plot_id == 1176 & period == 1)

vegetation_by_plot %>% filter(plot_id == 1176 & period == 1)

```


## Controle KV Kerss

n_subplots is fout: 710 ipv 750 (2eset wel OK, 140)

calculate_vegetation_core_area_species <- function(data_herblayer, data_vegetation) {
  by_core_area_species <- data_herblayer %>%
    group_by(.data$plot_id, .data$period) %>%
    mutate(
      n_subplots = n_distinct(.data$subplot_id)

OPGEPAST: `n_subplots` zou moeten bepaald worden op "data_vegetation", want in herblayer 
zitten enkel de subplots waar een soort waargenomen werd

> aan els gevraagd om dit aan te passen in PR van reg_AL (29/11/2022)
Hier niet aangepast, geeft geen immens grote afwijking, tijdelijk zo laten ...

Bij regeneration wordt van regeneraion-subplots vertrokken, dus daar is het aantal subplots wel correct.

```{r check_n_subplots_veg}
# controle n_subplots door runnen van deel van de functie -> OK!!
table(by_core_area_species$n_subplots)
#     1    10    34    50    97    98   105   140   710 
# 26466   174   101   724    34   917   194   111    76 

# ? 97 
# plot 41000, period 3, subplot 00.60, ID 22 is leeg en wordt daarom niet meegerekend

# ? 710 ipv 750?
# waarom bij reg geen probleem?
table(by_plot_species_reg$n_subplots)
```

```{r check_veg_Kerss_KV}
check_Kerss <- vegetation_by_core_area_species %>% 
  filter(plot_id == 11000)

check_Kerss <- vegetation_by_core_area_species %>% 
  filter(plot_id == 11000 & species == 71)  # beuk
# period = 2, zelfde resultaat als dataverwerking 2010 - OK

```

Resultaten stemmen overeen met dataverwerking uit 2012, muv percentage subplots, period 1.


## Check NA's

```{r}
names(vegetation_by_plot)
summary(vegetation_by_plot)
# veel covers niet ingevuld ...
```

```{r}
col <- c("number_of_species", "cumm_herb_coverage_class_average_perc")

vegetation_by_plot %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0

```

```{r}
names(vegetation_by_core_area_species)

col <- c("number_of_subplots_with_vegetation", "perc_of_subplots", "mean_coverage_class_average_perc")

vegetation_by_core_area_species %>% filter_at(col, any_vars(is.na(.))) %>% nrow() == 0

```

## Export


```{r join_plotinfo_veg}
veg_plotinfo <- lapply(vegetation, function(x) left_join(x, plotinfo %>% select(plot_id, forest_reserve, plottype, period, survey_number), by = c("plot_id", "period")))
# lapply: same function over all elements of the list
```


```{r save_veg_git, eval = FALSE}
# geen plotinfo naar git
save_results_git(
  results = vegetation,
  repo_path = path_to_git_forresdat,
  # strict = TRUE, 
  strict = TRUE
)
```

```{r save_veg_git_manueel, eval = FALSE}
# manueel - eigen simpele functie - als save_results_git niet werkt
save_results_tsv(vegetation, 
                 root = path_to_forresdat_data, 
                 strict = FALSE)
```


```{r save_veg_access_csv, eval = FALSE}
# volgende functie heb ik zelf geschreven, zit niet in het package!
save_results_csv (
    results = veg_plotinfo,
    output_dir = path_to_plotlevel_csv
    )

# afgerond voor export naar access
# de df's van CP mogen op 0 afgerond worden (= 1ste drie dataframes)
# de KV's op 2 cijfers na de komma
veg_round <- veg_plotinfo %>% 
  lapply(., function(x) round_df(x, 2))

# save_results_access (
#   results = veg_round,
#   database = path_to_analysis_set_db,
#   remove_tables = TRUE
#   )

# Functie "save_results_access" (< package) geeft problemen met dates => hierna manueel
vegetation_by_plot <- vegetation_by_plot %>% 
  mutate(date_vegetation = as.Date(gsub(' SAST','',date_vegetation))) 
  # gsub (SAST) is om tijdzone weg te halen, anders wordt een dag vroeger weergegeven


con <- odbcConnectAccess2007(path_to_analysis_set_db)

# vegetation_by_plot
dbtables <- sqlTables(con)
if ("vegetation_by_plot" %in% dbtables$TABLE_NAME) {
        sqlDrop(con, "vegetation_by_plot")
      }
sqlSave(con, dat = vegetation_by_plot, tablename = "vegetation_by_plot", varTypes = c(date_vegetation="datetime"))


# vegetation_by_core_area_species
dbtables <- sqlTables(con)
if ("vegetation_by_core_area_species" %in% dbtables$TABLE_NAME) {
        sqlDrop(con, "vegetation_by_core_area_species")
      }
sqlSave(con, dat = vegetation_by_core_area_species, tablename = "vegetation_by_core_area_species")

odbcClose(con)
```


# Herblayer - OK - 29/11/2022

## Export
Ook herblayer naar forresdat wegschrijven

```{r select_variables}
names(data_herblayer)

con <- odbcConnectAccess2007(path_to_fieldmap_db)
qBrowsIndex <- sqlFetch(con, "qBrowsIndex")
# qCoverHerbs <- sqlFetch(con, "qCoverHerbs")
odbcClose(con)

herblayer <- data_herblayer %>%
  select(plot_id, subplot_id, period, 
         date_vegetation, year, 
         species, coverage_class_average_perc, 
         browse_index_id) %>%
  left_join(qBrowsIndex %>% select(ID, Value2), by = c("browse_index_id" = "ID")) %>% 
  rename(browse_index = Value2) %>% 
  # mutate(date_vegetation = as.Date(date_vegetation)) 
  # !! r as.Date returns previous day 
  mutate(date_vegetation = as.Date(gsub(' SAST','',date_vegetation))) 
  # Which will remove the timezone from part of the string and then convert to date.

# save_results_xxxx: gemaakt om list weg te schrijven
# hier maar één dataframe
herblayer_list <- list(herblayer_by_plot = herblayer)
herblayer_list_git <- list(herblayer_by_plot = herblayer %>% select(-browse_index))
# summary(herblayer)

```


```{r join_plotinfo_herb}
herb_plotinfo <- lapply(herblayer_list, function(x) left_join(x, plotinfo %>% select(plot_id, forest_reserve, plottype, period, survey_number), by = c("plot_id", "period")))
# lapply: same function over all elements of the list

```



```{r save_herb_git, eval = FALSE}
# geen plotinfo naar git
save_results_git(
  results = herblayer_list_git,
  repo_path = path_to_git_forresdat,
  strict = TRUE
)

```

```{r save_herb_git_manueel, eval = FALSE}
# manueel - eigen simpele functie - als save_results_git niet werkt
save_results_tsv(herblayer_list_git, 
                 root = path_to_forresdat_data, 
                 strict = FALSE)
```


```{r save_herb_access_csv, eval = FALSE}
# volgende functie heb ik zelf geschreven, zit niet in het package!
save_results_csv (
    results = herb_plotinfo,
    output_dir = path_to_plotlevel_csv
    )

# afgerond voor export naar access
herb_round <- herb_plotinfo %>% 
  lapply(., function(x) round_df(x, 2))

# save to access nog steeds niet opgelost, is alsof access date niet herkent
# => manueel gedaan (csv opgeslagen als xlsx en dan geïmporteerd; csv gaf zelfd eproblemen als access)
        # save_results_access(
        #   results = herb_[1],
        #   database = path_to_analysis_set_db,
        #   remove_tables = TRUE
        # )

# probleem met datumvelden => varTypes aanduiden
con <- odbcConnectAccess2007(path_to_analysis_set_db)

dbtables <- sqlTables(con)
if ("herblayer_by_plot" %in% dbtables$TABLE_NAME) {
        sqlDrop(con, "herblayer_by_plot")
      }
# sqlSave(con, dat = herblayer, tablename = "herblayer_by_plot", fast = FALSE)
sqlSave(con, dat = herb_round[[1]], tablename = "herblayer_by_plot", varTypes = c(date_vegetation="datetime"))

odbcClose(con)

```


**Na update van forresdat, project "forresdat" openen en alles naar de cloud pushen**
**Eventueel ook access op gdrive plaatsen**


