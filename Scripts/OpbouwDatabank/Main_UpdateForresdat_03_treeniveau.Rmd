---
title: "Update forresdat 3 - dendro op stam- en boomniveau"
author: "Anja Leyman"
date: "`r Sys.Date()`"
output: 
  html_document:
    keep_md: FALSE
    number_sections: yes
    fig_caption: yes
    code_folding: hide
    toc: TRUE
    toc_float:
      collapsed: yes
      smooth_scroll: yes
---

```{r Rm, eval = FALSE}
rm(list=ls())
```

```{r Setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  # eval = FALSE,  # FALSE: dan kan ik knitten zonder dat er iets gebeurt
  message = FALSE,
  warning = FALSE, 
  fig.width = 9,
  fig.align = TRUE)

library(here)

# libraries & invoergegevens
source(here::here("scripts/Setup.R"))
```

```{r Setup2}
path_to_html_teamdrive <- paste0(path_to_dataverwerking_teamdrive, "25_Overkoepelend")
```


> juiste forrescalc kiezen:   
- om weg te schrijven naar forresdat - branch main => met juiste release van het package: dan `install.packages("forrescalc")`  
- laatste correcties van forrescalc => juiste branch selecteren in forrescalc en opnieuw builden - wegschrijven kan naar forresdat - branch "develop"
(10/3/25: branch 'bugfix' met corr van read_forresdat waarbij we de develop branch kunnen selecteren ipv main)

```{r forrescalc_to_write_to_forresdat, eval = FALSE}
# !!! eerst zeker 'install.packages("forrescalc")
# zodat forresdat-data goede release krijgt!
# zie mail 7/10/24 van Els L.
# soms een andere branch nodig als Els nog iets moet fixen, maar als ik naar forresdat 
# wil wegschrijven, moet ik officiële versie van forrescalc gebruiken

install.packages("forrescalc")

```



# Vraagstelling
DOEL van dit script is een update van forresdat gegevens naar 

- forresdat-folder als tsv (nadien nog te pushen naar github)
- BR_analysedb.accdb
- output-folders "_plot-level-data" en "_tree-level-data" als csv
- gdrive-folders "_plot-level-data" en "_tree-level-data" als csv

Kersselaerspleyn blijkt op meerdere vlakken uitzonderingen te bevatten.
Deze uitzonderingen worden na het inladen van de data gecorrigeerd. 

```{r results='hold', eval=TRUE}
path_to_forresdat_data
path_to_dataverwerking
path_to_dataverwerking_teamdrive
path_to_analysis_set_db
path_to_plotlevel_csv
path_to_treelevel_csv
path_to_meetgegevens

```

# Load plotinfo

Plotinfo inladen: `plottype`, naam `forest_reserve` en info over survey's.
(plotinfo op gdrive en forresdat: enkel processed plots!)

```{r }
# mbv forresdat
# plotinfo <- read_forresdat(file = "plotinfo", root = path_to_forresdat_data)
# names(plotinfo)
# ?read_forresdat

# van c-schijf
plotinfo <- read.csv2(paste0(path_to_plotlevel_csv, "plotinfo.csv")) %>% 
  select(-1)

```


# Load dendro data - voorlopig OK - 31/5/2023

Standaard wordt enkel processed data ingeladen mbv de load-functies

```{r load_dendro1_processed, results = 'hide'}
data_dendro <- load_data_dendrometry(database = path_to_fieldmap_db, 
                                     extra_variables = TRUE, 
                                     processed = TRUE) 
# %>% ilter(plottype != "OTHER")  # enkel CP of CA - omdat processed = TRUE worden andere plottypes hier niet meegenomen
unique(data_dendro$plottype)
data_dendro %>% filter(plot_id == 11000 & period == 1 & tree_measure_id == 10)

```

```{r load_dendro2, results="hide"}
data_shoots <- load_data_shoots(database = path_to_fieldmap_db, extra_variables = TRUE)

data_stems  <- compose_stem_data(data_dendro, data_shoots, extra_variables = TRUE)
# data_stems %>% filter(plot_id == 11000 & period == 1 & tree_measure_id == 10)

# height_model <- load_height_models()
# sneller en bij problemen met forresheights github, lokale modellen gebruiken
path_to_height_models # "C:/03_BR/1_DataVerwerkingBR/Data/Hoogtemodellen/"
height_model <- load_height_models_local(path_to_height_models)
# mean(height_model$P1) == mean(height_model2$P1)

data_deadwood <- load_data_deadwood(database = path_to_fieldmap_db, processed = TRUE)
# unique(data_deadwood$plottype) # CP CA
```

Waar hoogtemodellen beschikbaar? 

```{r check_heightmodels}
table(height_model$forest_reserve, height_model$period)
# table(plotinfo$forest_reserve)

height_model %>% group_by(forest_reserve) %>% summarise(n = n()) %>% ungroup() %>% anti_join(plotinfo, by = c("forest_reserve"))
## prognoses_extra: OK, deze hoeven niet meegenomen worden bij de standaard dataverwerking, 
# want geen deel van monitoring (onbeheerde) BRen
# In moederdb zijn plotdetails niet ingevuld (geen processed en geen "reservaat"forest_reesrve") 
# => trees werden niet ingeladen 
```


## Correctie year van dendrometrie


Year = jaar van groeiseizoen
Grens was gelegd op 1/7, nu naar 1/5.
Aangevraagd in issue # 114, OK (27/3/2024)
<!-- Berekening van year en year_dendro aangepast voor load_data_dendrometry() en load_plotinfo():  -->

**T.e.m. 30 april wordt nog bij het vorige jaar geteld, vanaf 1 mei wordt bij het **
**nieuwe jaar geteld (1 mei bij huidig jaar).**

Volgende reservaten daadwerkelijk over twee jaartallen heen opgemeten:

- Bos Terrijst CA - 1eSET: OK
- Heirnisse - 2eSET: 5 plots 9/2014: OK
- Everzwijnbad - 3eSET: 1 plot (118) pas op 5/5/2023 opgemeten
- Zoniën HARRAS_1995 - 3eSET: 3 plots nog opgemeten 14/5/2020, rest in 2019 opgemeten
- Zoniën UITBR_2010 - 3eSET: 52 plots jan 2020 tot april 2020 en 12 plots in mei 2020


```{r check, results = 'hide'}
names(data_dendro)
# data_dendro %>% filter(plot_id == 11000 & period == 1 & tree_measure_id == 10)

year_range <- data_dendro %>% 
  group_by(forest_reserve, period) %>% 
  summarize(min_year = min(year), 
            max_year = max(year),
            year_range = paste0(min_year, " - ", max_year)) %>% 
  ungroup()

t <- year_range %>% 
  filter(min_year != max_year)

```


# Correctie Kersselaerspleyn staande bomen

## Afwijkingen 

- KV 1986: 
** geen shoots, geen deadwood, reg of veg
** pas vanaf dbh > 30 cm  

- KV 2000: 
** pas vanaf dbh 30 cm volopname  
** boompjes met dbh 10-30 cm werden geteld, niet gepositioneerd, ook geen dbh of hoogte gekend


## Staande bomen 1ste decade KV Kersselaerspleyn pas vanaf 30 cm

Hier **NIET WEGFILTEREN VAN** de bomen met dbh < 30 cm in `data_stems` en `data_dendro` 
(want sommige old_id's uit p2 verwijzen naar die boompjes).
Wel goed beseffen dat er sommige wel, en sommige niet gekoppeld konden worden aan een boom uit p1 !!

> We gaan ervanuit dat degene die data gebruiken, het methodiekrapport gelezen hebben en dit dus weten.
Staat ook in metadata


# Calculate dendro data

```{r stems_trees_calc}
data_stems_calc <- calc_variables_stem_level(data_stems, height_model)

data_dendro_calc <- calc_variables_tree_level(data_dendro, data_stems_calc)

# dendro <- calculate_dendrometry(data_dendro, data_deadwood, data_shoots, height_model)

data_stems_calc %>% filter(is.na(calc_height_m)) %>% nrow() == 0 
data_dendro_calc %>% filter(is.na(calc_height_m)) %>% nrow() == 0

```


```{r CreateSeparateDataframesDendro}
# for (tablename in names(dendro)) {
#      assign(tablename, dendro[[tablename]])
# } 

```



# Check NA's

Een NA wijst vaak op een missing value in FM

> OPGEPAST
> Als in trees layer het veld `ind_sht_cop` = coppice (12)
én de  shoot zit toch niet in de shoots layer
dan wordt een fout gecreëerd in forrescalc (met NA voor volume als gevolg)
DUS BEST MEENEMEN IN DATACONTROLE

> OOK AANDACHT VOOR MISSING DBH OF HEIGHT VAN SNAGS !!!

```{r check_NA1, eval = FALSE}
col <- c("dbh_mm", "species", "dbh_class_5cm", "calc_height_m", "vol_crown_m3",
         "vol_bole_m3", "vol_tot_m3", "stem_number_alive_ha", "stem_number_dead_ha",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha",
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha",
         "intact_snag", "alive_dead", "ind_sht_cop")
nrow(data_stems_calc  %>%
       filter_at(col, any_vars(is.na(.)))) == 0

col <- c("dbh_mm", "species", "dbh_class_5cm", "calc_height_m",
         "basal_area_m2", "vol_bole_m3", "vol_crown_m3", "vol_tot_m3",
         "basal_area_alive_m2_ha", "basal_area_dead_m2_ha", "vol_alive_m3_ha",
         "vol_dead_standing_m3_ha", "vol_bole_alive_m3_ha", "vol_bole_dead_m3_ha",
         "number_of_trees_alive_ha", "number_of_trees_dead_ha")

nrow(data_dendro_calc  %>%
       filter_at(col, any_vars(is.na(.)))) == 0

```


# Vergelijking met oude data

```{r eval = FALSE}
trees_git <- read.csv2(file = paste0(path_to_treelevel_csv, "trees_calc.csv"))
nrow(trees_git) - nrow(data_dendro_calc) == 36
summary(data_dendro_calc)
summary(trees_git)
check <- trees_git %>% 
  anti_join(data_dendro_calc, by = c("period", "plot_id", "tree_measure_id"))
# 0  (nu ook mét 913 van Kerss KV 2000 < 30 cm dbh: die moeten mee opgenomen blijven)
check <- data_dendro_calc %>% 
  anti_join(trees_git, by = c("period", "plot_id", "tree_measure_id"))
# Rodebos KV1&2: periode 3: OK, wel nog niet in detail bekeken

stems_git <- read.csv2(file = paste0(path_to_treelevel_csv, "stems_calc.csv"))          
nrow(stems_git) - nrow(data_stems_calc) == -321
summary(data_stems_calc)
summary(stems_git)
check2 <- stems_git  %>% 
  anti_join(data_stems_calc, by = c("period", "plot_id", "tree_measure_id"))
# 0  (nu ook mét 913 van Kerss KV 2000 < 30 cm dbh: die moeten mee opgenomen blijven)
check2 <- data_stems_calc  %>% 
  anti_join(stems_git, by = c("period", "plot_id", "tree_measure_id"))
# 1234: Rodebos KV1&2: periode 3: OK, wel nog niet in detail bekeken
```


```{r save_Rdata, results = 'hide'}
names(data_dendro_calc)

# save(data_dendro_calc, file = "data_dendro_calc.Rdata")
# save(data_stems_calc, file = "data_stems_calc.Rdata")

save(data_dendro_calc, data_stems_calc, file = here::here("RData/main03_data_dendro_stems_calc.Rdata"))
```


# Create unique tree-id - 11/3/2025 laatste keer gerund (8/4/2022 // 31/5/2023 voorlaatste keer)

**! nog niet in detail gecheckt voor KV's**  

**! nog datacontrole te doen, ook voor bepaalde CP's **
(al zeker: 717,763,940,1155,1310,1502,1609: hebben dubbele coppice-id)

`Data_dendro_calc` bevat een unieke `tree_id` per boom (die constant blijft doorheen de tijd),
verschillend van de `tree_measure_id` uit fieldmap, die wel varieert doorheen de tijd.

Deze `tree_id` wordt in het package aangemaakt obv old_id.

**OPGEPAST**
Bij hakhout kan/kon dit soms tot gemiste linken leiden. 
(zie ook "TreeMortalityData_DetailHakhout.Rmd")

Hakhoutstoven worden opgesplitst in een levend en dood deel, 
en elk deel wordt dan als een afzonderlijke boom beschouwd 
(een boom kan immers niet én levend én dood tegelijk zijn)

OldID wordt standaard toegekend aan het levende deel van de hakhoutstoof.
Het dode deel wordt gelinkt via CoppiceID.
Indien er enkel een dood deel is (en geen levend deel), dan wordt daar OldID aan toegekend.

Dat wil zeggen dat er zich enkel een probleem stelt wanneer er in één van de 
twee periodes zowel een levend als een dood deel voorkomt.
In de andere gevallen is de koppeling die gebeurt via OldID correct.

**OPLOSSING**
Daarom wordt in code hierna voor hakhout dat in één van de 
twee periodes uit zowel een levend als een dood deel bestaat, de tree_id bepaald obv coppice_id.

Voor de 11 verwerkte CP's + KV Muizenbos is die koppeling gecheckt en OK bevonden.

Dit houdt in dat tree_id niet meer uniek is per periode.
Dat geeft dan weer problemen wanneer we er een "wijde" tabel van willen maken.

Daarom wordt er een _a of _b toegevoegd, afh. of het om levend of dood deel van een hakhoutstoof gaat.
Indien we toch één ID per hakhout willen, ongeacht levend/dood, dan kunnen we makkelijk de _a en _b verwijderen (= `tree_id_non_unique`).


## Op boomniveau - obv old-id

Met behulp van `create_unique_tree_id()` voor 4 decades. 

<!-- `create_unique_tree_id()` oneindige loop wanner old_id niet in vorige periode gevonden wordt: issue # 119: opgelost -->


```{r mbv_oldid_obv_package, results = 'hide'}
tree_id <- create_unique_tree_id(data_dendro = data_dendro_calc)
# Deze tabel wordt NIET bewaard in forresdat (daar enkel geaggregeerde resultaten op plotniveau)

# check
tree_id %>% filter(is.na(tree_id)) %>% nrow() == 0
tree_id_missing <- tree_id %>% filter(is.na(tree_id))
table(tree_id_missing$forest_reserve, tree_id_missing$period)

# selectie om wijde tabel aan te maken
tree_id_long <- tree_id %>%
  select(plot_id, species, tree_id, period, tree_measure_id, dbh_mm, vol_tot_m3, alive_dead)

```


## Op boomniveau - obv coppice-id

**EVENTUEEL EXTRA TOEVOEGEN**  
> 21/2/2022: link obv coppice-id, want dat wordt veel gevraagd.
> Zie ook `Euforia_TreePlotData_Flanders_Olalla_2022-01-13.Rmd`.

Uitsplitsen van hakhoutstoven in dood en levend deel is nodig, want een "tree" kan niet zowel levend als dood zijn.
Bovendien kan een `oldID` niet aan twee "trees" toegekend worden, omdat er anders problemen ontstaan met de koppeling die gebaseerd is op OldID (moet een één-op-één relatie zijn tussen de 2 periodes).

In de databank wordt OldID standaard toegekend aan het levende deel van de hakhoutstoof.   
Het dode deel wordt gelinkt via CoppiceID.   
Indien er enkel een dood deel is (en geen levend deel), dan wordt daar OldID aan toegekend.   

Dus bij de hakhoutstoven die (in eenzelfde periode) uit een levend en dood deel bestaan, hebben de twee delen niet dezelfde oldID, maar wel dezelfde coppice_id.    

Dat wil zeggen dat er zich enkel een probleem stelt wanneer er in één van de twee periodes zowel een levend als een dood deel voorkomt.   
In de andere gevallen kan de koppeling gebeuren via OldID.   

Zo werken we dan ook:  

- 2 delen: koppeling via OldID
- 3 of 4 delen: koppeling via CoppiceID  

In kader van het TreeMortality project hebben we nog een extra onderscheid gemaakt tss levend en dood deel van een hakhoutstoof, door _a en _b toe te voegen voor resp. levend of dood deel van een stoof.
Dat was toen nodig omdat we extra records "fallen" toe moesten voegen voor het dood hout dat er niet meer was.

Dat is ook nodig wanneer we er ooit een "wijde" tabel van willen maken.

Het is echter niet zeker dat dat een correcte link is, want beide delen lopen als het ware in elkaar over. 
Bv. - periode 1 levend gekoppeld aan periode 2 levend
    - periode 1 dood gekoppeld aan periode 2 dood
--> mogelijks zijn er van de levende wat extra dood gegaan, en van de dode wat omgevallen (fallen)
maar dat is niet te bepalen (kan vergeleken worden met dode takken in een boom)
(zie ook `TreeMortalityData_DetailHakhout.Rmd`)

Indien we een correcte link willen, moeten we _a en _b terug verwijderen, met als gevolg dat tree-id géén uniek veld meer is.

> !! controle van die coppice_id nodig obv aantal soorten en afwijking van XY
> reeds gedaan voor de 11 bosreservaten (CP's) in forresdat op 30/5/2023)
Nu zijn daar 3de decade wijnendale, everzwijnbad, with heide, heirnisse, jansheide bijgekomen
? welke 2 nog extra? 
Zoniën KERN_1983 afgesplitst van Zonien UITBR_1995
Kluisbos?

```{r results='hide'}
plotinfo %>% filter(plottype == "CP") %>% select(forest_reserve) %>% unique()
```


__Werkwijze:__

* bepalen hoeveel delen er per hakhoutstoof aanwezig zijn

* data opsplitsen:
    (1) een deel waarbij link via OldID behouden blijft (= treeid): **_data_OldID_**
    (individuele bomen en coppice dat uit max. één deel bestaat per periode)
    (2) een deel waarbij link via CoppiceID gecreëerd wordt (= nieuwe tree_id): **_data_CoppID_**
    (coppice met ergens een periode met 2 delen)
 
* in data_CoppID de treeid vervangen door period_plotid_coppiceID_a indien levend 
en period_plotid_coppiceID_b indien dood

* samenvoegen van data_OldID, data_CoppID

--
Vanaf 3 decades wordt het moeilijker.
Dan zouden we moeten kijken of er max. één per decade is, dan obv old_id
Zodra er meer dan één per decade is, dan moeten we werken met coppice_id voor allemaal en dan onderscheid tss levend en dood mbv suffix "a" en "b". 


```{r NumberOfPartsPerCoppicePerDecade, results = 'hide'}
tree_id %>% filter(coppice_id > 0) %>% nrow()
# [1] 17224 - 18015 - 18481 - 21584

# coppice_id en plot_id samen uniek => hoeveel metingen zijn er per stoof en per decade 
# (max.2, 1 levend en 1 dood deel- klopt)
summ_coppice_id <- tree_id %>% 
  filter(coppice_id > 0) %>%
  group_by(coppice_id, plot_id, period) %>% 
  summarise(aantal = n()) %>% 
  ungroup()
# 16138 - 16536 - 19253

table(summ_coppice_id$aantal)  # per periode max 2 => OK
#     1     2 
# 14645  1918
#     1     2 
# 16922  2331 

summ_coppice_id %>% filter(aantal > 2) %>% distinct(plot_id)

summ_coppice_id %>% filter(aantal > 2)

# vb van 3 decades
tree_id %>%  filter(coppice_id == 32 & plot_id == 31000) %>% 
  select(period, tree_measure_id, species, alive_dead, nr_of_stems, x_local, y_local, tree_id, coppice_id)


# summ_coppice_id
summ_coppice_id_def <- summ_coppice_id %>% 
  group_by(coppice_id, plot_id) %>% 
  summarise(max_aantal = max(aantal)) %>% 
  ungroup()
# 9690 - 9774 - 10125
```

```{r SplitDataTrees_OldID_CoppID, results = 'hide'}
tree_id_  <- tree_id %>% 
  left_join(summ_coppice_id_def, by = c("plot_id","coppice_id")) %>% 
  rename (max_nr_parts_coppice = max_aantal) 

str(tree_id_)
str(summ_coppice_id_def)

# tree_data via OldID
tree_data_OldID <- tree_id_ %>% 
  filter (ind_sht_cop != 12 | max_nr_parts_coppice < 2 | is.na(coppice_id))

# tree_data via coppice ID
tree_data_CoppID <- tree_id_ %>% 
  filter (max_nr_parts_coppice > 1)

nrow(tree_data_OldID) + nrow(tree_data_CoppID) - nrow(tree_id) == 0
# [1] 0

```

Daar waar coppice in één van de (twee of drie) decades uit meer dan één deel bestaat, `tree_id` vervangen door een id obv `coppice_id`.
(één deel lukt nog via old_id, zelfs al is het een dood dat verwijst naar voorheen een levend)

```{r CreateNewTreeID_TreeData_CoppID, results = 'hide'}
tree_data_CoppID_ <- tree_data_CoppID %>% 
  rename (treeid_old = tree_id) %>%    # tree-id obv old_id
  mutate (tree_id = paste(1, plot_id, coppice_id, sep = "_")) %>%
  mutate (tree_id = ifelse(alive_dead == 11, paste(tree_id, "a", sep = "_"),
                          ifelse(alive_dead == 12, paste(tree_id, "b", sep = "_"),
                                 NA)))

names(tree_data_CoppID_)

check_coppID <- tree_data_CoppID_ %>% 
  select(plot_id, 
         tree_id, tree_measure_id, coppice_id,
         max_nr_parts_coppice,
         x_local, y_local, 
         period, 
         species, 
         alive_dead, intact_snag, ind_sht_cop, decaystage,
         dbh_mm, height_m, calc_height_m, vol_tot_m3
         ) 

tree_data_CoppID <- tree_data_CoppID_
```

## Samenvoegen op boomniveau

```{r rbind_tree_data_OldID_CoppID, results = 'hide'}
tree_data_CoppID <- tree_data_CoppID %>% 
  select(-treeid_old)

tree_data_all <- rbind(tree_data_OldID, tree_data_CoppID)

nrow(tree_data_all) == nrow(tree_id)
names(tree_data_all)
names(tree_id)

# check_a_b <- tree_data_all %>% 
#   select(plot_id, 
#          tree_id, tree_measure_id, coppice_id,
#          nr_parts_coppice,
#          x_local, y_local, 
#          period, 
#          species, 
#          alive_dead, intact_snag, ind_sht_cop, decaystage,
#          dbh_mm, height_m, calc_height_m, vol_tot_m3
#          ) %>% 
#   filter(nr_parts_coppice > 2)

tree_id_ <- tree_data_all %>% 
  mutate(tree_id_non_unique = ifelse(max_nr_parts_coppice < 2 | is.na(max_nr_parts_coppice), tree_id,
                                 str_sub(tree_id, 1, -3)),
         test = (tree_id_non_unique == tree_id))
# %>%
#   select(plot_id,
#          tree_id, tree_measure_id,
#          coppice_id, old_id,
#          tree_id_non_unique, test,
#          max_nr_parts_coppice,
#          x_local, y_local,
#          period,
#          species,
#          alive_dead, intact_snag, ind_sht_cop, decaystage,
#          dbh_mm, height_m, calc_height_m, vol_tot_m3
#          )

tree_id <- tree_id_ %>% 
  select(-test, -max_nr_parts_coppice)

names(tree_id)
```


Controle: zie `Datacontrole7_coppice_id.Rmd`
(dataframe ter controle opslaan in C:\03_BR\1_DataVerwerkingBR\RData)

Hier verder gaan met wat is ....

```{r save_RData_ter_controle}
save(tree_data_OldID, tree_data_CoppID, tree_id, file = here::here("RData/controle_CoppID.Rdata"))
# load(here::here("RData/controle_CoppID.Rdata"))
```



## Op spilniveau

**!! OPGEPAST !! **

Tree-id wordt overgenomen van boomniveau, aangemaakt via `old_id` of `coppice_id` afhankelijk van "delen" hakhout (zie hoger).

```{r copy_tree_id, results = 'hide'}
names(data_stems_calc)
names(tree_id)
tree_id %>%  filter(is.na(tree_id)) %>% nrow() == 0
data_stems_calc %>% filter(tree_measure_id == 0) %>% nrow() 

tree_id_ <- tree_id %>% 
  select(plot_id, tree_measure_id, tree_id, tree_id_non_unique, period)
# tree_id_ <- tree_id %>% 
#   select(plot_id, tree_measure_id, tree_id, period)

stem_id <- data_stems_calc %>% 
  filter(tree_measure_id != 0) %>% 
  left_join(tree_id_, by = c("plot_id", "tree_measure_id", "period"))

names(stem_id)
nrow(stem_id) == nrow(data_stems_calc)

# 1 meer wegens een tree_measure_id == 0 in KV Jansheide (101000)
data_stems_calc %>% filter(tree_measure_id == 0)
```

```{r check_id_hakhout, eval=FALSE, results = 'hide'}
stem_id %>% filter(is.na(tree_id)) %>% nrow() == 0
# 0
stem_id %>% filter(is.na(tree_id)) %>% select(plot_id, period)


tree_id_hakhout <- stem_id %>% 
  group_by(plot_id, tree_measure_id, period) %>% 
  summarize(aantal = n()) %>% 
  ungroup()

table(tree_id_hakhout$aantal)
```


# Op boomniveau: wijde tabel met één record per boom doorheen de tijd

Om één record per boom te verkrijgen met info uit beide periodes, dient functie "make_table_wide" gebruikt te worden.
Dit werkt enkel bij een unieke tree_id.
**DAAROM: tijdelijk verwijderen van deze met een dubbele tree-id**

> mail op 12/3/25 naar Peter om dubbele coppice_id's te checken
(zie G:\Gedeelde drives\Team_Boseco_BR\PRJ_BR_Gegevensverwerking\30_Datacontrole)

Zie hierna:

```{r tree_id_wide_check}
check_dubbele_tree_id <- tree_id %>% 
  group_by(plot_id, tree_id, period, species) %>% 
  summarize(aantal_per_periode = n()) %>% 
  ungroup() %>% 
  filter(aantal_per_periode > 1) 
# %>% inner_join(tree_data_CoppID_check)

check_dubbele_tree_id
# A tibble: 3 x 4
#   plot_id tree_id       period aantal_per_periode
#     <int> <chr>          <dbl>              <int>
# 1   41000 1_41000_164_a      2                  2
# 2   51000 1_51000_4_a        1                  2
# 3   53000 1_53000_258_b      1                  2

```
```{r results='hide'}
check_dubbele_tree_id %>% distinct(plot_id)
# 13 rows

check_dubbele_tree_id2 <- tree_id %>% 
  inner_join(check_dubbele_tree_id) %>% 
  select(plot_id, period, tree_measure_id, old_id, coppice_id,
         tree_id, 
         species, ind_sht_cop,
         dbh_mm, vol_tot_m3, alive_dead)

# exporteren en laten nakijken door Peter
write.xlsx(check_dubbele_tree_id2, 
           file = paste0(path_to_dataverwerking_teamdrive, 
                         "30_Datacontrole/dubbele_coppice_20250311.xlsx"))

write.xlsx(check_dubbele_tree_id2, 
           file = paste0(path_to_dataverwerking,
                         "Data_controle/coppice_id/coppice_id_te_checken_20250311.xlsx"))
```



```{r dubbele_ids_verwijderen}
# TIJDELIJK
tree_id_ <- tree_id %>% 
  anti_join(check_dubbele_tree_id %>%  select(plot_id, tree_id, period))  # tijdelijk de dubbele tree_id's verwijderen
# bevat geen beuk ...

nrow(tree_id_) == nrow(tree_id) - 2*nrow(check_dubbele_tree_id)

tree_id <- tree_id_
```


```{r tree_id_long}
# selectie om wijde tabel aan te maken
tree_id_long <- tree_id %>%
  select(plot_id, period, tree_id, 
         species, ind_sht_cop,
         dbh_mm, vol_tot_m3, alive_dead) %>% 
  arrange(period) %>% 
  left_join(plotinfo %>% select(plot_id, period, survey_number)) %>% 
  select(-period)

# ? survey_number => joinen met plotinfo
```

!!Opgepast: soms daalt dbh doorheen de tijd: dat is het geval bij dode bomen.


```{r tree_id_wide_zonder_dubbele_ids, results='hide'}
tree_id_wide <- make_table_wide(table_long = tree_id_long
                                , column_to_repeat = "survey_number"
                                , columns_for_comparison = 
                                  c("alive_dead", "dbh_mm", "vol_tot_m3"))

names(tree_id_wide)
```
**Jaartal survey's toevoegen**    
Dit jaartal moet uit `plotinfo` gehaald worden, want als boom er niet meer staat (omgevallen), 
is er in de tabel met bomen ook geen `year_dendro` meer voor di eboom en dat jaartal, 
terwijl er wél een opname was.
We nemen voor `survey_Y1` het jaar van de eerste survey voor dat gebied, dus NIET het jaartal van 
de eerste decade/periode van monitoringnetwerk.
Dat is het meest logische (idem als shapefile Marc, zie `strata_location`), maar houdt wel in dat
`survey_Y1` kan varieren van 1986 (old core zoniën) tot 2020 (Kluisbos).

<!-- ! ev. NA bij jaartallen '0' van maken? cfr shapefile Marc? NEE -->
<!-- ? wat met NA's van bomen die er niet meer zijn => moet een getal zijn, anders een probleem -->
<!-- beste om dat toch NA te laten!!! -->
<!-- En andere jaartallen ook NA, anders wordt er mogelijks mee gerekend ... -->

```{r year_survey, results='hide'}
names(plotinfo)

# aantal surveys
n_surveys <- plotinfo %>% 
  group_by(forest_reserve, plot_id, plottype) %>% 
  summarize(n_surveys = n()
            , min_yr = min(year_dendro)
            , max_yr = max(year_dendro)) %>% 
  ungroup()

# jaartallen surveys
plotinfo_long <- plotinfo %>% 
  select(forest_reserve, plot_id, plottype
         , survey_number, year_dendro, survey_trees
         , data_processed)

plotinfo_wide <- make_table_wide(table_long = plotinfo_long
                                , column_to_repeat = "survey_number"
                                , columns_for_comparison = 
                                   c("year_dendro")) %>% 
  rename(survey_Y1 = "1", survey_Y2 = "2", survey_Y3 = "3", survey_Y4 = "4")
names(plotinfo_wide)
# survey_Y1 = jaar van eerste survey voor dat gebied, is meest logische (idem als shapefile Marc, zie strata_location)
```

```{r combine}
tree_survey_wide <- tree_id_wide %>% 
  left_join(plotinfo_wide) %>% 
  left_join(n_surveys)
head(tree_survey_wide)

names(tree_survey_wide)
```

```{r}
tree_survey_wide_ <- tree_survey_wide %>% 
  select(forest_reserve, plot_id, plottype
         , tree_id, species, ind_sht_cop
         , n_surveys
         , contains(c("survey_Y", "alive_dead", "dbh", "vol")))

tree_id_wide <- tree_survey_wide_

```

# Op boomniveau: lange tabel met unieke record per boom doorheen de tijd

Op vraag van Arno ook de "lange" tabel waar `tree_survey_wide` op gebaseerd is, 
exporteren als `trees_unique_id_long`.

Dit is een tabel waar de dubbele/foute tree-id's uit gehaald zijn, zodat men zelf 
een "wijde" tabel kan aanmaken afhankelijk van de onderzoeksvraag.

Volgende velden worden opgenomen:

- forest_reserve, plot_id, plottype
- tree_id
- species, ind_sht_cop
- survey_nr
- decade
- year_dendro

Belangrijk hierbij is te beseffen dat sommige bomen in een bepaalde periode niet 
opgemeten zijn, omdat ze omgevallen zijn.
Voor een volledig beeld moet men deze tabel dus combineren met tabel `plotinfo`. 

```{r results='hide'}
names(tree_id_long)

tree_id_long <- tree_id %>%
  left_join(plotinfo %>% select(forest_reserve, plot_id, period, survey_number, year_dendro)) %>% 
  select(forest_reserve, plot_id, plottype
         , tree_id
         , decade = period, survey_number, year_dendro
         , species, ind_sht_cop, alive_dead
         , dbh_mm, vol_tot_m3) %>% 
  arrange(decade)

# check: max. 4 surveys?
tree_id_long %>% 
  group_by(tree_id) %>% 
  summarize(n = n()) %>% 
  ungroup() %>% 
  filter(n > 4) %>% nrow() == 0

summary(tree_id_long)
  
```

# Export tree level data

- Met unieke en non-unieke (voor hakhout) tree-id én berekende variabelen    
- Enkel processed data   
- Niet alle variabelen geëxporteerd, enkel deze relevant voor de meeste gebruikers    
- Zonder de bomen met dubbele tree-id's (TIJDELIJK) => belangrijk om dit voor gebruik goed te checken 

**Volgende plots zijn niet helemaal correct (wegens één of meerdere dubbele tree-id's): **    

- niet correcte unieke tree-id in `trees_calc`     
- ontbrekende bomen in wijde tabel in `trees_wide` en `trees_unique_id_long`


```{r}
check_dubbele_tree_id %>% distinct(plot_id) %>% as_tibble
```


**Enkele verduidelijkingen:**

- plotarea_ha = de oppervlakte van resp. A3 of A4, afh. van status en diameter van de boom
(of LxB voor kernvlaktes of volledig BR voor andere plottypes) dus NIET de volledige cirkel


```{r trees_less_variables, results='hide'}
names(tree_id)

tree_id_less_var <- tree_id %>% 
  select(-old_id, -r_A1, -r_A2, -r_A3, -r_A4, -contains(c("dbh_min", "core_area_")), -subcirclearea_ha)

tree_id_less_var <- tree_id_less_var %>% 
  select(forest_reserve, plot_id, plottype, 
         period, 
         tree_measure_id, tree_id, tree_id_non_unique, coppice_id, 
         x_local, y_local, 
         species, 
         dbh_mm, height_m, calc_height_m, 
         alive_dead, ind_sht_cop, intact_snag, 
         iufro_hght, iufro_vital, iufro_socia, 
         decaystage, crown_volume_reduction, branch_length_reduction, 
         remark, common_remark, 
         year, date_dendro, 
         subcircle, plotarea_ha, totalplotarea_ha, 
         dbh_class_5cm, 
         nr_of_stems, 
         basal_area_m2, 
         vol_bole_m3, vol_crown_m3, vol_tot_m3, 
         basal_area_alive_m2_ha, basal_area_dead_m2_ha, 
         vol_alive_m3_ha, vol_dead_standing_m3_ha, 
         vol_bole_alive_m3_ha, vol_bole_dead_m3_ha, 
         number_of_trees_alive_ha, number_of_trees_dead_ha
         )

```


```{r save_trees_access_csv, eval = FALSE}
# volgende functies heb ik zelf geschreven, zitten niet in het package!!!
save_results_csv (
    results = list(trees_calc = tree_id_less_var),
    output_dir = path_to_treelevel_csv
    )

# afgerond voor export naar access
tree_id_round <- tree_id_less_var %>% 
  mutate_at(c("calc_height_m"), round, 2) %>% 
  mutate_at(vars(matches("_ha|_m3|_m2")), round, 4)

# save_results_access (
#   results = list(trees_calc = data_dendro_calc_round),
#   database = path_to_analysis_set_db,
#   remove_tables = TRUE
#   )

# Functie "save_results_access" (< package) geeft problemen met dates => hierna manueel

con <- odbcConnectAccess2007(path_to_analysis_set_db)

dbtables <- sqlTables(con)
if ("trees_calc" %in% dbtables$TABLE_NAME) {
        sqlDrop(con, "trees_calc")
      }
sqlSave(con, dat = tree_id_round, tablename = "trees_calc", varTypes = c(date_dendro="datetime"), fast = FALSE)

odbcClose(con)
```


```{r save_trees_wide_access_csv, eval = FALSE}
# volgende functies heb ik zelf geschreven, zitten niet in het package!!!
save_results_csv (
    results = list(trees_wide = tree_id_wide),
    output_dir = path_to_treelevel_csv
    )

# afgerond voor export naar access
tree_id_wide_round <- tree_id_wide %>% 
  # mutate_at(c("calc_height_m"), round, 2) %>% 
  mutate_at(vars(matches("_ha|_m3|_m2")), round, 4)

save_results_access (
  results = list(trees_wide = tree_id_wide_round),
  database = path_to_analysis_set_db,
  remove_tables = TRUE
  )

```


```{r save_trees_unique_id_long_access_csv, eval = FALSE}
# volgende functies heb ik zelf geschreven, zitten niet in het package!!!
save_results_csv (
    results = list(trees_unique_id_long = tree_id_long),
    output_dir = path_to_treelevel_csv
    )

# afgerond voor export naar access
tree_id_long_round <- tree_id_long %>% 
  # mutate_at(c("calc_height_m"), round, 2) %>% 
  mutate_at(vars(matches("_ha|_m3|_m2")), round, 4)

save_results_access (
  results = list(trees_unique_id_long = tree_id_long_round),
  database = path_to_analysis_set_db,
  remove_tables = TRUE
  )

```


Direct naar gdrive exporteren (csv): 
naar **/PRJ_BOSECO_ALGEMEEN/PRJ_BR_AanvraagGegevens/!METADATA-ALL_PLOTS/_tree-level-data/**

```{r save_trees_gdrive, eval = FALSE}
save_results_csv(
    results = list(trees_calc = tree_id_less_var),
    output_dir = path_to_treelevel_gdrive
    )

save_results_csv(
    results = list(trees_wide = tree_id_wide),
    output_dir = path_to_treelevel_gdrive
    )

save_results_csv(
    results = list(trees_unique_id_long = tree_id_long),
    output_dir = path_to_treelevel_gdrive
    )

```


# Export stem level data

Met unieke en non-unieke (voor hakhout) tree-id (uniek op boomniveau, niet op spilniveau) én berekende variabelen.

**!! OPGEPAST !!**
Unieke en non-unieke (voor hakhout) tree-id overgenomen van trees berekend op boomniveau.

<!--  na 16/2/2022: voor hakhout met meer dan twee delen: tree-id obv coppice-id (zie hoger) -->

Niet alle variabelen mee exporteren, enkel deze relevant voor de meeste gebruikers


Volgende plots zijn (NOG) niet helemaal correct (wegens één of meerdere dubbele tree-id's):   

- niet correcte unieke tree-id in `stems_calc`     
- ontbrekende bomen in wijde tabel in `stems_wide`

```{r}
check_dubbele_tree_id %>% distinct(plot_id) %>% as.tibble
```

```{r stems_less_variables}
stem_id_less_var <- stem_id %>% 
  select(-old_id, -r_A1, -r_A2, -r_A3, -r_A4, -contains(c("dbh_min", "core_area_")), -subcirclearea_ha)
## stemnumber_alive werd weggefilterd

stem_id_less_var <- stem_id_less_var %>% 
  select(forest_reserve, plot_id, plottype, 
         period, 
         tree_measure_id, shoot_measure_id, 
         tree_id, tree_id_non_unique, coppice_id, 
         x_local, y_local, 
         species, 
         dbh_mm, height_m, calc_height_m, 
         alive_dead, ind_sht_cop, intact_snag, 
         iufro_hght, iufro_vital, iufro_socia, 
         decaystage, crown_volume_reduction, branch_length_reduction, 
         remark, common_remark, 
         year, date_dendro, 
         subcircle, plotarea_ha, totalplotarea_ha, 
         dbh_class_5cm, 
         basal_area_m2, 
         vol_bole_m3, vol_crown_m3, vol_tot_m3, 
         basal_area_alive_m2_ha, basal_area_dead_m2_ha, 
         vol_alive_m3_ha, vol_dead_standing_m3_ha, 
         vol_bole_alive_m3_ha, vol_bole_dead_m3_ha, 
         stem_number_dead_ha, stem_number_alive_ha
         )

```


```{r save_stems_access_csv, eval = FALSE}
# volgende functies heb ik zelf geschreven, zitten niet in het package!!!
save_results_csv (
    results = list(stems_calc = stem_id_less_var),
    output_dir = path_to_treelevel_csv
    )

# afgerond voor export naar access
stem_id_round <- stem_id_less_var %>% 
  # mutate_at(c("calc_height_m"), round, 2) %>% 
  mutate_at(vars(matches("_ha|_m3|_m2")), round, 4)

# save_results_access (
#   results = list(trees_calc = data_dendro_calc_round),
#   database = path_to_analysis_set_db,
#   remove_tables = TRUE
#   )

# Functie "save_results_access" (< package) geeft problemen met dates => hierna manueel

con <- odbcConnectAccess2007(path_to_analysis_set_db)

dbtables <- sqlTables(con)
if ("stems_calc" %in% dbtables$TABLE_NAME) {
        sqlDrop(con, "stems_calc")
      }
# sqlSave(con, dat = stem_id_round, tablename = "stems_calc", varTypes = c(date_dendro="datetime"))
sqlSave(con, dat = stem_id_round, tablename = "stems_calc", varTypes = c(date_dendro="datetime"), fast = FALSE)

odbcClose(con)
```

Direct naar gdrive exporteren (csv): 
naar **/PRJ_BOSECO_ALGEMEEN/PRJ_BR_AanvraagGegevens/!METADATA-ALL_PLOTS/_tree-level-data/**

```{r save_stems_gdrive, eval = FALSE}
save_results_csv(
    results = list(stems_calc = stem_id_less_var),
    output_dir = path_to_treelevel_gdrive
    )

```



# Copy html to teamdrive

Na knitting - manueel

```{r eval = FALSE}
# Specify the path of the file you want to copy
source_file <- here::here(paste0("Scripts/OpbouwDatabank/Main_UpdateForresdat_03_treeniveau.html"))

# Specify the destination directory where you want to copy the file
destination_dir <- path_to_html_teamdrive

# Copy the file to the destination directory
file.copy(from = source_file, to = destination_dir, overwrite = TRUE)
# ? file.copy
```

