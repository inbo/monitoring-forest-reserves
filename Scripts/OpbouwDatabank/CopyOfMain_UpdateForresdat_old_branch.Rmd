---
title: "Update forresdat"
author: "Anja Leyman"
date: "`r Sys.Date()`"
output: 
  html_document:
    keep_md: FALSE
    number_sections: yes
    fig_caption: yes
    code_folding: hide
    toc: TRUE
    toc_float:
      collapsed: yes
      smooth_scroll: yes
---

DOEL van dit script is een update van forresdat gegevens naar github.

- 21/2/2022: update nalv correctie coppice-id (+ kleine aanpassing plotinfo)
=> enkel tree level data & plotinfo bijgewerkt 

- 8/3/2022: update dendro nalv nieuwe dh-curves Zonien (Kerss CP&KV, Zwaenep CP, Harras KV) - 
obv branch "statistics_and_other_issues".
- 9/3/2022: ook tree-id toegevoegd, functie was nog niet in orde, maar licht aangepast


```{r Rm, eval = FALSE}
rm(list=ls())
```

```{r Setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  eval = FALSE,
  message = FALSE,
  warning = FALSE, 
  fig.width = 9,
  fig.align = TRUE)

library(here)

# libraries & invoergegevens
source(here::here("scripts/Setup.R"))

```

# Update lookuplijsten - EVENTUEEL

Enkel indien de q-tabellen gewijzigd zijn.
Enkel de gewijzigde tabellen vermelden.

## Input from access fieldmap

```{r lulist1, eval = FALSE}
from_access_to_git(
  database = path_to_fieldmap_db,
  tables = c("qAliveDead", "qSpecies", "qHerbSpecies240810", "qHeightClass_regeneration", "qnumber_regeneration_classes", "qdecaystage",
             "qcommenremark", "qiufrosocialstatus", "qiufroheight", "qiufrovitality", "qBrowsIndex",
             "qPlotType", "qIntactSnag", "qIndShootCop"),
  repo_path = path_to_git_forresdat #,
  # strict = FALSE
)

# !!!! argument "strict": keep default TRUE to update data without structural changes,
                  #    change to FALSE only if tables are structurally changed
                  #          (e.g. additional column, change in sorting order,...)


from_access_to_git(
  database = path_to_fieldmap_db,
  tables = c("qCrownVolRedu","qBranchLenghtReduction"),
  repo_path = path_to_git_forresdat,
  strict = FALSE
)

from_access_to_git(
  database = path_to_fieldmap_db,
  tables = c("qCoverHerbs"),
  repo_path = path_to_git_forresdat,
  strict = FALSE
)

```


## Save in analysis database

```{r lulist2, eval = FALSE}
from_git_to_access(tables = c("qAliveDead", "qSpecies", "qHerbSpecies240810", "qHeightClass_regeneration", "qnumber_regeneration_classes", "qdecaystage",
                              "qcommenremark", "qiufrosocialstatus", "qiufroheight", "qiufrovitality", "qBrowsIndex",
                              "qPlotType", "qIntactSnag", "qIndShootCop"),
                   repo_path = path_to_git_forresdat,
                   database = path_to_analysis_set_db)

from_git_to_access(tables = c("qCrownVolRedu","qBranchLenghtReduction"),
                   repo_path = path_to_git_forresdat,
                   database = path_to_analysis_set_db)

# lookuplijsten niet als csv of xls geëxporteerd, want teveel rompslomp, zit in de access-db

```


## Als git niet werkt ...

```{r lulist_manueel, eval = FALSE}
# inladen
con <- odbcConnectAccess2007(path_to_fieldmap_db)

qBrowsIndex <- sqlFetch(con, "qBrowsIndex")
qCoverHerbs <- sqlFetch(con, "qCoverHerbs")

odbcClose(con)

# exporteren - access & csv
save_results_access (
  results = list(qCoverHerbs = qCoverHerbs),
  database = path_to_analysis_set_db,
  remove_tables = TRUE
)

save_results_csv(
    results = list(qCoverHerbs = qCoverHerbs),
    output_dir = path_to_analysis_set_csv
  )


# exporteren - tsv - eigen simpele functie
save_results_tsv(list(qCoverHerbs = qCoverHerbs), 
                 root = path_to_forresdat_data)
```


```{r lkplists_to_csv, eval = FALSE}
con <- odbcConnectAccess2007(path_to_fieldmap_db)

  qIndShootCop <- sqlFetch(con, "qIndShootCop", stringsAsFactors = FALSE)
  qAliveDead <- sqlFetch(con, "qAliveDead", stringsAsFactors = FALSE)
  qSpecies <- sqlFetch(con, "qAliveDead", stringsAsFactors = FALSE)
  qDecaystage <- sqlFetch(con, "qdecaystage", stringsAsFactors = FALSE)
  qIntactSnag <- sqlFetch(con, "qIntactSnag", stringsAsFactors = FALSE)
    
  qCrownVolRedu <- sqlFetch(con, "qCrownVolRedu", stringsAsFactors = FALSE)
  qBranchLenghtReduction <- sqlFetch(con, "qBranchLenghtReduction", stringsAsFactors = FALSE)

  qiufroheight <- sqlFetch(con, "qiufroheight", stringsAsFactors = FALSE)
  qiufroheight_shoots <- sqlFetch(con, "qiufroheight_shoots", stringsAsFactors = FALSE)
  qiufrovitality <- sqlFetch(con, "qiufrovitality", stringsAsFactors = FALSE)
  qiufrovitality_shoots <- sqlFetch(con, "qiufrovitality_shoots", stringsAsFactors = FALSE)
  qiufrosocialstatus <- sqlFetch(con, "qiufrosocialstatus", stringsAsFactors = FALSE)
  qiufrosocialstatus_shoots <- sqlFetch(con, "qiufrosocialstatus_shoots", stringsAsFactors = FALSE)
  
odbcClose(con)


# list maken van alle lookuplijsten en als csv opslaan
list_lkp <- list(qIndShootCop = qIndShootCop, qAliveDead = qAliveDead, qSpecies = qSpecies, 
                 qDecaystage = qDecaystage, qIntactSnag = qIntactSnag, 
                 qCrownVolRedu = qCrownVolRedu, qBranchLenghtReduction = qBranchLenghtReduction,
                 qiufroheight = qiufroheight, qiufroheight_shoots = qiufroheight_shoots,
                 qiufrosocialstatus = qiufrosocialstatus, 
                 qiufrosocialstatus_shoots = qiufrosocialstatus_shoots,
                 qiufrovitality = qiufrovitality, 
                 qiufrovitality_shoots = qiufrovitality_shoots)

names(list_lkp)

save_results_csv(
    results = list_lkp,
    output_dir = path_to_analysis_set_csv
  )

```




# Plotinfo - OK - 09/3/2022

## Load plotinfo

Plotinfo samenstellen, zijnde plottype, naam forest_reserve en info over survey en data al dan niet processed.
Wegschrijven naar git, access en opslaan als csv

```{r plotinfo_load}
plotinfo <- load_plotinfo(database = path_to_fieldmap_db)

```

Aangezien het package nog niet overweg kan met 1986 (branch `statistics-and-other-issues` vangt dit op, maar nog niet gemerged).
Hierna code om deze plotinfo extra in te laden. 

!! niet zo mooi, nu enkel kopie van code uit `aanmaakdhcurves Kerss` geplaatst

```{r plotdetails_1986, eval = FALSE}
con <- odbcConnectAccess2007(path_to_fieldmap_db)

tables_fieldmap <- sqlTables(con) %>% filter(!str_detect(TABLE_NAME, "MSys"))

PlotDetails_1986 <- sqlFetch (con, "PlotDetails_1986", stringsAsFactors = TRUE) %>% 
  mutate(period = 0) %>% 
  rename(Date_Dendro = Date_Dendro_1986,
         FieldTeam_Dendro = FieldTeam_Dendro_1eSet) %>% 
  select(-FieldStatus)
PlotDetails_1eSet <- sqlFetch (con, "PlotDetails_1eSet", stringsAsFactors = TRUE) %>% 
  mutate(period = 1) %>% 
  rename(Date_Dendro = Date_Dendro_1eSet,
         FieldTeam_Dendro = FieldTeam_Dendro_1eSet) %>% 
  select(-FieldStatus)
PlotDetails_2eSet <- sqlFetch (con, "PlotDetails_2eSet", stringsAsFactors = TRUE) %>% 
  mutate(period = 2) %>% 
  rename(Date_Dendro = Date_Dendro_2eSet,
         FieldTeam_Dendro = FieldTeam_Dendro_2eSet) %>% 
  select(-FieldStatus)
PlotDetails_3eSet <- sqlFetch (con, "PlotDetails_3eSet", stringsAsFactors = TRUE) %>% 
  mutate(period = 3) %>% 
  rename(Date_Dendro = Date_Dendro_3eSet,
         FieldTeam_Dendro = FieldTeam_Dendro_3eSet) %>% 
  select(-FieldStatus)

odbcClose(con)

# tables_fieldmap %>% filter(str_detect(TABLE_NAME, "PlotDet"))

# names(PlotDetails_1986)
# names(PlotDetails_1eSet)
# names(PlotDetails_2eSet)
# names(PlotDetails_3eSet)

plotDetails <- rbind(PlotDetails_1986, PlotDetails_1eSet, PlotDetails_2eSet, PlotDetails_3eSet)

# colnames(PlotDetails_1eSet) == colnames(PlotDetails_2eSet)
# nrow(plotDetails) == nrow(PlotDetails_1eSet) + nrow(PlotDetails_1986) + nrow(PlotDetails_2eSet) + nrow(PlotDetails_3eSet)

names(plotDetails)

# n_distinct(plotDetails$plot_id)

plotdetails_ <- plotDetails %>% 
  mutate(year = year(round_date(.data$Date_Dendro, "year")) - 1, 
         survey_trees = ifelse(.data$Survey_Trees_YN == 10 & !is.na(.data$Survey_Trees_YN), TRUE, FALSE),
          survey_deadw = ifelse(.data$Survey_Deadwood_YN == 10 & !is.na(.data$Survey_Deadwood_YN), TRUE, FALSE),
          survey_veg = ifelse(.data$Survey_Vegetation_YN == 10 & !is.na(.data$Survey_Vegetation_YN), TRUE, FALSE),
          survey_reg = ifelse(.data$Survey_Regeneration_YN == 10 & !is.na(.data$Survey_Regeneration_YN), TRUE, FALSE),
          data_processed = ifelse(.data$DataProcessed_YN == 10 & !is.na(.data$DataProcessed_YN), TRUE, FALSE)
           ) %>% 
  rename(CoreArea_ha = Area_ha) %>% 
    select(plot_id = IDPlots, forest_reserve = ForestReserve, period, year,
           Date_Dendro, 
           contains("survey"), data_processed,
         rA1_m = rA1, rA2_m = rA2, rA3_m = rA3, rA4_m = rA4, 
         TresHoldDBH_A3_alive_mm = TresHoldDBH_Trees_A3_alive, 
         TresHoldDBH_A3_dead_mm = TresHoldDBH_Trees_A3_dead, 
         TresHoldDBH_A4_alive_mm = TresHoldDBH_Trees_A4_alive, 
         TresHoldDBH_A4_dead_mm = TresHoldDBH_Trees_A4_dead, 
         TresHoldDBH_CoreArea_dead_mm = TresHoldDBH_Trees_CoreArea_dead, 
         TresHoldDBH_CoreArea_alive_mm = TresHoldDBH_Trees_CoreArea_alive, 
         TresHoldDiam_Deadw_A4_mm = TresHoldDiam_Deadwood_A4,
         TresHoldDiam_Deadw_CoreArea_mm = TresHoldDiam_Deadwood_CoreArea,
         contains("Area"),
         -contains("YN")
         )
```


```{r vgl_plotinfo_plotdetails, eval=FALSE}
names(plotdetails_)
names(plotinfo)
nrow(plotdetails_)
nrow(plotinfo)

# plotdetails: geen info over survey-number en plottype
plotdetails_ <- plotdetails_ %>% 
  select(plot_id, forest_reserve, contains("survey"), data_processed,
         period, year)

# extra: BR Kerss 1986
extra_plotdetails <- plotdetails_ %>% 
  anti_join(plotinfo, by = c("plot_id", "period")) %>% 
  mutate(plottype = "CA",
         survey_number = 0)

extra_plotdetails

```

Initieel extra plotinfo 1986 toegevoegd aan plotinfo, maar deze branch voegt year NIET toe aan plotinfo 
Daarom toch beter zelf obv plotdetails.
Maar dan zit survey_number er niet bij ...
Dus eerst joinen


```{r join_year}
plotinfo_ <- plotinfo %>% 
  left_join(plotdetails_ %>% select(plot_id, period, year), by = c("plot_id", "period"))
```



```{r add_plotinfo_1986, eval = FALSE}
# samenvoegen
plotinfo_ <- rbind(plotinfo_, extra_plotdetails) 

# aanpassen survey_numbers Kerss KV
plotinfo_ <- plotinfo_ %>% 
  mutate(survey_number = ifelse(plot_id == 11000, survey_number + 1, survey_number)) %>% 
  rename(year_dendro = year)

# OK
plotinfo <- plotinfo_

```


```{r plotinfo_processed}
# enkel checken bij deze waar er een dendro-opname gebeurd is
check_processed <- plotinfo %>% 
  filter(survey_trees == TRUE)

table(check_processed$forest_reserve, check_processed$data_processed)

```


```{r plotinfo_corr_processed, eval = FALSE}
# plotinfo_ <- plotinfo %>%
#   mutate(data_processed = ifelse(forest_reserve %in% c("Kersselaerspleyn", "Zwaenepoel")  & survey_trees == TRUE & period == 3, TRUE, data_processed))
# 
# test <- plotinfo_ %>% 
#   filter(forest_reserve %in% c("Kersselaerspleyn", "Zwaenepoel")  & survey_trees == TRUE & period == 3)
# 
# plotinfo <- plotinfo_

```

## Export plotinfo

```{r plotinfo_save_git, eval=FALSE}
save_results_git(
  results = list(plotinfo = plotinfo)
  , repo_path = path_to_git_forresdat
  , strict= FALSE
)

```

```{r plotinfo_save_git_manueel, eval=FALSE}
# manueel - eigen simpele functie - als save_results_git niet werkt
save_results_tsv(list(plotinfo = plotinfo), 
                 root = path_to_forresdat_data, 
                 strict = FALSE)

```


```{r plotinfo_save_access_csv, eval=FALSE}
save_results_access (
  results = list(plotinfo = plotinfo),
  database = path_to_analysis_set_db,
  remove_tables = TRUE
)

save_results_csv(
    results = list(plotinfo = plotinfo),
    output_dir = path_to_analysis_set_csv
  )

```


# Dendro - OK - 09/3/2022

## Load dendro data

```{r load_dendro_1}
data_dendro <- load_data_dendrometry(database = path_to_fieldmap_db, extra_variables = TRUE)

# data_shoots <- load_data_shoots(database = path_to_fieldmap_db, extra_variables = TRUE)
data_shoots <- load_data_shoots(database = path_to_fieldmap_db)

```


<!-- Aangezien het package nog niet overweg kan met 1986, hierna code om deze data extra in te laden.  -->

Er zijn geen shoots, en ook geen deadwood, reg of veg in Kerss KV 1986

```{r load_data_1986, eval = FALSE}
# path_to_moederdb <- "C:/03_BR/8_Moederdatabank_tmp/MDB_BR_X8_inbo2020/FieldMapData_MDB_BR_X8_inbo2020.accdb"

# trees_1986 <- load_data_dendrometry_1986(database = path_to_fieldmap_db) 

# shoots_1986: leeg, geen shoots
```

```{r rbind_trees_1986, eval = FALSE}
# names(trees_1986)
# names(data_dendro)
# 
# trees_1986_ <- trees_1986 %>% 
#   select(-X_m, -Y_m) %>% 
#   mutate(subcircle = NA,
#          subcirclearea_ha = NA)  # core area
# names(trees_1986_)
# 
# data_dendro_ <- rbind(data_dendro, trees_1986_)
# 
# nrow(data_dendro) + nrow(trees_1986_) == nrow(data_dendro_)
# 
# data_dendro <- data_dendro_
```


```{r load_dendro_2}
data_stems  <- compose_stem_data(data_dendro, data_shoots)

height_model <- load_height_models(path_to_height_models)

data_deadwood <- load_data_deadwood(database = path_to_fieldmap_db)

```


## Calculate dendro data

```{r calc_dendro}
data_stems_calc <- calc_variables_stem_level(data_stems, height_model)

data_dendro_calc <- calc_variables_tree_level(data_dendro, data_stems_calc)

dendro <- calculate_dendrometry(data_dendro, data_deadwood, data_shoots, height_model)
```

```{r join_plotinfo}
dendro_plotinfo <- lapply(dendro, function(x) left_join(x, plotinfo %>% select(plot_id, forest_reserve, plottype, period, survey_number), by = c("plot_id", "period")))
# lapply: same function over all elements of the list
```

No deadwood survey wordt nu opgevangen door extra parameter in de `load_data_xxx`-functies, nl. `data_processed = TRUE`.
Dit wordt in de code van de functie uitgebreid met `xxx_survey = TRUE`.


## Controle plot-level-data

```{r CreateSeparateDataframesDendro}
for (tablename in names(dendro)) {
     assign(tablename, dendro[[tablename]])
} 

```


## Export plot-level-data

!!!! ENKEL PLOTS EXPORTEREN WAARVAN DATA PROCESSED ZIJN!!
!! zorgen dat dit up-to-date is, zie chunck "plotinfo_corr_processed"

Issue #58: afgesproken met Els dat standaard enkel processed_data ingeladen worden bij load_data
==> ook bij de dataverwerking enkel deze data mee
  IS OK, opgelost in branch `statistic_and_other_issues`

 
Enkele verduidelijkingen:

* "number_of_tree_species" = aantal soorten obv de levende bomen

* "stems_per_tree" = meerstammigheid (stem_number_ha / number_of_trees_ha): heeft hier geen zin, maar dient als insteek voor berekeningen per soort

* "vol_bole_alive_m3_ha" en "vol_bole_dead_m3_ha": volume zonder crown, 
versus "vol_alive_m3_ha" en "vol_dead_standing_m3_ha"

* "vol_log_m3_ha": liggend dood hout

* "vol_deadw_m3_ha": staand en liggend dood hout


```{r filter_processed_dendro, eval=FALSE}
# filter processed data - NIET MEER NODIG, reeds bij load_data_xxxx gedaan
# # dendro_plotinfo_ <- dendro_plotinfo %>% 
#   lapply(., function(x) filter(x, data_processed == TRUE))

```


```{r save_dendro_git}
# geen plotinfo naar git
save_results_git(
  results = dendro,
  repo_path = path_to_git_forresdat
)
```

```{r save_dendro_git_manueel, eval = FALSE}
# manueel - eigen simpele functie - als save_results_git niet werkt
save_results_tsv(dendro, 
                 root = path_to_forresdat_data, 
                 strict = FALSE)
```


```{r save_dendro_access_csv}
# volgende functie heb ik zelf geschreven, zit niet in het package!
save_results_csv (
    results = dendro_plotinfo,
    output_dir = path_to_analysis_set_csv
    )

# afgerond voor export naar access
dendro_round <- dendro_plotinfo %>% 
  lapply(., function(x) round_df(x, 2))

save_results_access (
  results = dendro_round,
  database = path_to_analysis_set_db,
  remove_tables = TRUE
  )

```


## Create unique tree-id

`Data_dendro_calc` bevat een unieke `tree_id` per boom (die constant blijft doorheen de tijd),
verschillend van de `tree_measure_id` uit fieldmap, die wel varieert doorheen de tijd..

Deze `tree_id` wordt in het package aangemaakt obv old_id.

**OPGEPAST**
Bij hakhout kan/kon dit soms tot gemiste linken leiden. 
(zie ook "TreeMortalityData_DetailHakhout.Rmd")

Hakhoutstoven worden opgesplitst in een levend en dood deel, 
en elk deel wordt dan als een afzonderlijke boom beschouwd 
(een boom kan immers niet én levend én dood tegelijk zijn)

OldID wordt standaard toegekend aan het levende deel van de hakhoutstoof.
Het dode deel wordt gelinkt via CoppiceID.
Indien er enkel een dood deel is (en geen levend deel), dan wordt daar OldID aan toegekend.

Dat wil zeggen dat er zich enkel een probleem stelt wanneer er in één van de 
twee periodes zowel een levend als een dood deel voorkomt.
In de andere gevallen is de koppeling die gebeurt via OldID correct.

**OPLOSSING**
Daarom wordt in code hierna voor hakhout dat in één van de 
twee periodes uit zowel een levend als een dood deel bestaat, de tree_id bepaald obv coppice_id.

Voor de 11 verwerkte CP's + KV Muizenbos is die koppeling gecheckt en OK bevonden.

Dit houdt in dat tree_id niet meer uniek is per periode.
Dat geeft dan weer problemen wanneer we er een "wijde" tabel van willen maken.

Daarom wordt er een _a of _b toegevoegd, afh. of het om levend of dood deel van een hakhoutstoof gaat.
Indien we toch één ID per hakhout willen, ongeacht levend/dood, dan kunnen we makkelijk de _a en _b verwijderen (= `tree_id_non_unique`).


### Op boomniveau - obv old-id

De branch `statistics_and_other_issues` heeft een manier gevonden om tree-id te berekenen, ook voor 4 decades. 
Staat nog niet helemaal op punt, maar kan al berekend worden.
Zie `test_create_unique_treeid_2022-03-09.R` voor de berekening.

Op 9/3/2022 gedaan en zo export ...

```{r mbv_oldid_obv_package, eval = FALSE}
tree_id <- create_unique_tree_id(data_dendro = data_dendro_calc_)
# Deze tabel wordt NIET bewaard in forresdat (daar enkel geaggregeerde resultaten op plotniveau)

# check
tree_id %>% filter(is.na(tree_id)) %>% nrow()
tree_id_missing <- tree_id %>% filter(is.na(tree_id))
table(tree_id_missing$forest_reserve, tree_id_missing$period)

# selectie om wijde tabel aan te maken
tree_id_long <- tree_id %>%
  select(plot_id, species, tree_id, period, dbh_mm, vol_tot_m3, alive_dead)

```


```{r mbv_oldid_zelf, eval = FALSE}
test_data <- data_dendro_calc

### functie uitgesplitst ----------
status_tree <- test_data %>%
    mutate(
      tree_id =
        ifelse(
          is.na(.data$old_id),
          paste(.data$period, .data$plot_id, .data$tree_measure_id, sep = "_"),
          NA
        )
    )

# dataset <- status_tree %>% filter(is.na(tree_id))
dataset <- status_tree

# lookup_tree_id <- function(dataset) {
    # if (any(is.na(dataset$tree_id))) {
      dataset_ <- dataset %>%
        left_join(
          dataset %>%
            transmute(
              .data$plot_id, .data$tree_measure_id, .data$tree_id, .data$old_id,
              period = .data$period + 1
            ) %>%
            filter(!is.na(.data$tree_id)) %>%
            distinct(),
          by = c("plot_id", "old_id" = "tree_measure_id", "period"),
          suffix = c("", "_oldid")  # _oldid bij deze die al een tree_id hadden
        ) %>%
        mutate(
          tree_id =
            ifelse(
              is.na(.data$tree_id),
              .data$tree_id_oldid,
              .data$tree_id
            )
        ) %>%
        select(-.data$tree_id_oldid, -.data$old_id_oldid)
      # dataset <- lookup_tree_id(dataset)
    # }

  
t <- dataset %>%
  # transmute does not retain our original data
  transmute(
    .data$plot_id, .data$tree_measure_id, .data$tree_id, .data$old_id,
    period = .data$period + 1  # want we willen die koppelen aan de volgende periode
                                # by = c("plot_id", "old_id" = "tree_measure_id", "period")
  ) %>%
  filter(!is.na(.data$tree_id)) %>%
  distinct()
  
# je moet dat inderdaad 2 x na elkaar doen!!
  
### 2de keer -------
dataset__ <- dataset_ %>%
  left_join(
    dataset_ %>%
      transmute(
        .data$plot_id, .data$tree_measure_id, .data$tree_id, .data$old_id,
        period = .data$period + 1
      ) %>%
      filter(!is.na(.data$tree_id)) %>%
      distinct(),
    by = c("plot_id", "old_id" = "tree_measure_id", "period"),
    suffix = c("", "_oldid")  # _oldid bij deze die al een tree_id hadden
  ) %>%
  mutate(
    tree_id =
      ifelse(
        is.na(.data$tree_id),
        .data$tree_id_oldid,
        .data$tree_id
      )
  ) %>%
  select(-.data$tree_id_oldid, -.data$old_id_oldid)


### 3de keer -----
dataset_finaal <- dataset__ %>%
  left_join(
    dataset__ %>%
      transmute(
        .data$plot_id, .data$tree_measure_id, .data$tree_id, .data$old_id,
        period = .data$period + 1
      ) %>%
      filter(!is.na(.data$tree_id)) %>%
      distinct(),
    by = c("plot_id", "old_id" = "tree_measure_id", "period"),
    suffix = c("", "_oldid")  # _oldid bij deze die al een tree_id hadden
  ) %>%
  mutate(
    tree_id =
      ifelse(
        is.na(.data$tree_id),
        .data$tree_id_oldid,
        .data$tree_id
      )
  ) %>% 
  select(-.data$tree_id_oldid, -.data$old_id_oldid)

# Controle
dataset_finaal %>% filter(is.na(tree_id)) %>% nrow()
tree_id_missing <- dataset_finaal %>% filter(is.na(tree_id))
table(tree_id_missing$forest_reserve, tree_id_missing$period)

# FINAAL
tree_id <- dataset_finaal %>% 
  select(contains("id"), everything())
```


### Op boomniveau - obv coppice-id

**EVENTUEEL EXTRA TOEVOEGEN**  
> 21/2/2022: link obv coppice-id, want dat wordt veel gevraagd.
> Zie ook `Euforia_TreePlotData_Flanders_Olalla_2022-01-13.Rmd`.

Uitsplitsen van hakhoutstoven in dood en levend deel is nodig, want een "tree" kan niet zowel levend als dood zijn.
Bovendien kan een `oldID` niet aan twee "trees" toegekend worden, omdat er anders problemen ontstaan met de koppeling die gebaseerd is op OldID (moet een één-op-één relatie zijn tussen de 2 periodes).

In de databank wordt OldID standaard toegekend aan het levende deel van de hakhoutstoof.   
Het dode deel wordt gelinkt via CoppiceID.   
Indien er enkel een dood deel is (en geen levend deel), dan wordt daar OldID aan toegekend.   

Dus bij de hakhoutstoven die (in eenzelfde periode) uit een levend en dood deel bestaan, hebben de twee delen niet dezelfde oldID, maar wel dezelfde coppice_id.    

Dat wil zeggen dat er zich enkel een probleem stelt wanneer er in één van de twee periodes zowel een levend als een dood deel voorkomt.   
In de andere gevallen kan de koppeling gebeuren via OldID.   

Zo werken we dan ook:  

- 2 delen: koppeling via OldID
- 3 of 4 delen: koppeling via CoppiceID  

In kader van het TreeMortality project hebben we nog een extra onderscheid gemaakt tss levend en dood deel van een hakhoutstoof, door _a en _b toe te voegen voor resp. levend of dood deel van een stoof.
Dat was toen nodig omdat we extra records "fallen" toe moesten voegen voor het dood hout dat er niet meer was.

Dat is ook nodig wanneer we er ooit een "wijde" tabel van willen maken.

Het is echter niet zeker dat dat een correcte link is, want beide delen lopen als het ware in elkaar over. 
Bv. - periode 1 levend gekoppeld aan periode 2 levend
    - periode 1 dood gekoppeld aan periode 2 dood
--> mogelijks zijn er van de levende wat extra dood gegaan, en van de dode wat omgevallen (fallen)
maar dat is niet te bepalen (kan vergeleken worden met dode takken in een boom)
(zie ook `TreeMortalityData_DetailHakhout.Rmd`)

Indien we een correcte link willen, moeten we _a en _b terug verwijderen, met als gevolg dat tree-id géén uniek veld meer is.

> !! controle van die coppice_id nodig obv aantal soorten en afwijking van XY
> reeds gedaan voor de 11 CP's in forresdat op 16/2/2022

Het wordt wel moeilijk wanneer er een derde periode bijkomt, dat moet dan verder bekeken worden, en anders benaderd. Is voor later ...

__Werkwijze:__

* bepalen hoeveel delen er per hakhoutstoof aanwezig zijn

* data opsplitsen:
    (1) een deel waarbij link via OldID behouden blijft (= treeid): **_data_OldID_**
    (individuele bomen en coppice dat uit max. twee delen bestaat over de twee periodes heen)
    (2) een deel waarbij link via CoppiceID gecreëerd wordt (= nieuwe tree_id): **_data_CoppID_**
    (coppice met 3 of meer delen)
 
    
* in data_CoppID de treeid vervangen door period_plotid_coppiceID_a indien levend 
en period_plotid_coppiceID_b indien dood

* samenvoegen van data_OldID, data_CoppID


```{r NumberOfPartsPerCoppice}
tree_id %>% filter(coppice_id > 0) %>% nrow()
# [1] 17224

# coppice_id en plot_id samen uniek => hoeveel metingen zijn er per stoof (max.4 - klopt)
summ_coppice_id <- tree_id %>% 
  filter(coppice_id > 0) %>%
  group_by(coppice_id, plot_id) %>% 
  summarise(aantal = n()) %>% 
  ungroup()
# 9328

table(summ_coppice_id$aantal)
#    1    2    3    4 
# 2877 5194 1077  182 


summ_coppice_id %>% filter(aantal > 4) %>% distinct(plot_id)

summ_coppice_id %>% filter(aantal > 4)

```


```{r SplitDataTrees_OldID_CoppID}
tree_id_  <- tree_id %>% 
  left_join(summ_coppice_id, by = c("plot_id","coppice_id")) %>% 
  mutate (nr_parts_coppice = aantal) %>% 
  select(- aantal) 

str(tree_id_)
str(summ_coppice_id)

tree_data_OldID <- tree_id_ %>% 
  filter (ind_sht_cop != 12 | nr_parts_coppice < 3 | is.na(coppice_id))

tree_data_CoppID <- tree_id_ %>% 
  filter (nr_parts_coppice > 2)

nrow(tree_data_OldID) + nrow(tree_data_CoppID) - nrow(tree_id) == 0
# [1] 0

```

Daar waar coppice uit meer dan twee delen bestaat (over de twee periodes heen), `tree_id` vervangen door een id obv `coppice_id`.

```{r CreateNewTreeID_TreeData_CoppID}
tree_data_CoppID_ <- tree_data_CoppID %>% 
  rename (treeid_old = tree_id) %>% 
  mutate (tree_id = paste(1, plot_id, coppice_id, sep = "_")) %>%
  mutate (tree_id = ifelse(alive_dead == 11, paste(tree_id, "a", sep = "_"),
                          ifelse(alive_dead == 12, paste(tree_id, "b", sep = "_"),
                                 NA)))

names(tree_data_CoppID_)

check_coppID <- tree_data_CoppID_ %>% 
  select(plot_id, 
         tree_id, tree_measure_id, coppice_id,
         nr_parts_coppice,
         x_local, y_local, 
         period, 
         species, 
         alive_dead, intact_snag, ind_sht_cop, decaystage,
         dbh_mm, height_m, calc_height_m, vol_tot_m3
         ) 

tree_data_CoppID <- tree_data_CoppID_
```


```{r Controle_TreeData_OldID}
# str(tree_data_OldID)
nrow(tree_data_OldID)
# [1] 36615
# [1] 75907
# summary(tree_data_OldID)

```


```{r Controle_TreeData_CoppID}
# str(tree_data_CoppID)
nrow(tree_data_CoppID)
# [1] 2038
# [1] 3959
# summary(tree_data_CoppID)

table(tree_data_CoppID$nr_parts_coppice)
#    3    4 
# 3231  728  

tree_data_CoppID_check <- tree_data_CoppID %>% 
  mutate(tree_id_non_unique = ifelse(nr_parts_coppice < 3, tree_id,
                                 str_sub(tree_id, 1, -3)),
         test = (tree_id_non_unique == tree_id)) %>% 
  select(plot_id, 
         tree_id, tree_measure_id, coppice_id, old_id,
         tree_id_non_unique, test,
         nr_parts_coppice,
         x_local, y_local, 
         period, 
         species, 
         alive_dead, intact_snag, ind_sht_cop, decaystage,
         dbh_mm, height_m, calc_height_m, vol_tot_m3
         )
  

# 5 => !! 3 periodes opgemeten  (Hannecart, Rodebos) - ?? Harras?

# !! Kerss en Zwaenepoel en Harras (3 decades): heel weinig coppice => daarom nu nog zo geen probleem
# maar het kan wel dat er nu hakhout is dat er al 3 decades staat (bv. 3x levend), dat via coppice_id gekoppeld wordt ipv via oldID, maar dat is geen probleem
# Beter in die richting een afwijking dan andersom

```

Zijn er geen foute linken obv coppice_id? 

```{r check_XY}
# checken obv XY

check_XY_coppiceid <- tree_data_CoppID_check %>% 
  group_by(plot_id, tree_id_non_unique, coppice_id, x_local, y_local) %>% 
  summarize(aantal_records = n(),
            aantal_soorten = n_distinct(species),
            aantal_statussen = n_distinct(alive_dead)) %>% 
  ungroup() 


verschil_XY_coppiceid <- tree_data_CoppID_check %>% 
  group_by(plot_id, tree_id_non_unique, coppice_id) %>% 
  summarize(aantal_records = n(),
            aantal_soorten = n_distinct(species),
            aantal_statussen = n_distinct(alive_dead),
            x1 = first(x_local), 
            x2 = last(x_local),
            y1 = first(y_local),
            y2 = last(y_local)) %>% 
  ungroup() %>% 
  mutate(verschilX = abs(x1 - x2),
         verschily = abs(y1 - y2)
  ) %>% 
  filter(verschilX > 0.4 | verschily > 0.4)
  # filter(verschilX > 0.2 | verschily > 0.2)
  
nrow(verschil_XY_coppiceid)
# 28

verschil_XY_coppiceid_detail <- tree_data_CoppID_check %>% 
  select(plot_id, tree_id,
         tree_id_non_unique, tree_measure_id, 
         coppice_id, old_id,
         x_local, y_local, 
         period, 
         species, 
         alive_dead, intact_snag, ind_sht_cop, decaystage,
         dbh_mm, height_m, calc_height_m, vol_tot_m3
         ) %>% 
  inner_join(verschil_XY_coppiceid, by = c("plot_id", "tree_id_non_unique", "coppice_id"))
  

#   pivot_wider(names_from = tree_id, values_from = x_local) 
# 
# %>% 
#   rename(individual = "10", coppice = "12") %>% 
#   mutate(perc_hakhout = round(100*coppice/(individual + coppice), ))

```

```{r check_meerdere_soorten}
# verschillende soorten
meerdere_soorten_zelfde_coppice_id <- tree_data_CoppID_check %>% 
  select(-x_local, -y_local) %>% 
  inner_join(check_XY_coppiceid %>% filter(aantal_soorten > 1),
             by = c("plot_id", "tree_id_non_unique", "coppice_id")) %>% 
  select(plot_id, 
         tree_id, tree_id_non_unique, tree_measure_id, 
         coppice_id, old_id,
         x_local, y_local, 
         period, 
         species, 
         alive_dead, intact_snag, ind_sht_cop, decaystage,
         dbh_mm, height_m, calc_height_m, vol_tot_m3
         ) 

meerdere_soorten_zelfde_coppice_id %>% distinct(plot_id)
#   plot_id
# 1   31000   # hannecart
```


```{r te_controleren_door_Peter, eval=FALSE}
write_csv2(meerdere_soorten_zelfde_coppice_id, "Data_controle/nalv_Euforia_2022-02-15/meerdere_soorten_zelfde_coppice_id.csv")

write_csv2(verschil_XY_coppiceid_detail, "Data_controle/nalv_Euforia_2022-02-15/verschil_XY_coppiceid_detail.csv") 

# OK, verzonden op 15/2/2022 naar Peter !! enkel data voor Euforia, niet van KV's of 2109 of 723 of 
# (enkel processed én 2x opgemeten)


write_csv2(meerdere_soorten_zelfde_coppice_id, "Data_controle/meerdere_soorten_zelfde_coppice_id2.csv")

write_csv2(verschil_XY_coppiceid_detail, "Data_controle/verschil_XY_coppiceid_detail2.csv") 
# OK, verzonden op 21/2/2022 naar Peter !! gezegd dat dat geen haast had
# Bevat ook de niet processed data


```

Ik heb zelf de foute coppice-id's in plot 21000 en 2109 al aangepast in mijn dbEls, zodat ik van de BR-en met DH-curves toch correcte output heb.
De rest moet Peter maar op gemak bekijken.


```{r rbind_tree_data_OldID_CoppID}
tree_data_CoppID <- tree_data_CoppID %>% 
  select(-treeid_old)

tree_data_all <- rbind(tree_data_OldID, tree_data_CoppID)

nrow(tree_data_all) == nrow(tree_id)
names(tree_data_all)
names(tree_id)

# check_a_b <- tree_data_all %>% 
#   select(plot_id, 
#          tree_id, tree_measure_id, coppice_id,
#          nr_parts_coppice,
#          x_local, y_local, 
#          period, 
#          species, 
#          alive_dead, intact_snag, ind_sht_cop, decaystage,
#          dbh_mm, height_m, calc_height_m, vol_tot_m3
#          ) %>% 
#   filter(nr_parts_coppice > 2)

tree_id_ <- tree_data_all %>% 
  mutate(tree_id_non_unique = ifelse(nr_parts_coppice < 3 | is.na(nr_parts_coppice), tree_id,
                                 str_sub(tree_id, 1, -3)),
         test = (tree_id_non_unique == tree_id)) 
# %>% 
#   select(plot_id, 
#          tree_id, tree_measure_id, 
#          coppice_id, old_id,
#          tree_id_non_unique, test,
#          nr_parts_coppice,
#          x_local, y_local,
#          period,
#          species,
#          alive_dead, intact_snag, ind_sht_cop, decaystage,
#          dbh_mm, height_m, calc_height_m, vol_tot_m3
#          )

tree_id <- tree_id_ %>% 
  select(-test, -nr_parts_coppice)

names(tree_id)
```


### Op spilniveau

!! OPGEPAST !! 

Tree-id wordt overgenomen van boomniveau, aangemaakt via `old_id` of `coppice_id` afhankelijk van "delen" hakhout (zie hoger).

```{r copy_tree_id}
names(data_stems_calc)
names(tree_id)

tree_id_ <- tree_id %>% 
  select(plot_id, tree_measure_id, tree_id, tree_id_non_unique, period)

stem_id <- data_stems_calc %>% 
  filter(tree_measure_id != 0) %>% 
  left_join(tree_id_, by = c("plot_id", "tree_measure_id", "period"))

names(stem_id)
```

```{r check_id_hakhout, eval=FALSE}
stem_id %>% filter(is.na(tree_id)) %>% nrow()
# 0
stem_id %>% filter(is.na(tree_id)) %>% select(plot_id, period)


tree_id_hakhout <- stem_id %>% 
  group_by(plot_id, tree_measure_id, period) %>% 
  summarize(aantal = n()) %>% 
  ungroup()

table(tree_id_hakhout$aantal)
```


## Op boomniveau: wijde tabel met één record per boom doorheen de tijd

```{r tree_id_long}
# selectie om wijde tabel aan te maken
tree_id_long <- tree_id %>%
  select(plot_id, period, tree_id, 
         species, ind_sht_cop,
         dbh_mm, vol_tot_m3, alive_dead) %>% 
  arrange(period) %>% 
  left_join(plotinfo %>% select(plot_id, period, survey_number)) %>% 
  select(-period)

# ? survey_number => joinen met plotinfo
```

Om één record per boom te verkrijgen met info uit beide periodes, dient functie "make_table_wide" gebruikt te worden.
Dit werkt enkel bij een unieke tree_id.

!!Opgepast: soms daalt dbh doorheen de tijd: dat is het geval bij dode bomen.

```{r tree_id_wide_check}
check_dubbele_tree_id <- tree_id %>% 
  group_by(plot_id, tree_id, period) %>% 
  summarize(aantal_per_periode = n()) %>% 
  ungroup() %>% 
  filter(aantal_per_periode > 1) %>% 
  inner_join(tree_data_CoppID_check)

check_dubbele_tree_id
# A tibble: 3 x 4
#   plot_id tree_id       period aantal_per_periode
#     <int> <chr>          <dbl>              <int>
# 1   41000 1_41000_164_a      2                  2
# 2   51000 1_51000_4_a        1                  2
# 3   53000 1_53000_258_b      1                  2



```

```{r te_controleren_door_Peter2, eval=FALSE}
write_csv2(check_dubbele_tree_id, "Data_controle/nalv_Euforia_2022-02-15/hakhout_verschillende_id_zelfde_status_levend_dood.csv")

```

```{r tree_id_wide}
# TIJDELIJK
tree_id_long_ <- tree_id_long %>% 
  anti_join(check_dubbele_tree_id %>%  select(plot_id, tree_id))  # tijdelijk de dubbele tree_id's verwijderen

tree_id_long <- tree_id_long_

tree_id_wide <- make_table_wide(table_long = tree_id_long_,
                                    column_to_repeat = "survey_number",
                                    columns_for_comparison = c("dbh_mm", "vol_tot_m3", "alive_dead"))

names(tree_id_wide)
```



## Export tree level data

Met unieke en non-unieke (voor hakhout) tree-id én berekende variabelen.
Enkel processed data.

Niet alle variabelen mee exporteren, enkel deze relevant voor de meeste gebruikers.

Enkele verduidelijkingen:

* plotarea_ha = de oppervlakte van resp. A3 of A4, afh. van status en diameter van de boom
(of LxB voor kernvlaktes of volledig BR voor andere plottypes) dus NIET de volledige cirkel


```{r trees_less_variables}
tree_id_less_var <- tree_id %>% 
  select(-old_id, -contains(c("r_A", "dbh_min", "core_area_")), -subcirclearea_ha)
```


```{r save_trees}
# volgende functies heb ik zelf geschreven, zitten niet in het package!!!
save_results_csv (
    results = list(trees_calc = tree_id_less_var),
    output_dir = paste0(path_to_output, "raw-data/")
    )

# afgerond voor export naar access
tree_id_round <- tree_id_less_var %>% 
  mutate(round_df(., 4))

# save_results_access (
#   results = list(trees_calc = data_dendro_calc_round),
#   database = path_to_analysis_set_db,
#   remove_tables = TRUE
#   )

# Functie "save_results_access" (< package) geeft problemen met dates => hierna manueel

con <- odbcConnectAccess2007(path_to_analysis_set_db)

dbtables <- sqlTables(con)
if ("trees_calc" %in% dbtables$TABLE_NAME) {
        sqlDrop(con, "trees_calc")
      }
sqlSave(con, dat = tree_id_round, tablename = "trees_calc", varTypes = c(date_dendro="datetime"))

odbcClose(con)
```


```{r save_trees_wide}
# volgende functies heb ik zelf geschreven, zitten niet in het package!!!
save_results_csv (
    results = list(trees_wide = tree_id_wide),
    output_dir = paste0(path_to_output, "raw-data/")
    )

# afgerond voor export naar access
tree_id_wide_round <- tree_id_wide %>% 
  mutate(round_df(., 4))

save_results_access (
  results = list(trees_wide = tree_id_wide_round),
  database = path_to_analysis_set_db,
  remove_tables = TRUE
  )

```


## Export stem level data

Met unieke en non-unieke (voor hakhout) tree-id (uniek op boomniveau, niet op spilniveau) én berekende variabelen.

**!! OPGEPAST !!**
Unieke en non-unieke (voor hakhout) tree-id overgenomen van trees berekend op boomniveau.

<!--  na 16/2/2022: voor hakhout met meer dan twee delen: tree-id obv coppice-id (zie hoger) -->

Niet alle variabelen mee exporteren, enkel deze relevant voor de meeste gebruikers

```{r stems_less_variables}
stem_id_less_var <- stem_id %>% 
  select(-old_id, -contains(c("r_A", "dbh_min", "core_area_")), -subcirclearea_ha)
```


```{r save_stems}
# volgende functies heb ik zelf geschreven, zitten niet in het package!!!
save_results_csv (
    results = list(stems_calc = stem_id_less_var),
    output_dir = paste0(path_to_output, "raw-data/")
    )

# afgerond voor export naar access
stem_id_round <- stem_id_less_var %>% 
  mutate(round_df(., 4))

# save_results_access (
#   results = list(trees_calc = data_dendro_calc_round),
#   database = path_to_analysis_set_db,
#   remove_tables = TRUE
#   )

# Functie "save_results_access" (< package) geeft problemen met dates => hierna manueel

con <- odbcConnectAccess2007(path_to_analysis_set_db)

dbtables <- sqlTables(con)
if ("stems_calc" %in% dbtables$TABLE_NAME) {
        sqlDrop(con, "stems_calc")
      }
sqlSave(con, dat = stem_id_round, tablename = "stems_calc", varTypes = c(date_dendro="datetime"))

odbcClose(con)
```



# Regeneration 

## Calculate
```{r load_calc_reg}
data_regeneration <-
  load_data_regeneration(
    database = path_to_fieldmap_db
  )

regeneration <- calculate_regeneration(data_regeneration)
```


## Export


```{r filter_processed_reg}
reg_plotinfo <- lapply(regeneration, function(x) left_join(x, plotinfo_no_yr, by = c("plot_id", "period")))
# lapply: same function over all elements of the list

# filter processed data
reg_plotinfo_ <- reg_plotinfo %>% 
  lapply(., function(x) filter(x, data_processed == TRUE & survey_reg == TRUE))

# keep only necessary variables
reg_ <- reg_plotinfo_ %>% 
  lapply(., function(x) select(x, -survey_trees, -survey_deadw, -survey_veg))

# keep even less variables for export to git
reg_git <- reg_ %>% 
  lapply(., function(x) select(x, -plottype, -forest_reserve,-data_processed, -survey_number, -survey_reg))

```


```{r save_reg_git, eval=FALSE}
save_results_git(
  results = reg_git,
  repo_path = path_to_git_forresdat
)
```


```{r save_reg_git_manueel}
# manueel - eigen simpele functie
save_results_tsv(reg_git, 
                 root = path_to_forresdat_data,
                 strict = FALSE)
```


```{r save_reg_access_csv}
save_results_csv (
  results = reg_,
  output_dir = path_to_analysis_set_csv
)


# afgerond voor export naar access
# de df's van CP mogen op 0 afgerond worden (= 1ste drie dataframes)
# de KV's op 2 cijfers na de komma

reg_CP <- reg_[c(1:3)]
reg_CP <- reg_CP %>% 
  lapply(., function(x) round_df(x, 0)) 
  
reg_CA  <- reg_[c(4:5)]
reg_CA <- reg_CA %>% 
  lapply(., function(x) round_df(x, 2))

reg_round <- c(reg_CP, reg_CA)

save_results_access(
    results = reg_round,
    database = path_to_analysis_set_db,
    remove_tables = TRUE
  )

```


# Vegetation - bezig  - 10/3/2022

## Calculate

```{r load_veg}
data_vegetation <-
  load_data_vegetation(
    database = path_to_fieldmap_db
  )
data_herblayer <-
  load_data_herblayer(
    database = path_to_fieldmap_db
  )

vegetation <- calculate_vegetation(data_vegetation, data_herblayer)
```

## Export

```{r filter_processed_veg}
veg_plotinfo <- lapply(vegetation, function(x) left_join(x, plotinfo_no_yr, by = c("plot_id", "period")))
# lapply: same function over all elements of the list

# filter processed data
veg_plotinfo_ <- veg_plotinfo %>% 
  lapply(., function(x) filter(x, data_processed == TRUE & survey_veg == TRUE))

# keep only necessary variables
veg_ <- veg_plotinfo_ %>% 
  lapply(., function(x) select(x, -survey_trees, -survey_deadw, -survey_reg))


# keep even less variables for export to git
veg_git <- veg_ %>% 
  lapply(., function(x) select(x, -plottype, -forest_reserve,-data_processed, -survey_number, -survey_veg))

```

```{r save_veg_git, eval=FALSE}
save_results_git(
  results = veg_git,
  repo_path = path_to_git_forresdat
)
```


```{r save_veg_git_manueel}
# manueel - eigen simpele functie
save_results_tsv(veg_git, 
                 root = path_to_forresdat_data, 
                 strict = FALSE)
```


```{r save_veg_access_csv}
save_results_csv (
  results = veg_,
  output_dir = path_to_analysis_set_csv
)

# afgerond voor export naar access
# de df's van CP mogen op 0 afgerond worden (= 1ste drie dataframes)
# de KV's op 2 cijfers na de komma

veg_round <- veg_ %>% 
  lapply(., function(x) round_df(x, 2)) 
  
save_results_access(
    results = veg_round,
    database = path_to_analysis_set_db,
    remove_tables = TRUE
  )

```

# Herblayer 

## Export
Ook herblayer naar forresdat wegschrijven

```{r select_variables}
str(data_herblayer)

herblayer <- data_herblayer %>%
  select(plot_id, subplot_id, period, year, species, coverage_class_average_perc, browse_index_id, plotarea_ha, date_vegetation, deviating_date) %>%
  mutate(date_vegetation = as.Date(date_vegetation), deviating_date = as.Date(deviating_date)) 

# save_results_xxxx: gemaakt om list weg te schrijven
# hier maar één dataframe
herblayer_list <- list(herblayer_by_plot = herblayer)

# summary(herblayer)


```


```{r filter_processed_herb}
herb_plotinfo <- lapply(herblayer_list, function(x) left_join(x, plotinfo_no_yr, by = c("plot_id", "period")))
# lapply: same function over all elements of the list

# filter processed data
herb_plotinfo_ <- herb_plotinfo %>% 
  lapply(., function(x) filter(x, data_processed == TRUE & survey_veg == TRUE))

# keep only necessary variables
herb_ <- herb_plotinfo_ %>% 
  lapply(., function(x) select(x, -survey_trees, -survey_deadw, -survey_reg))


# keep even less variables for export to git
herb_git <- herb_ %>% 
  lapply(., function(x) select(x, -plottype, -forest_reserve,-data_processed, -survey_number, -survey_veg))

```


```{r save_herb_git, eval=FALSE}

save_results_git(
  results = herb_git,
  repo_path = path_to_git_forresdat
)

```


```{r save_herb_git_manueel}
# manueel - eigen simpele functie
save_results_tsv(herb_git, 
                 root = path_to_forresdat_data, 
                 strict = FALSE)
```


```{r save_herb_access_csv}
save_results_csv (
  results = herb_,
  output_dir = path_to_analysis_set_csv
)

# afgerond voor export naar access - is al OK

# save to access nog steeds niet opgelost, is alsof access date niet herkent
# => manueel gedaan (csv opgeslagen als xlsx en dan geïmporteerd; csv gaf zelfd eproblemen als access)
        # save_results_access(
        #   results = herb_[1],
        #   database = path_to_analysis_set_db,
        #   remove_tables = TRUE
        # )

# probleem met datumvelden => varTypes aanduiden
con <- odbcConnectAccess2007(path_to_analysis_set_db)

dbtables <- sqlTables(con)
if ("herblayer_by_plot" %in% dbtables$TABLE_NAME) {
        sqlDrop(con, "herblayer_by_plot")
      }
# sqlSave(con, dat = herblayer, tablename = "herblayer_by_plot", fast = FALSE)
sqlSave(con, dat = herb_[[1]], tablename = "herblayer_by_plot", varTypes = c(date_vegetation="datetime", deviating_date="datetime"))

odbcClose(con)

```




**Na update van forresdat, project "forresdat" openen en alles naar de cloud pushen**


