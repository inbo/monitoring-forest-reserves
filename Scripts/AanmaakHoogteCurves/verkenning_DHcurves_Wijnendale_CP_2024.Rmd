---
title: "Verkenning DHcurves aangemaakt in FM-IA"
subtitle: "Wijnendale - cirkelplots"
author: "Anja Leyman"
date: "`r Sys.Date()`"
output: 
  html_document:
    keep_md: FALSE
    number_sections: yes
    fig_caption: yes
    code_folding: hide
    toc: TRUE
    toc_float:
      collapsed: FALSE
      smooth_scroll: FALSE
---

```{r Rm, eval = FALSE}
rm(list=ls())
```

```{r Setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  eval = TRUE,
  message = FALSE,
  warning = FALSE, 
  fig.width = 9,
  fig.align = TRUE)

library(here)
library(writexl)


# libraries & invoergegevens
source(here::here("scripts/Setup.R"))

```


```{r Setup2}
forestreserve <- "Wijnendalebos"
forestreserve_short <- forestreserve
forestreserve_short <- "Wijnendale"
# plot_type <- "CA"
plot_type <- "CP"

forestreserve_folder <- paste0(path_to_reserves, "4b_Wijnendale")

virt_plot <- 599

# plots_to_exclude <- c(701, 707, 709, 727, 728, 738, 739, 740, 759, 760)
```


```{r Path}
# specifiek voor Wijnendale werden hoogtes toegevoegd aan "Wijnendale_DHcurves_CP_X8_inbo2020.accdb"
# => dit project gebruiken om dhcurves te verkennen
path_to_fieldmap_dhcurves <- paste0(forestreserve_folder,"/FMprojecten_2024/", forestreserve_short, "_DHcurves_CP_X8_inbo2020/FieldMapData_", forestreserve_short, "_DHcurves_CP_X8_inbo2020.accdb")


# resultaten
path_to_datarequest <- paste0(forestreserve_folder, "/verwerking_2024_1e2e3eSET/2AanmaakDHcurves_1e2e3eSET/")

```


# Vraagstelling

Momenteel gebeurt de meeste dataverwerking in R, maar de aanmaak van DH-curves gebeurt nog steeds in FM-IA.

Tot nu toe werd acces gebruikt om te kijken of er voor elke soort een curve opgesteld was, en of er geen soorten geclusterd dienen te worden.
Dit wordt nu door onderstaand script vervangen.


# Data inladen

**Bosreservaat `r forestreserve`** - **plottype `r plot_type`**.

<!-- In het geval van `r forestreserve` dient ook rekening gehouden te worden met een aantal **verstoorde plots**. -->
<!-- Deze worden niet meegenomen in de verdere dataverwerking.   -->


```{r overview_tables}
con <- odbcConnectAccess2007(path_to_fieldmap_dhcurves)
      dbtablesRaw_1eSET <- sqlTables(con) %>% 
                filter(str_detect(TABLE_NAME, "MSys", negate = TRUE ))
                # wegfilteren van records waar TABLE_NAME "MSys" bevat
odbcClose(con)
```

```{r load_lookuplists}
con <- odbcConnectAccess2007(path_to_fieldmap_db)

qspecies <- sqlFetch(con, "qSpecies")
qalivedead <- sqlFetch(con, "qAliveDead")
qindshootcop <- sqlFetch(con, "qIndShootCop")
qintactsnag <- sqlFetch(con, "qIntactSnag")

odbcClose(con)

```

Om functie `load_data_dendrometry()`van forrescalc te kunne gebruiken, moeten de
plotdetails ingevuld zijn (o.a. `forest_reserve` en `survey_trees` en `data_processed`)! 

```{r load_data}
# zorgen dat plotdetails ingevuld is
stems <- load_data_dendrometry(path_to_fieldmap_dhcurves, extra_variables = TRUE)

names(stems)

stems_ <- stems %>% 
  select(plot_id, tree_measure_id, species, alive_dead
         , intact_snag, ind_sht_cop, height_m
         , remark, common_remark)
```

```{r select_height_data}
# names(stems)
stems_height <- stems_ %>% 
  filter(alive_dead == 11 & intact_snag == 11
         & ind_sht_cop != 11
         & !is.na(height_m)  # levend en intact, geen opgr spil
  ) %>% 
  left_join(qspecies %>% select(ID, name_nl = Value1), by = c("species"= "ID")) %>% 
  left_join(qindshootcop %>% select(ID, ind_sht_cop_txt = Value1), by = c("ind_sht_cop"= "ID"))

```


## Erraneous records

Erraneous records inladen en omvormen naar IDPlots, ID, diff, en koppelen met soort
! worden bepaald obv afwijking tov algemene curve, niet soort-specifiek

kolomnamen "plot" en "diff" toevoegen in `erraneous_records.xlsx`


```{r}
erraneous <- read_xlsx(paste0(path_to_datarequest, "erraneous_records.xlsx"),
                       sheet = "Blad1")
# erraneous <- read_xlsx(paste0(path_to_VBI2_dhcurves, "erraneous_records_dhcurves.xlsx")
                       # , sheet = "2eRun")

erraneous_ <- erraneous %>% 
  mutate(plot_id = str_match(plot, "Plot\\s*(.*?)\\s*/")[,2]
         # na plot_ en voor /
         # ,ID = str_match(Plot, "Tree\\s*(.*?)")
         , tree_measure_id = sub(".*Tree ", "", plot)  # alles na "Tree" 
               # (want alles tem tree vervangen door "" (niks))
         , diff_m = ifelse(str_detect(diff, "-"),
                         str_sub(diff, 6, 11),
                         str_sub(diff, 6, 10)
                         )
         , diff_m = str_replace(diff_m, ",", ".")
         , diff_m = as.numeric(diff_m)
         # volgende code werkt ook voor IDPlots - eenvoudiger te snappen
         # , test_plotid = sub("/.*", "", Plot)   # alles voor "/"
         # , test_plotid = sub(".*Plot ", "", test_plotid) # alles na "Plot "
         , plot_id = as.integer(plot_id)
         , tree_measure_id = as.integer(tree_measure_id)
  )

# x <- "hello xxx other stuff"         # Example character string
# x                                    # Print example string
# # "hello xxx other stuff"
# sub(" xxx.*", "", x)
# sub(" *.xxx", "", x)
# sub(".*xxx ", "", x)

erraneous_ <- erraneous_ %>% 
  select(plot_id, tree_measure_id, diff_m)
```

```{r}
names(stems_height)

erraneous_ <- erraneous_ %>% 
  left_join(stems_height)

range(abs(erraneous_$diff_m))
table(erraneous_$species)
table(erraneous_$name_nl)
```

Erraneous records worden bepaald op basis van de afwijkingen tov de algemene curve.
Dat wil echter niet zeggen dat dat echt afwijkende metingen zijn!
(zie 0_0_residuals.emf)
Daarvoor moeten we kijken naar de emf-files per soort:    
 - 0_64_residuals.emf voor tka: 1 outlier: 25 cm dbh en 6 m hoogte => effectief een outlier => hoogte verwijderen
 - 0_89_residuals.emf voor Zwarte els: net 1 outlier: dbh 22 en hoogte 11.5 => ook verwijderen 


```{r}
write.xlsx(x = erraneous_, file = paste0(path_to_datarequest, "erraneous_records.xlsx")
           , sheetName = "detail"
           , append = TRUE)
```


Hierna dh-curves op nieuw laten berekenen in FM-IA.


# Hoogtemodellen inladen

```{r}

```

# Aantal gemeten hoogtes per soort

```{r}
nr_measured <- stems_ %>% 
  # filter(alive_dead == 11 & intact_snag == 11) %>% 
  group_by(species) %>% 
  summarize(n = n(),
            n_alive = sum(alive_dead == 11),
            n_dead = sum(alive_dead == 12),
            n_height_all = sum(height_m > 0, na.rm = TRUE), 
            n_height_alive = sum(height_m > 0 & alive_dead == 11 & intact_snag == 11, na.rm = TRUE)) %>%
  ungroup() %>% 
  left_join(qspecies %>% select(ID, name_nl = Value1), by = c("species" = "ID")) %>% 
  arrange(n_height_alive, n_alive)

nr_measured %>% DT :: datatable(options = list(dom = 'tip'),rownames = FALSE) 

write.csv2(nr_measured, paste0(path_to_datarequest, "/nr_measured.csv"))

```

# Hakhout

```{r HH_overzicht}
overview_HH_height <- stems_height %>% 
  group_by(ind_sht_cop, species, name_nl) %>% 
  summarize(aantal = n()) %>% 
  ungroup %>% 
  pivot_wider(names_from = ind_sht_cop, values_from = aantal) %>% 
  rename(individual = "10", coppice = "12") %>% 
  mutate(perc_hakhout = round(100*coppice/(individual + coppice), ))

overview_HH_height %>% 
  arrange(desc(perc_hakhout)) %>% 
  DT :: datatable(options = list(dom = 'tip'), rownames = FALSE, filter = "top") 

write.csv2(overview_HH_height, paste0(path_to_datarequest, "/overview_HH_height.csv"))
```

# Soorten die enkel dood of als snag voorkomen
Deze moeten ook toegevoegd worden aan de lijst

```{r}
only_dead <- stems_ %>% 
  group_by(species) %>% 
  summarize(aantal = n(),
            alive = sum(alive_dead == 11) > 0,
            dead = sum(alive_dead == 12) > 0) %>%
  ungroup() %>% 
  left_join(qspecies %>% select(ID, name_nl = Value1), by = c("species" = "ID")) %>% 
  filter(alive == FALSE & dead == TRUE)

print(only_dead)

```


Voor bosreservaat `r forestreserve` gaat het om volgende soorten: `r only_dead$name_nl` (soort-id `r only_dead$species`)



