---
title: "Verkenning DHcurves aangemaakt in FM-IA"
subtitle: "2025 - decade 3"
author: "Anja Leyman"
date: "6 maart 2025"
output: 
  html_document:
    keep_md: FALSE
    number_sections: yes
    fig_caption: yes
    code_folding: hide
    toc: TRUE
    toc_float:
      collapsed: FALSE
      smooth_scroll: FALSE
---

```{r Rm, eval = FALSE}
rm(list=ls())
```

```{r Setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  eval = TRUE,
  message = FALSE,
  warning = FALSE, 
  fig.width = 7,
  fig.height = 3,
  fig.align = TRUE)

library(here)
library(writexl)
library(scales)


# libraries & invoergegevens
source(here::here("scripts/Setup.R"))
```


```{r Setup2}
forestreserve <- "Heirnisse"
forestreserve_short <- forestreserve

forestreserve_folder <- paste0(path_to_reserves, "2_Heirnisse_DEELS")

# plot_type <- "CA"
plot_type <- "CP"

virt_plot <- 799

plots_to_exclude <- c(701, 707, 709, 727, 728, 738, 739, 740, 759, 760)
```


```{r Path}
# specifiek voor Wijnendale werden hoogtes toegevoegd aan "Heirnisse_DHcurves_CP_X8_inbo2020.accdb"
# => dit project gebruiken om dhcurves te verkennen
path_to_fieldmap_dhcurves <- paste0(forestreserve_folder,"/FMprojecten_2025/", forestreserve, "_DHcurves_", plot_type, "_X8_inbo2020/FieldMapData_", forestreserve, "_DHcurves_", plot_type, "_X8_inbo2020.accdb")

# resultaten
path_to_datarequest <- paste0(forestreserve_folder, "/verwerking_2025_1e2e3eSET/2AanmaakDHcurves_1e2e3eSET/")

path_to_html <-  path_to_datarequest

# hoogtemodellen: zie paths.R
    # path_to_height_models   # "C:/03_BR/1_DataverwerkingBR/Data/Hoogtemodellen/"
    # path_to_heightmodels_teamdrive # "G:/Gedeelde drives/Team_Boseco_BR/PRJ_BR_Gegevensverwerking/50_Hoogtemodellen/"
```



# Vraagstelling

Momenteel gebeurt de meeste dataverwerking in R, maar de aanmaak van DH-curves gebeurt nog steeds in FM-IA.

Onderstaand R-script helpt en geeft info bij  

1. het checken van de erraneous records door in de excel-file erraneous_records.xlsx 
een extra tabblad ("detail") aan te maken met daarin de outliers met vermelding 
van soort, dbh, hoogte en ev. opmertrkingen

2. het checken van de curves: de globale curves (0_xx.emf) en de curves op plotniveau (839_xxxx.emf) worden in in FM-IA overlopen en de probleemgevallen worden in onderstaand R-script beschreven

3. het controleren of er wel voor elke soort een curve opgesteld is

4. het beslissen of er geen soorten geclusterd dienen te worden

<br>


# Data inladen

**Bosreservaat `r forestreserve`** - **plottype `r plot_type`**.

<!-- In het geval van `r forestreserve` dient ook rekening gehouden te worden met een aantal **verstoorde plots**. -->
<!-- Deze worden niet meegenomen in de verdere dataverwerking.   -->


```{r overview_tables}
con <- odbcConnectAccess2007(path_to_fieldmap_dhcurves)
      dbtablesRaw_1eSET <- sqlTables(con) %>% 
                filter(str_detect(TABLE_NAME, "MSys", negate = TRUE ))
                # wegfilteren van records waar TABLE_NAME "MSys" bevat
odbcClose(con)
```

```{r load_lookuplists}
con <- odbcConnectAccess2007(path_to_fieldmap_db)

qspecies <- sqlFetch(con, "qSpecies")
qalivedead <- sqlFetch(con, "qAliveDead")
qindshootcop <- sqlFetch(con, "qIndShootCop")
qintactsnag <- sqlFetch(con, "qIntactSnag")

odbcClose(con)

```

Om functie `load_data_dendrometry()`van forrescalc te kunnen gebruiken, moeten de
plotdetails ingevuld zijn (o.a. `forest_reserve` en `survey_trees` en `data_processed`)! 

```{r load_data, results='hide'}
# zorgen dat plotdetails ingevuld is
stems <- load_data_dendrometry(path_to_fieldmap_dhcurves, extra_variables = TRUE)

names(stems)

stems_ <- stems %>% 
  select(plot_id, tree_measure_id
         , species, alive_dead
         , intact_snag, ind_sht_cop, dbh_mm, height_m
         , remark, common_remark)

summary(stems_)
```

```{r select_height_data}
# names(stems)
stems_height <- stems_ %>% 
  filter(alive_dead == 11 & intact_snag == 11
         & ind_sht_cop != 11
         & !is.na(height_m)  # levend en intact, geen opgr spil
  ) %>% 
  left_join(qspecies %>% select(ID, name_nl = Value1), by = c("species"= "ID")) %>% 
  left_join(qindshootcop %>% select(ID, ind_sht_cop_txt = Value1), by = c("ind_sht_cop"= "ID"))

table(stems_height$period)

```


# Erraneous records

## Inladen en omvormen

Eerst kolomnamen "plot" en "diff" toevoegen in `erraneous_records.xlsx`

Vervolgens worden de erraneous records ingeladen en omgevormd naar IDPlots, ID, diff
en gekoppeld met soort, dbh, hoogte en ev. remark. 

**OPGEPAST**: de erraneous records worden bepaald obv afwijking tov algemene curve, 
niet tov de soort-specifieke curve


```{r}
erraneous <- read_xlsx(paste0(path_to_datarequest, "erraneous_records_", plot_type, ".xlsx"),
                       sheet = "Blad1")
# erraneous <- read_xlsx(paste0(path_to_VBI2_dhcurves, "erraneous_records_dhcurves.xlsx")
                       # , sheet = "2eRun")

erraneous_ <- erraneous %>% 
  mutate(plot_id = str_match(plot, "Plot\\s*(.*?)\\s*/")[,2]
         # na plot_ en voor /
         # ,ID = str_match(Plot, "Tree\\s*(.*?)")
         , tree_measure_id = sub(".*Tree ", "", plot)  # alles na "Tree" 
               # (want alles tem tree vervangen door "" (niks))
         , diff_m = ifelse(str_detect(diff, "-"),
                         str_sub(diff, 6, 11),
                         str_sub(diff, 6, 10)
                         )
         , diff_m = str_replace(diff_m, ",", ".")
         , diff_m = as.numeric(diff_m)
         # volgende code werkt ook voor IDPlots - eenvoudiger te snappen
         # , test_plotid = sub("/.*", "", Plot)   # alles voor "/"
         # , test_plotid = sub(".*Plot ", "", test_plotid) # alles na "Plot "
         , plot_id = as.integer(plot_id)
         , tree_measure_id = as.integer(tree_measure_id)
  )

# x <- "hello xxx other stuff"         # Example character string
# x                                    # Print example string
# # "hello xxx other stuff"
# sub(" xxx.*", "", x)
# sub(" *.xxx", "", x)
# sub(".*xxx ", "", x)

erraneous_ <- erraneous_ %>% 
  select(plot_id, tree_measure_id, diff_m)
```

```{r}
# names(stems_height)

erraneous_ <- erraneous_ %>% 
  left_join(stems_height)

range(abs(erraneous_$diff_m))
table(erraneous_$species)
table(erraneous_$name_nl)
```

Erraneous records worden bepaald op basis van de afwijkingen tov de algemene curve.
Dat wil echter niet zeggen dat dat echt afwijkende metingen zijn!
(zie 0_0_residuals.emf)
Daarvoor moeten we kijken naar de emf-files per soort.

Hiervoor voegen we (eenmalig) de soort, dbh en hoogte toe aan de erraneous_records 
in een nieuw tabblad "detail".

```{r eval=FALSE}
write.xlsx(x = erraneous_, file = paste0(path_to_datarequest, "erraneous_records_", plot_type, ".xlsx")
           , sheetName = "detail"
           , append = TRUE)
```


## Besluit 

Evenveel "erraneous records" bij log als bij exponentiële functie.
Wel niet allemaal dezelfde.

Bij exp. functie: 4 populieren en 2 zomereiken: 

- Populier: bijnnen de soort zijn dit geen outliers
- Zomereik: twee "outliers" volgens grafiek van residuals, maar gewoon lage metingen, 
geen impact op curve (dbh = 22.5 en 23.5 met hoogte ca 10m)

Bij log. functie: 3 populieren (51), 1 esdoorn (16), 1 wilg (78) en 1 zomereik (87)

- esdoorn: hh-spil, 23m hoog, dbh = 130  => hoogte verwijderen(! niet de tree)
- wilg: 15 m hoog, dbh = 40 cm => hoogte verwijderen   

 **Hierna dh-curves opnieuw laten berekenen in FM-IA.**
 
 - nieuwe outlier: tKa: is OK!


# Hoogtemodellen checken

De globale curves (0_xx.emf) en de curves op plotniveau (799_xxx.emf) worden in 
FM-IA overlopen.


## Globale modellen per soort - outliers

Over alle plots heen: 0_xx.emf

Om snel te zien of globale curve ok is en er geen rare outliers zijn.

Alles lijkt OK.


## Plotmodellen per soort - extrapolaties

bv. 799_xxx.emf: specifiek voor die ene plot, met ook aanduiding van de bomen zonder 
hoogtes (in dit project enkel de levende bomen ingeladen)

Dit laat toe om te zien of er een (onverantwoorde) extrapolatie gebeurd is 
(blauwe bolletjes geven de hoogtemetingen weer; gele vierkantjes de gemodelleerde hoogtes)

Bij Heirnisse zien we bij breedbladige wilg (77) duidelijk een extrapolatie.
Is dat een probleem? 
Boom van 30 cm dbh --> 18 m hoog; van 50 cm dbh --> 21 m hoog
Meeste bomen < 20 cm dbh en > 14 m hoog
=> OK

<br> 

**Heirnisse CP's: extrapolatie van breedbladige wil is OK**

<!-- Ev. aftoetsen aan alle bomen van een bepaalde soort om te kijken of de extrapolatie  -->
<!-- geen te grote over- of onderschatting geeft?  -->

```{r}
all_trees_ever <- load_data_dendrometry(database = path_to_fieldmap_db) %>% 
  filter(alive_dead == 11 & intact_snag == 11 & !is.na(height_m)) %>% 
  mutate(dbh_cm = dbh_mm/10)

```


## Parameters exp vs log    

### Check in FM-IA

show existing charts - tabblad "Model Parameters" - Copy to clipboard

Plakken in excel-file "HeightParams_Heirnisse_CP.xlsx" in folder ".../2_Heirnisse_DEELS/verwerking_2024_1e2e3eSET/2AanmaakDHcurves_1e2e3eSET"

- tabblad log    
- tabblad exp

 
### Check in verkenner

de emf-files uit ".../2_Heirnisse_DEELS/FMprojecten_2024/Heirnisse_DHcurves_CP_X8_inbo2020/InventoryAnalyst/Charts_Height_m" kopiëren naar

- ".../2_Heirnisse_DEELS/verwerking_2024_1e2e3eSET/2AanmaakDHcurves_1e2e3eSET/DH_curves_CP_exp"    
- ".../2_Heirnisse_DEELS/verwerking_2024_1e2e3eSET/2AanmaakDHcurves_1e2e3eSET/DH_curves_CP_log"     



## Besluit

### Outliers

Twee outlieres verwijderd (esdoorn en wilg)


### Extrapolaties

Enkel bij breedbladige wilg (77) duidelijk extrapolatie, maar is OK.



### Exp vs log

In 2015 en 2022 geopteerd voor exp. functie, die was toen beter.
Nu lijkt log beter, MAAR:   

- CA: exponentiële functie beter
- als we kiezen voor exp, is er minder verschil met de eerde gebruikte curves

=> in 2025 opteren we opnieuw voor de **exponentiële functie**.
Een optie zou kunnen zijn om afhankelijk van de soort een andere functie-vorm te kiezen, 
maar dit lijkt me overkill. 

We schuiven tabblad "log" naar voor in de excel-file en voegen volgende velden toe:    

- BR	  
- info	  
- Brondata	  
- Verklaring   


<br>


# Aantal gemeten hoogtes per soort

```{r}
all_trees_reserve <- load_data_dendrometry(database = path_to_fieldmap_db
                                   , plottype = plot_type
                                   , extra_variables = TRUE
                                   , processed = FALSE) %>% 
  # filter(forest_reserve == forestreserve & !plot_id %in% plots_to_exclude) %>% 
  filter(forest_reserve == forestreserve) %>% 
  mutate(fperiod = as.factor(period))

all_shoots_reserve <- load_data_shoots(database = path_to_fieldmap_db, extra_variables = TRUE)
all_stems_reserve <- compose_stem_data(all_trees_reserve, all_shoots_reserve, extra_variables = TRUE)

# names(all_stems_reserve)

all_stems_reserve <- all_stems_reserve %>% 
  select(plot_id, tree_measure_id, species, alive_dead
         , intact_snag, ind_sht_cop, dbh_mm, height_m
         , remark, common_remark
         , period)
```

## Overzichtstabel

```{r}
nr_measured <- all_stems_reserve %>% 
  # filter(alive_dead == 11 & intact_snag == 11) %>% 
  group_by(species) %>% 
  summarize(n = n(),
            n_alive = sum(alive_dead == 11),
            n_dead = sum(alive_dead == 12),
            n_height_all = sum(height_m > 0, na.rm = TRUE), 
            n_height_alive = sum(height_m > 0 & alive_dead == 11 & intact_snag == 11
                                 , na.rm = TRUE)) %>%
  ungroup() %>% 
  left_join(qspecies %>% select(ID, name_nl = Value1), by = c("species" = "ID")) %>% 
  arrange(n_height_alive, n_alive)

nr_measured %>% arrange(desc(n_height_alive)) %>% 
  DT :: datatable(filter = 'top', options = list(dom = 'tip'),rownames = FALSE) 

```


## Enkel dode bomen

Er zijn drie soorten die enkel als dode boom voorkomen: Berk, Onbekend loofhout en Ruwe iep.

```{r}
nr_measured %>% filter(n_alive == 0) %>% 
  DT :: datatable(options = list(dom = 'tip'),rownames = FALSE) 
```


Deze moeten we manueel toevoegen aan de excel-file "HeightParams_Heirnisse_CP.xlsx", met de algemene curve als curve, en n = 0.



## Geen hoogtes

Er is - naast de drie soorten met enkel dode bomen - nog één soort waar geen hoogtes 
van gemeten zijn: Gladde iep. 

```{r}
nr_measured %>% filter(between(n_height_alive, 0, 0)) %>% 
  DT :: datatable(options = list(dom = 'tip'),rownames = FALSE) 
```


Daar wordt automatisch de algemene curve gebruikt = OK    


## Adjusted curve 

Welke soorten hebben enkel een “adjusted” curve wegens onvoldoende (< 5) metingen? 

Dit wil zeggen dat er te weinig metingen zijn voor een curve met eigen vorm, en  
dat de algemene curve (alle soorten samen) verschoven wordt obv die enkele metingen 
(intercept wordt aangepast). 

Daarom is het van belang om te checken of één rare meting toch geen foute curve creëert.

Zo ja, dan kiezen we beter voor de algemene curve.

```{r}
nr_measured %>% filter(between(n_height_alive, 1, 4)) %>% 
  arrange(species) %>% 
  DT :: datatable(options = list(dom = 'tip'),rownames = FALSE) 
```

Bovenstaande soorten worden in detail bekeken in FM-IA.

Alles OK. 


## Soorten clusteren 

We voegen soorten samen wanneer er van een bepaalde soort te weinig metingen zijn.
Dit zien we soms al duidelijk bij het overlopen van de curves in FM-IA, maar
bovenstaande tabel geeft soms nog wat meer duidelijkheid.

In 2022 bekeken we de hoogtes uit 1e en 2eSET en daar zijn toen - als test - berk, els en wilg geclusterd.
MAAR dat bleek niet veel verschil te geven voor berk en wilg, en anderzijds daalde de R voor els.
Daarom beslist om de soorten afzonderlijk te behouden, wegens geen meerwaarde van clustering.

=> bij de CP's van Heirnisse is het geen meerwaarde om te clusteren.


# Aanpassen parameterfile

De excel-file "HeightParams_Heirnisse_CP.xlsx" aanpassen


## Verklaring toevoegen

Volgende opties zijn mogelijk:

```{r}
# Maak een dataframe met de gegeven gegevens
verklaring <- data.frame(
  Source = c("global", "adjusted_all_species", "all_species"),
  Brondata = c("1eSET+3eSET", "1eSET+3eSET", "1eSET+3eSET"),
  Verklaring = c("eigen curve: voldoende bomen voor de soort beschikbaar", 
                 "globale hoogtecurve van geclusterde soorten, intercept aangepast aan soort", 
                 "globale hoogtecurve van geclusterde soorten")
)

# Toon de dataframe
verklaring %>% DT :: datatable(options = list(dom = 'tip'),rownames = FALSE)
```

- bij de globale soortmodellen als verklaring "eigen curve: 
voldoende bomen voor de soort beschikbaar" toevoegen     
 
- bij de plotmodellen van soorten met 0 metingen, als verklaring "globale hoogtecurve 
van geclusterde soorten" toevoegen     

- bij de plotmodellen van soorten met < 5 metingen, als verklaring "globale hoogtecurve
van geclusterde soorten, intercept aangepast aan soort" toevoegen   

- idem dito voor de soorten met meer dan 4 metingen, waar toch geen eigen curve voor 
opgesteld kon worden (hier zijn dat soorten 69 en 17)



## Verwijderen plotmodellen

De plotmodellen (plotID = 799) van soorten waar ook een globaal model (plotID = <ALL>) 
van is, verwijderen, zodat soorten niet dubbel voorkomen in de lijst.


## Toevoegen plotmodellen van geclusterde soorten   

Dit is ahw het ontkoppelen van de geclusterde soorten.
Hier niet nodig.


## Kopieren naar folder dataverwerking 

De parameterfile kopiëren naar folder "C:/03_BR/1_DataVerwerkingBR/Data/Hoogtemodellen" 
voor gebruik in R, package forrescalc.


- Eerst de oude parameterfiles die daar staan, hernoemen naar "xxxxx_vs2022.xlsx" en 
verplaatsen naar folder "archief",met behulp van onderstaande code (! versienr aanpassen).    

```{r}
versienr <- "vs2022"

for (decade in c(1, 2)){
  
  # bestaat de file al?
  archive_filename <- paste0(path_to_height_models, "archief/HeightParams_", forestreserve_short, "_", plot_type, "_", decade, "_", versienr, ".xlsx")
  
  if (file.exists(archive_filename)) {
  print(paste0(archive_filename, " already exists!"))
} else {
  print("The file does not exist.")
  parameters_old <- read_excel(paste0(path_to_height_models, "HeightParams_", forestreserve_short, "_", plot_type, "_1.xlsx"))
  write.xlsx(parameters_old, file = archive_filename, showNA = FALSE) 
}
  
}

# idem voor teamdrive
for (decade in c(1, 2)){
  
  # bestaat de file al?
  archive_filename <- paste0(path_to_heightmodels_teamdrive, "archief/HeightParams_", forestreserve_short, "_", plot_type, "_", decade, "_", versienr, ".xlsx")
  
  if (file.exists(archive_filename)) {
  print(paste0(archive_filename, " already exists!"))
} else {
  print("The file does not exist.")
  parameters_old <- read_excel(paste0(path_to_heightmodels_teamdrive, "HeightParams_", forestreserve_short, "_", plot_type, "_1.xlsx"))
  write.xlsx(parameters_old, file = archive_filename, showNA = FALSE) 
}
  
}


```

- De parameterfile inlezen.    

```{r}
parameters <- read_excel(path = paste0(path_to_datarequest, "HeightParams_", forestreserve_short, "_", plot_type, ".xlsx"))

# eerste sheet inlezen
```

- De parameterfile opslaan onder `r path_to_height_models`, met een afzonderlijke file per decade.

```{r}
write.xlsx(parameters, file = paste0(path_to_height_models, "HeightParams_", forestreserve_short, "_", plot_type, "_1.xlsx"), showNA = FALSE)  # row.names = TRUE geeft foutmelding

write.xlsx(parameters, file = paste0(path_to_height_models, "HeightParams_", forestreserve_short, "_", plot_type, "_2.xlsx"), showNA = FALSE)

write.xlsx(parameters, file = paste0(path_to_height_models, "HeightParams_", forestreserve_short, "_", plot_type, "_3.xlsx"), showNA = FALSE)
```


- De parameterfile ook direct opslaan in onze teamdrive `r path_to_heightmodels_teamdrive`

```{r eval = FALSE}
write.xlsx(parameters, file = paste0(path_to_heightmodels_teamdrive, "HeightParams_", forestreserve_short, "_", plot_type, "_1.xlsx"), showNA = FALSE)  # row.names = TRUE geeft foutmelding

write.xlsx(parameters, file = paste0(path_to_heightmodels_teamdrive, "HeightParams_", forestreserve_short, "_", plot_type, "_2.xlsx"), showNA = FALSE)

write.xlsx(parameters, file = paste0(path_to_heightmodels_teamdrive, "HeightParams_", forestreserve_short, "_", plot_type, "_3.xlsx"), showNA = FALSE)
```

# Html kopieren naar teamdrive

Html manueel kopieren naar c-schijf en naar de teamdrive (`r paste0("PRJ_BR_Gegevensverwerking/per_gebied/2024_", forestreserve_short)`)  

Na knitting - manueel

```{r eval = FALSE}
# Specify the path of the file you want to copy
source_file <- here::here(paste0("Scripts/AanmaakHoogteCurves/verkenning_DHcurves_", forestreserve_short, "_", plot_type, "_2025.html"))

# Specify the destination directory where you want to copy the file
destination_dir1 <- path_to_datarequest
destination_dir2 <- paste0(path_to_dataverwerking_teamdrive, "20_Per_gebied/2024_"
                           , forestreserve, "/02_dh_curves")

# Copy the file to the destination directory
file.copy(from = source_file, to = destination_dir1, overwrite = TRUE)
file.copy(from = source_file, to = destination_dir2, overwrite = TRUE)
# ? file.copy
```
