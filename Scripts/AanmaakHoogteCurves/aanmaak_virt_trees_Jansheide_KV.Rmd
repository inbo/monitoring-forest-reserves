---
title: "Ophalen data voor aanmaak DH-curves in een virtuele plot mbv FM-IA"
subtitle: "2025 - decade 3"
author: "Anja Leyman"
date: "`r Sys.Date()`"
output: 
  html_document:
    keep_md: FALSE
    number_sections: yes
    fig_caption: yes
    code_folding: hide
    toc: TRUE
    toc_float:
      collapsed: FALSE
      smooth_scroll: FALSE
---

```{r Rm, eval = FALSE}
rm(list=ls())
```

```{r Setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  eval = TRUE,
  message = FALSE,
  warning = FALSE, 
  fig.width = 9,
  fig.align = TRUE)

library(here)
library(writexl)


# libraries & invoergegevens
source(here::here("scripts/Setup.R"))

```


```{r Setup2}
forestreserve <- "Jansheideberg"
forestreserve_folder <- "1_Jansheide_DEELS"

plot_type <- "CA"
# plot_type <- "CP"

virt_plot <- 101001

```


```{r Path}
# deze worden ook in "Paths.R" gedefinieerd, hier ev. extra "paths" toevoegen indien nodig voor huidig script

# resultaten
path_to_datarequest <- paste0(path_to_reserves, forestreserve_folder, "/verwerking_2025_1e2e3eSET/2AanmaakDHcurves_1e2e3eSET/VirtualTreesHeightCurves")

path_to_html <-  paste0(path_to_reserves, forestreserve_folder, "/verwerking_2025_1e2e3eSET/2AanmaakDHcurves_1e2e3eSET")

```


# Vraagstelling

Momenteel gebeurt de meeste dataverwerking in R, maar de aanmaak van DH-curves gebeurt nog steeds in FM-IA.
Daartoe wordt een virtuele plot aangemaakt waar alle boomhoogtes in opgenomen zijn.

- alle hoogtes van intacte bomen
- hoogtes van hakhout spillen, zeker als er te weinig metingen op boomniveau zijn (bv. Hazelaar)
- hoogtes van 1e en 2eSET samen (soms hoogtecurves obv 1e en 2e SET afzonderlijk)

Onderstaand script voegt al deze data samen, om vervolgens in FM in te laden mbv de Import2FM-tool.


# Datacontrole

Datacontrole dient vooraf te gebeuren, zie "...\Scripts\Per_gebied".

Eens datacoontrole afgerond is, moet veld `processed` aangepast worden.

Met behulp van een updatequery voor een vooraf geselecteerde decade, plottype en bosreservaat zetten we `DataProcessed_YN` op `10` (code 10 = 'ja'), indien `Survey_Trees_YN = 10`. 

```{r update_processed, eval = FALSE}
# Predefined strings
decade <- "3" 
# plot_type <- "CA"
# forestreserve <- "Meerdaalwoud"

# Construct the query string using sprintf
query_update <- paste0(sprintf("UPDATE (PlotDetails_%seSET pd 
                         INNER JOIN Plots p ON pd.IDPlots = p.ID) 
                         INNER JOIN qPlotType q ON p.Plottype = q.ID 
                         SET pd.DataProcessed_YN = 10 
                         WHERE (pd.Survey_Trees_YN = 10) 
                         AND (q.Value3 = '%s') 
                         AND (pd.ForestReserve = '%s')",
                         decade, plot_type, forestreserve)
                       ) %>% noquote()

con <- odbcConnectAccess2007(path_to_fieldmap_db)
   sqlQuery(con,query_update)
odbcClose(con)

```


# Data inladen

In dit script wordt data van het **bosreservaat `r forestreserve`** ingeladen, met als **plottype `r plot_type`**.

```{r overview_tables_fieldmap}
con <- odbcConnectAccess2007(path_to_fieldmap_db)
      tables_fieldmap <- sqlTables(con) %>% 
                filter(str_detect(TABLE_NAME, "MSys", negate = TRUE ))
                # wegfilteren van records waar TABLE_NAME "MSys" bevat
odbcClose(con)
```

```{r load_lookuplists}
con <- odbcConnectAccess2007(path_to_fieldmap_db)

qspecies <- sqlFetch(con, "qSpecies")
qalivedead <- sqlFetch(con, "qAliveDead")
qindshootcop <- sqlFetch(con, "qIndShootCop")
qintactsnag <- sqlFetch(con, "qIntactSnag")

odbcClose(con)

```

Data inladen via de functies `load_data_dendrometry`, `load_data_shoots` en `compose_stem_data`uit package `forrescalc`.

NIET `trees_calc` uit forresdat, want dat zijn niet steeds de meest recente data en mogelijk ook enkel de processed data.


```{r inspect_plots}
plots <- load_plotinfo(database = path_to_fieldmap_db)

plots %>% distinct(forest_reserve) %>% dplyr::pull(forest_reserve)

# # bevat geen tresholds
# con <- odbcConnectAccess2007(path_to_strata_db)
#  # strata_tables <- sqlTables(con) %>% filter(!str_detect(TABLE_NAME, "MSys"))
#  # strata <- sqlFetch(con, "strata_remaining", stringsAsFactors = FALSE)
#  # location <- sqlFetch(con, "strata_location", stringsAsFactors = FALSE)
#  plotinfo <- sqlFetch(con, "info_survey", stringsAsFactors = FALSE)
# odbcClose(con)
# 
# plotinfo %>% filter(str_detect(forest_reserve, forestreserve)) %>% select(plot_id, contains("Treshold"))

plotinfo_ <- plots %>% filter(str_detect(forest_reserve, forestreserve) & plottype == 30) 

unique(plotinfo_$forest_reserve)
```


```{r load_data}
trees <- load_data_dendrometry(database = path_to_fieldmap_db, 
                               plottype = plot_type, 
                               forest_reserve = forestreserve, 
                               extra_variables = TRUE) 

# shoots <- load_data_shoots(database = path_to_fieldmap_db)
shoots <- load_data_shoots(database = path_to_fieldmap_db, extra_variables = TRUE)# hier kan forest_reserve niet gespecifieerd worden

stems <- compose_stem_data(trees, shoots, extra_variables = TRUE)
# door samen te voegen, wordt enkel het specifieke forest reserve behouden

```


```{r select_height_data}
# names(stems)
stems_height <- stems %>%
  filter(alive_dead == 11 & intact_snag == 11
         & ind_sht_cop != 11
         & !is.na(height_m)  # levend en intact, geen opgr spil
         & (common_remark != 90 | is.na(common_remark)) # 90: uitgebroken top
  ) %>%
  left_join(qspecies %>% select(ID, Value1), by = c("species"= "ID")) %>%
  rename(name_nl = Value1) %>%
  left_join(qindshootcop %>% select(ID, Value1), by = c("ind_sht_cop"= "ID")) %>%
  rename(ind_sht_cop_txt = Value1) %>%
  mutate(fperiod = as.factor(period),
         ind_sht_cop = as.factor(ind_sht_cop)) %>%
  select(-contains(c("dbh_min", "r_A", "core", "area", "circle")))

```

# Aantal gemeten hoogtes per soort

```{r only_core_area}
nr_measured <- stems %>% 
  mutate(height_m = ifelse((common_remark != 90 | is.na(common_remark))
                            , height_m
                            , NA)  # uitgebroken top
        ) %>% 
  # filter(alive_dead == 11 & intact_snag == 11) %>% 
  group_by(species) %>% 
  summarize(n = n(),
            n_alive = sum(alive_dead == 11),
            n_dead = sum(alive_dead == 12),
            n_height_all = sum(height_m > 0, na.rm = TRUE), 
            n_height_alive = sum(height_m > 0 & alive_dead == 11 & intact_snag == 11, na.rm = TRUE)) %>%
  ungroup() %>% 
  left_join(qspecies %>% select(ID, name_nl = Value1), by = c("species" = "ID")) %>% 
  arrange(n_height_alive, n_alive)

nr_measured %>% DT :: datatable(options = list(dom = 'tip'),rownames = FALSE) 

write.csv2(nr_measured, paste0(path_to_datarequest, "/nr_measured_KV.csv"))

```


# Aantal metingen per periode

```{r}
table(stems_height$period)
unique(stems_height$year)

overview_heights_KV <- stems_height %>% 
  group_by(name_nl, period) %>% 
  summarize(aantal = n()) %>% 
  ungroup() %>% 
  pivot_wider(
    names_from = period,
    values_from = c(aantal),
    names_prefix = "periode" 
    )

write_csv2(overview_heights_KV,paste0(path_to_datarequest, "/overview_heights_KV.csv"))
```


# Hakhout meenemen?

Voor 't simpelste standaard meenemen tenzij indien afwijkend => zie onderstaande grafieken.

```{r tables, include=FALSE}
table(stems_height$period)
table(stems_height$ind_sht_cop)
table(stems_height$name_nl)
table(stems_height$crown_volume_reduction) # allemaal NA
table(stems_height$branch_length_reduction) # allemaal NA

table(stems_height$ind_sht_cop, stems_height$name_nl)

table(stems$species)

```


```{r HH_overzicht}
overview_HH_height <- stems_height %>% 
  group_by(ind_sht_cop, species, name_nl) %>% 
  summarize(aantal = n()) %>% 
  ungroup %>% 
  pivot_wider(names_from = ind_sht_cop, values_from = aantal) %>% 
  rename(individual = "10", coppice = "12") %>% 
  mutate(perc_hakhout = round(100*coppice/(individual + coppice), ))

overview_HH_height %>% arrange(desc(perc_hakhout)) %>% DT :: datatable(options = list(dom = 'rt'), rownames = FALSE, filter = "top") 

write.csv2(overview_HH_height, paste0(path_to_datarequest, "/overview_HH_height_KV.csv"))

```


## Grafiek


```{r vgl_individ_coppice_curve}
specieslist_coppice <- c(16, 39, 64)

# per soort
p1 <- ggplot(stems_height  %>% filter(species %in% specieslist_coppice), aes(dbh_mm, height_m)) + geom_point(aes(color = ind_sht_cop)) + geom_smooth() + facet_wrap(~species)
p1

```

```{r vgl_individ_coppice_curve2, eval = FALSE}
ggplot(stems_height %>% filter(species %in% specieslist_coppice), aes(dbh_mm, height_m)) + geom_point(aes(color = ind_sht_cop)) + geom_smooth(aes(color = ind_sht_cop)) 

ggplot(stems_height %>% filter(species %in% specieslist_coppice), aes(dbh_mm, height_m)) + geom_point() + geom_smooth() + facet_wrap(~ind_sht_cop)

ggplot(stems_height %>% filter(species %in% specieslist_coppice), aes(dbh_mm, height_m)) + geom_point(aes(color = ind_sht_cop)) + geom_smooth() 

# per soort
p1 <- ggplot(stems_height %>% filter(species %in% specieslist_coppice), aes(dbh_mm, height_m)) + geom_point(aes(color = ind_sht_cop)) + geom_smooth() + facet_wrap(~species)
p1

# eens alleen individuele bomen
p2 <- ggplot(stems_height %>% filter(species %in% specieslist_coppice & ind_sht_cop == 10), aes(dbh_mm, height_m)) + geom_point(aes(color = ind_sht_cop)) + geom_smooth() + facet_wrap(~species)
p2

grid.arrange(p1, p2, nrow = 2)
```


# Welke periodes gebruiken?

Kunnen we alle hoogtemetingen uit de drie periodes samengooien?
(2005 en 2013 en 2023)

## Tabel

```{r }
n1_h <- stems %>% filter(period == 1 & alive_dead == 11 & !is.na(height_m)) %>% nrow()
n2_h <- stems %>% filter(period == 2 & alive_dead == 11 & !is.na(height_m)) %>% nrow()
n3_h <- stems %>% filter(period == 3 & alive_dead == 11 & !is.na(height_m)) %>% nrow()

n1 <- stems %>% filter(period == 1) %>% nrow()
n2 <- stems %>% filter(period == 2) %>% nrow()
n3 <- stems %>% filter(period == 2) %>% nrow()

periode <- c("decade 1", "decade 2", "decade 3")
n_bomen <- c(n1, n2, n3)
n_hoogtes <- c(n1_h, n2_h, n3_h)
dt <- data.frame(periode, n_bomen, n_hoogtes)
dt %>% DT :: datatable(options = list(dom = 'rt'), rownames = FALSE) 
  
# table(stems_height$plot_id, stems_height$period)

```

Meer metingen in 2005, te weinig in 2013, geen in 2023 => beide gebruiken


## Grafiek

```{r vgl_all_1_vs_2_curve}
ggplot(stems_height, aes(dbh_mm, height_m)) + geom_point(aes(color = fperiod)) + geom_smooth(aes(color = fperiod)) 

# ggplot(stems_height, aes(dbh_mm, height_m)) + geom_point() + geom_smooth() + facet_wrap(~fperiod)
# 
# ggplot(stems_height, aes(dbh_mm, height_m)) + geom_point(aes(color = fperiod)) + geom_smooth()
                                                  
```

Niet veel verschil


## Besluit

Op basis van bovenstaande grafieken:  

- 1eSET: data 1e + 2eSET
- 2eSET: data 1e + 2eSET
- 3eSET: data 1e + 2eSET


# Per boomsoort

Met behulp van extra functies (zie `functions_dhcurves.R`) hierna heel eenvoudige 
dh-curves gemaakt: kwadratische functie obv logOmtrek, naar analogie met project 
dhcurves van ANB ikv de houtverkoop.

Alternatief is een eenvoudige smoother.

Dit zijn niet dezelfde curves als aangemaakt in FieldMap-IA.


```{r}
# Vooraf Omtrek en logOmtrek berekenen
stems_for_model <- stems_height %>%
  mutate(
    Omtrek = pi*.data$dbh_mm/1000,
    logOmtrek = log(.data$Omtrek),
    logOmtrek2 = .data$logOmtrek ^ 2)

```

```{r}
# zie functions_dhcurves.R (afgeleid van code uit project dhcurves van ANB ikv houtverkoop)

models_per_period <- fit.period(stems_for_model)

parameters_per_period <- modelparameters_per_period(models_per_period
                                                    , Data = stems_for_model)

stems_modeled_height <- stems_for_model %>% 
  left_join(parameters_per_period, by = c("species", "forest_reserve", "period")) %>% 
  mutate(height_per_period = Ad + Bd*logOmtrek + Cd*logOmtrek2)

# names(stems_modeled_height)
```



## Beuk

Kan het zijn dat er bij periode 1 een overschatting gebeurd is bij de metingen? 

```{r include=FALSE}
stems_height_beuk <- stems_modeled_height %>% filter(name_nl == "Beuk")

stems_height_beuk_p1 <- stems_height_beuk %>% filter(period == 1)
stems_height_beuk_p2 <- stems_height_beuk %>% filter(period == 2)
stems_height_beuk_p3 <- stems_height_beuk %>% filter(period == 3)

mean(stems_height_beuk_p1$height_m) # 30.6
mean(stems_height_beuk_p2$height_m) # 32
mean(stems_height_beuk_p3$height_m)

```


```{r vgl_beuk}
ggplot(stems_height_beuk, aes(dbh_mm, height_m)) + 
  geom_point(aes(color = fperiod)) + 
  geom_smooth(aes(y = height_per_period, group = fperiod, color = fperiod))  

ggplot(stems_height_beuk, aes(dbh_mm, height_m)) +
  geom_point(aes(color = fperiod)) +
  geom_smooth(aes(y = height_per_period))

ggplot(stems_height_beuk, aes(dbh_mm, height_m)) + 
  geom_point() + geom_smooth(aes(y = height_per_period)) + 
  facet_wrap(~fperiod)


```

```{r vgl_beuk_curve}
ggplot(stems_height_beuk, aes(dbh_mm, height_m)) + geom_point(aes(color = fperiod)) + geom_smooth(aes(color = fperiod)) 

# ggplot(stems_height_beuk, aes(dbh_mm, height_m)) + geom_point() + geom_smooth() + facet_wrap(~fperiod)

ggplot(stems_height_beuk, aes(dbh_mm, height_m)) + geom_point(aes(color = fperiod)) + geom_smooth()

```

Periode 2 ietsje hoger (1 m) => doorgroei, geen overschatting periode 1.


## Gewone esdoorn

```{r include=FALSE}
stems_height_esd <- stems_modeled_height %>% filter(name_nl == "Esdoorn (gewone)")

stems_height_esd_p1 <- stems_height_esd %>% filter(period == 1)
stems_height_esd_p2 <- stems_height_esd %>% filter(period == 2)
stems_height_esd_p3 <- stems_height_esd %>% filter(period == 3)

mean(stems_height_esd_p1$height_m, na.rm = T) # 12
mean(stems_height_esd_p2$height_m, na.rm = T) # 18
mean(stems_height_esd_p3$height_m, na.rm = T) 
```

In 2eSET maar heel weinig esdoorn opgemeten.

```{r vgl_esd}
ggplot(stems_height_esd, aes(dbh_mm, height_m)) + 
  geom_point(aes(color = fperiod)) + 
  geom_smooth(aes(y = height_per_period, group = fperiod, color = fperiod))  

# eenv. smoother
ggplot(stems_height_esd, aes(dbh_mm, height_m)) +
  geom_point(aes(color = fperiod)) +
  geom_smooth(aes(color = fperiod))

ggplot(stems_height_esd, aes(dbh_mm, height_m)) +
  geom_point(aes(color = fperiod)) +
  geom_smooth(aes(y = height_per_period))

ggplot(stems_height_esd, aes(dbh_mm, height_m)) + 
  geom_point() + geom_smooth(aes(y = height_per_period)) + 
  facet_wrap(~fperiod)

```

Niet zoveel verschil tss de curves, 2e set te weinig metingen voor afzonderlijke curve.


## Zomereik

```{r include=FALSE}
stems_height_eik <- stems_modeled_height %>% filter(name_nl == "Zomereik")

stems_height_eik_p1 <- stems_height_eik %>% filter(period == 1)
stems_height_eik_p2 <- stems_height_eik %>% filter(period == 2)
stems_height_eik_p3 <- stems_height_eik %>% filter(period == 3)

mean(stems_height_eik_p1$height_m, na.rm = T) # 22.8
mean(stems_height_eik_p2$height_m, na.rm = T) # 25
mean(stems_height_eik_p3$height_m)
```


```{r vgl_eik}
ggplot(stems_height_eik, aes(dbh_mm, height_m)) + 
  geom_point(aes(color = fperiod)) + 
  geom_smooth(aes(y = height_per_period, group = fperiod, color = fperiod))  

# eenv. smoother
ggplot(stems_height_eik, aes(dbh_mm, height_m)) +
  geom_point(aes(color = fperiod)) +
  geom_smooth(aes(color = fperiod))

ggplot(stems_height_eik, aes(dbh_mm, height_m)) +
  geom_point(aes(color = fperiod)) +
  geom_smooth(aes(y = height_per_period))

ggplot(stems_height_eik, aes(dbh_mm, height_m)) + 
  geom_point() + geom_smooth(aes(y = height_per_period)) + 
  facet_wrap(~fperiod)

```

Niet zoveel verschil tss de curves.
Periode 2 iets hoger, maar te weinig metingen voor afzonderlijke curve. 
Ook weinig verschil in hoogtes va nperiode 2: bijna allemaal ts 20 en 27.5 m, vrij vlakke curve.


# Dataset aanmaken voor import mbv Import2FM

Deze dataset dient omgevormd te worden zodat die makkelijk in te laden is mbv Import2FM.  
Dataset moet volgende velden bevatten:

- IDPlots = IDPlotsVirt
- IDTrees = unique_ID
- X
- Y
- Species
- DBH_mm
- Height_m
- AliveDead
- IntactSnag
- IndShtCop

Ter info ook nog volgende velden:  

- period
- plot_id
- tree_measure_id
- shoot_measure_id


```{r aanmaak_output}
# names(stems)
                        
unique_ID <- c(1:nrow(stems %>%
                        filter(alive_dead == 11 & intact_snag == 11
                               # & !plot_id %in% plots_to_exclude
                      )))

output <- stems %>% 
  filter(alive_dead == 11 & intact_snag == 11) %>% 
  mutate(height_m = ifelse((is.na(common_remark) |  common_remark != 90), height_m, NA)) %>% 
         # 90: uitgebroken top
  mutate(IDPlotsVirt = virt_plot) %>% 
  select(IDPlotsVirt
         , X = x_local
         , Y = y_local
         , Species = species
         , DBH_mm = dbh_mm
          ,Height_m = height_m
          ,AliveDead = alive_dead
          ,IntactSnag = intact_snag
          ,IndShtCop = ind_sht_cop
          ,period
         , plot_id
         ,tree_measure_id
         ,shoot_measure_id
  ) %>% 
  cbind(unique_ID)
  
# check
t <- unique(output$unique_ID)
nrow(output) - length(t) == 0

```


# Wegschrijven output

De resultaten worden weggeschreven naar **TblVirtueleTrees_KV_1e2e3eSET.xlsx**

```{r WegschrijvenOutput}
write_xlsx(output, paste0(path_to_datarequest, "/TblVirtueleTrees_KV_1e2e3eSET.xlsx"))

```


# Copy html to teamdrive

Na knitting - manueel

```{r eval = FALSE}
# Specify the path of the file you want to copy
source_file <- here::here(paste0("Scripts/AanmaakHoogteCurves/aanmaak_virt_trees_Jansheide_KV.html"))

# Specify the destination directory where you want to copy the file
destination_dir <- path_to_html

# Copy the file to the destination directory
file.copy(from = source_file, to = destination_dir, overwrite = TRUE)
# ? file.copy
```
