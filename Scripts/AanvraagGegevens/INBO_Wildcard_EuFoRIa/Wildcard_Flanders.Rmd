---
title: "Plot data from the Flemish forest reserve network - Wildcard"
author: "Anja Leyman"
date: "25/09/2024"  
output: 
  html_document:
    keep_md: FALSE
    number_sections: yes
    fig_caption: yes
    code_folding: hide
    toc: TRUE
    toc_float:
      collapsed: FALSE
      smooth_scroll: FALSE
---

```{r Rm, eval = FALSE}
rm(list=ls())
```

```{r Setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  eval = TRUE,
  message = FALSE,
  warning = FALSE, 
  fig.width = 7,
  fig.height = 3,
  fig.align = TRUE)

library(here)
library(writexl)
library(scales)
library(sf)


# libraries & invoergegevens
source(here::here("scripts/Setup.R"))
```


```{r Setup2}
# path_to_project <- "C:/03_BR/3_AanvraagGegevens/INBO_DigitaalVlaanderen"
path_to_project_teamdrive <- paste0(path_to_output_gdrive, "EUFORIA_WILDCARD_2024")

# path_to_datarequest <- paste0(path_to_project, "/output/")
path_to_datarequest_teamdrive <- paste0(path_to_project_teamdrive, "/output/")
path_to_html_teamdrive <- path_to_datarequest_teamdrive
# path_to_html <- path_to_datarequest

path_to_datacontrol <- paste0(path_to_project_teamdrive, "/datacontrole/")

```



# Request

This script creates the data as requested by Yannick De Win as part of the 
[Wildcard project](https://drive.google.com/drive/folders/0AHzOhlj-qFSnUk9PVA).

Data is collected over the whole of Europe. 

The script below generates all info and data according to the guidelines stipulated in this document: [DTF_Tree-Data-Template_final.xlsx](https://docs.google.com/spreadsheets/d/1jV4II-uSDDKaNNWqeBIXi6IQ_BSK_LFr?rtpof=true&usp=drive_fs)

<!-- Ik ga me niet bezig houden met link tss fieldmap-sites en euforia-sites. -->
<!-- Ik maak de data voor de FM-sites (BR + CP vs CA) en Yannick kan dan verder veratel naar Euforia-sites. -->


**Design  level data**
Data File Title: Institute_Design.txt

Tab "DESIGN_metadata"	provides explanations of the inventory design for each site and inventory year. 
It describes the inventory strategy, target woody structures used for sampling, 
spatial definition of the plots and the site, and others.	

DESIGN: This data table aggregates site-level information on inventory desing for each site and inventory year combination (e.g. Javorina and 2009 in the example below), providing site summaries of inventory design(s). The table describes the inventory strategy, target woody structures (sampled population), spatial definition of plots and sites, and others. Opposed to the plot-level PLOTS data table with one LPI or SPI plot per each row (one-to-one), this data table groups all plots with the same characteristics for each site and inventory year combination into one row (many-to-one = all plots of the same data collection design in a given inventory year are in one row). To list individual plots for each site and inventory year combination, please use the PLOTS data sheet instead.



**Plot level data**
Data File Title: Institute_Plots.txt

Tab "PLOT_metadata"	provides explanations of the plot-level data such as plot ID, coordinates and possibly also several topographic characteristics such as slope, exposition and elevation. Each SIP (as well as LIP) need to be uniquely described. This results in one row per each plot. 										
											
PLOTS: This data table describes the plot-level data by recording the plot-site relationship, plot ID, coordinates and possibly also several topographic characteristics such as slope, exposition and elevation. Each SPI and LPI plot needs to be uniquely described, resulting in one row per each plot. In contrast to the site-level DESIGN data table grouping all LPI or SPI plots of the same data collection design in a given inventory year into one row (many-to-one), this data table lists individual plots for each site and inventory year combination. To group all plots with the same characteristics for each site and inventory year combination, please use the DESIGN data sheet instead.



**Tree level data - standing**
Data File Title: Institute_Standing.txt
or: Institute_Standing_Site_ID.txt

Sheet "Standing_metadata" explains the recorded attributes of STANDING stems. These are divided into Basic strictly defined grey columns, where missing values are filled in as "NA"; coloured columns, where unused variants need to be deleted; and Extended attributes. Extended attributes are provided only if available.  Each data provider should clearly describe the methodology for measuring standing trees on their own research areas in the Standing_metadata.txt file;  for example: species code list, specification of height measurement, cause of death (extended).															
																
STANDING: This data table is designed to characterize alive and dead STANDING stems on a particular site, LPI or SPI, qualitative and quantitative attributes of each individual stem. These are divided into Basic strictly defined grey columns, where missing values are filled in as "NA"; coloured columns, where unused variants need to be deleted; and Extended attributes. Extended attributes are provided only if available. In case when the standing stem was measured in several inventories, the records are listed for each inventory on a separate row.													
										

**Tree level data - lying**
Data File Title: Institute_Lying.txt		
or: Institute_Lying_Site_ID.txt		

Sheet "Lying_metadata" explains the recorded attributes of LYING stems (object sampling). These are divided into Basic strictly defined grey columns, where unavailable values are filled in as "NA"; coloured columns, where unused variants need to be deleted; and Extended attributes. Extended attributes are provided only if available. Each data provider should clearly describe the methodology for measuring lying stems on their own research sites in the Lying_metadata.txt file; for example: specification of the point of upper end diameter measurement, decay classification, method of volume calculation of lying stems/pieces (extended), etc.												
													
LYING: This data table is designed to provide obect-based descriptions of LYING stems on a particular site, LPI or SPI, i.e. qualitative and quantitative attributes of each individual stem. These are divided into Basic strictly defined grey columns, where missing values are filled in as "NA"; coloured columns, where unused variants need to be deleted; and Extended attributes. Extended attributes are provided only if available. In case when the lying stem was measured in several inventories, the records are listed for each inventory on a separate line.														
					

**Coarse Woody Debris - Line Intersect**
Data File Title: Institute_CWD.txt
Institute_CWD_Site_ID.txt

Sheet "CWD_metadata" contains explanations of attributes of coarse woody debris (CWD data sheet) which is about plot level deadwood volume estimates, but unlike LYING data table does not include information on individual objects - dead stems and decaying logs. Please provide your methodology.													
														
CWD:	This data table is designed to provide plot level estimates of coarse woody debris volume (by line intersect sampling) summed by species and decay classes.

- path_to_fieldmap_db is "`r path_to_fieldmap_db`"      
- path_to_project_teamdrive is "`r path_to_project_teamdrive`"      
- path_to_datarequest_teamdrive is "`r path_to_datarequest_teamdrive`"      

```{r results='hide', eval=TRUE}
path_to_fieldmap_db
# path_to_datarequest
path_to_project_teamdrive
path_to_datarequest_teamdrive

```

# Important information

This script creates data tables only of our processed data, using the dataframes

- `list_plots`: only processed plots; one record per plot_id, period and INVENTORY_YEAR
- `list_BR`: corresponding reserves, one record per type of plot (CA and CP), period 
and INVENTORY_YEAR (in some reserves we see two different INVENTORY YEAR's per period); 
contains PLOTS_LIST with all the plotid's included


Difference between `plotdata_def` and `list_plots`:   

- `plotdata_def`: separate records for A3 and A4 (circular plots)      
- `list_plots`: one record per plot_id   


In Flanders trees, not stems, are coupled through time. 

=> PLOTS: `CONSISTENT_ID_STANDING` = P (NA for first survey)    
=> STANDING: coppice => `CONSISTENT_ID` = N; individuel tree => CONSISTENT_ID = Y        







# PLOTS data

SITE_ID	SITE_NAME			LPI_ID	SPI_ID		SLOPE	TOPO	EXPO	ELEV_CENTER	ELEV_RANGE
		WILDCARD_sub_ID	INVENTORY_YEAR CIRCLE_NO	CIRCLE_RADIUS	PLOT_SAMPLED	SAMPLED_AREA	CONSISTENT_ID_STANDING	CONSISTENT_ID_LYING	OTHER	X	Y	Z	WKT_GEOM		
		
LPI_ID	Plot ID in Large plot inventory (LPI) within the site (reserve).    
SPI_ID	Plot ID in Sampling plot inventory (SPI) grid within the site (reserve).

=> plot_id's van CA en CP's afzonderlijk

**Wordt opgeslagen in `plotdata_def`**

## Load plotinfo

Plotinfo samenstellen

```{r processed_plots, results = 'hide', eval = FALSE}
plotinfo_ <- load_plotinfo(database = path_to_fieldmap_db, 
                          processed = FALSE)
names(plotinfo_)

plotinfo_ %>% filter(is.na(survey_number) & survey_trees == TRUE)
table(plotinfo_$data_processed)

plotinfo_ <- plotinfo_ %>% 
  filter(survey_trees == TRUE)

plotinfo_ %>% filter(data_processed == FALSE)

non_processed <- plotinfo_ %>% 
  filter(data_processed == FALSE)

table(non_processed$forest_reserve, non_processed$period)
table(non_processed$forest_reserve, non_processed$plottype)
```

Twee bosreservaten nog niet (helemaal) processed:     

- één kernvlaktes (Kerss: plot 1999 = Rogister+)    
- één set van cirkelplots (With heide).  

**We gaan enkel verder met de processed data.**   
Vertrekken van info_survey uit strata-db

```{r plotinfo}
con <- odbcConnectAccess2007(path_to_strata_db)
  info_survey_ <- sqlFetch(con, "info_survey", stringsAsFactors = FALSE)
  info_XY <- sqlFetch(con, "strata_location", stringsAsFactors = FALSE)
  info_beheer <- sqlFetch(con, "strata_remaining", stringsAsFactors = FALSE)
  strata_soil <- sqlFetch(con, "strata_soil", stringsAsFactors = FALSE) %>% 
    select(Unieknr, plot_id, SiteName, SubArea, forest_reserve_fieldmap)
odbcClose(con)

# unieknr 11001 tem 11006 zijn delen van Kerss
info_survey_ <- info_survey_ %>% 
  filter(!Unieknr %in% c(11001, 11002, 11003, 11004, 11005, 11006))


# strata_soil enkel nodig om SubArea van Sevendonck te onderscheiden (A vs Q)
# andere subarea's zijn enkel verwarrend en hier niet nodig
subarea_sevendonck <- strata_soil %>% 
  filter(forest_reserve_fieldmap == "Sevendonck") %>% 
  select(plot_id, forest_reserve_fieldmap, subarea = SubArea)
```


## Afwijkingen Kersselaerspleyn   

! Attention: standing trees (L+D) in plot 11000 (core area Kersselaerspleyn) measured 
in 1986 and 2000 have a treshold of 30 cm DBH (instead of 5 cm)

! Attention: volume of lying deadwood per decaystage/diameter class is unknown for circular plots 
Kersselaerspleyn (2001-2065) 1st survey (2000)
If necessary volume and species can be derived from old inventory report: "CP_Kerss_logs_2000.xlsx" (C:/03_BR/1_DataVerwerkingBR/Data/Meetgegevens/logs_CPs_Kerss_2000) 
**=> geen deadwood in CP's Kersselaerspleyn 1eSET (2000)**

! Attention: standing trees (L+D) in plot 11000 (core area Kersselaerspleyn) measured 
in 1986 only contains trees still standing in 2000
**=> we nemen 1986 hier niet mee**

! No (lying) deadwood measurements in 1986 and 2000 in plot 11000 (core area Kersselaerspleyn)    
! In 2010 and 2020 treshold for lying deadwood measurements is 40 cm
<!-- (51 intacte liggende dode bomen in KV Kerss) -->

```{r}
info_survey <- info_survey_ %>% 
  filter(!(plot_id == 11000 & period == 0))
```


## Variables

SITE_ID	SITE_NAME			LPI_ID	SPI_ID		SLOPE	TOPO	EXPO	ELEV_CENTER	ELEV_RANGE
WILDCARD_sub_ID	INVENTORY_YEAR CIRCLE_NO	CIRCLE_RADIUS	PLOT_SAMPLED	SAMPLED_AREA
CONSISTENT_ID_STANDING	CONSISTENT_ID_LYING	OTHER	X	Y	Z	WKT_GEOM		
		
LPI_ID	Plot ID in Large plot inventory (LPI) within the site (reserve).
SPI_ID	Plot ID in Sampling plot inventory (SPI) grid within the site (reserve).

=> plot_id's van CA en CP's afzonderlijk in een kolom

```{r results = 'hide'}
names(info_survey)
info_survey <- info_survey %>% 
  rename(forest_reserve_fieldmap = forest_reserve)

# tijdelijk nog geen link leggen - mogelijks aan Yannick overlaten
plotdata0 <- info_survey %>%
  # enkel plots waar XY van berekend is => inner_join
  # (niet 52000 en 61000: immers enkel 1eSet een opname, dan niet meer)
  inner_join(info_XY %>% select(Unieknr, XLon_wgs84, YLat_wgs84, Z_m_TAW), by = c("Unieknr")) %>% 
  # left_join(link_WC_FM, by = c(forest_reserve_fieldmap", plottype))
  mutate(SITE_ID = NA, SITE_NAME = NA, WILDCARD_sub_ID = NA
         , INVENTORY_YEAR = year_dendro
         , LPI_ID = ifelse(plottype == "CA", plot_id, NA)
         , SPI_ID = ifelse(plottype == "CP", plot_id, NA)
         # , CIRCLE_NO = ifelse(plottype == "CP", "1 / 2", NA)   #zie verder
         # , CIRCLE_RADIUS = ifelse(plottype == "CP", "rA4 / rA3", NA) #zie verder
         , PLOT_SAMPLED = "Y"  # enkel processed data hier
         , SAMPLED_AREA = ifelse(plottype == "CP", pi*rA4_m^2, CoreArea_ha*10000)   # in m2
         , CONSISTENT_ID_STANDING = ifelse(survey_number > 1, "P", NA)  
         # NA voor 1ste survey, P voor alle andere (want is op niveau van de stems, 
         # dus niet OK voor hakhout)
             # If you chose P, specify in the STANDING sheet which stems could not be 
             # reidentified and were assigned new IDs. 
         , CONSISTENT_ID_LYING = ifelse(survey_number > 1, "N", NA)  
         , OTHER = NA
         # coord= Coordinate system (epsg code) used is specified in DESIGN sheet. If using WSG 84 (epsg code 4623), use decimal format with precision up to centimeters.
         , X = XLon_wgs84
         , Y = YLat_wgs84
         , Z = Z_m_TAW
         ) %>% 
  # onderscheid A en Q cirkelplots Sevendonck ...
  left_join(subarea_sevendonck, by = c("forest_reserve_fieldmap", "plot_id")) %>% 
  # forest_reserve_fieldmap_new aanmaken
  # om verder te kunnen koppelen aan site-id's wildcard
  mutate(forest_reserve_fieldmap_new = ifelse(!is.na(subarea) & subarea == "Alder forest SFR", "Sevendonck A",
                                         ifelse(!is.na(subarea) & subarea == "Oak forest SFR", "Sevendonck Q",
                                                forest_reserve_fieldmap))
         ) %>% 
  select(-subarea)

names(plotdata0)

```

Ontdubbelen van cirkelplots (A3 en A4)
<!-- zijn de stralen van de subcircles constant doorheen de tijd?: hoeven we nu niet eens meer te weten -->

Ook bewaren van STANDING_ALIVE_THRESHOLD	STANDING_DEAD_THRESHOLD	LYING_ALIVE_THRESHOLD	LYING_DEAD_THRESHOLD
voor aanmaak "design_data" (zie verder)

```{r tresholds, results = 'hide'}
names(info_survey)
# add extra rows per subcircle
tresholds_ <- info_survey %>% 
  # filter(plottype == "CP") %>% 
  group_by(forest_reserve_fieldmap, plottype, period
           , rA3_m, rA4_m, CoreArea_ha
           # STANDING_ALIVE_THRESHOLD
           , TresHoldDBH_A3_alive_mm, TresHoldDBH_A4_alive_mm, TresHoldDBH_CoreArea_alive_mm
           # STANDING_DEAD_THRESHOLD
           , TresHoldDBH_A3_dead_mm, TresHoldDBH_A4_dead_mm, TresHoldDBH_CoreArea_dead_mm
           # LYING_ALIVE_THRESHOLD
           # LYING_DEAD_THRESHOLD: A3 en A4 zelfde
           , TresHoldDiam_Deadw_A4_mm, TresHoldDiam_Deadw_CoreArea_mm
           ) %>% 
  summarize(n = n()) %>% 
  ungroup()

```

Enkel bij Kersselaersplein gaat rA3 van 9m (survey 1) naar 12m (survey 2 en 3) 
=> rekening mee houden voor "CONSISTENT_ID_STANDING": wordt "NA" voor die 1ste periode én "N" voor de 2de periode

Ontdubbelen van cirkelplots (A3 en A4), met uitz van deze waar rA3 = rA4
(Liedekerke en Withoefse heide)

```{r results = 'hide'}
names(tresholds_)
names(plotdata0)

# lang formaat maken van de cirkelplots binnen tresholds_
CP_tresholds <- tresholds_ %>% 
  filter(plottype == "CP") %>% 
  pivot_longer(cols = c("rA3_m", "rA4_m")) %>% 
  mutate(CIRCLE_NO = ifelse(name == "rA4_m", 1, 
                            ifelse(name == "rA3_m", 2, NA))
         , STANDING_ALIVE_THRESHOLD = ifelse(name == "rA4_m", TresHoldDBH_A4_alive_mm, 
                            ifelse(name == "rA3_m", TresHoldDBH_A3_alive_mm, NA))
         , STANDING_DEAD_THRESHOLD =  ifelse(name == "rA4_m", TresHoldDBH_A4_dead_mm, 
                            ifelse(name == "rA3_m", TresHoldDBH_A3_dead_mm, NA))
         , LYING_DEAD_THRESHOLD = TresHoldDiam_Deadw_A4_mm
         , LYING_ALIVE_THRESHOLD = LYING_DEAD_THRESHOLD
           ) %>% 
  select(forest_reserve_fieldmap, period, plottype,
         CIRCLE_NO, CIRCLE_RADIUS = value,
         STANDING_ALIVE_THRESHOLD, STANDING_DEAD_THRESHOLD,
         STANDING_DEAD_THRESHOLD, LYING_DEAD_THRESHOLD, LYING_ALIVE_THRESHOLD
         )

# CA's selecteren
CA_tresholds <- tresholds_ %>% 
  filter(plottype == "CA") %>% 
  mutate(CIRCLE_NO = NA, CIRCLE_RADIUS = NA
         , STANDING_ALIVE_THRESHOLD = TresHoldDBH_CoreArea_alive_mm
         , STANDING_DEAD_THRESHOLD =  TresHoldDBH_CoreArea_dead_mm
         , LYING_DEAD_THRESHOLD = TresHoldDiam_Deadw_CoreArea_mm
         , LYING_ALIVE_THRESHOLD = LYING_DEAD_THRESHOLD) %>% 
  select(forest_reserve_fieldmap, period, plottype, 
         CIRCLE_NO, CIRCLE_RADIUS,
         STANDING_ALIVE_THRESHOLD, STANDING_DEAD_THRESHOLD,
         STANDING_DEAD_THRESHOLD, LYING_DEAD_THRESHOLD, LYING_ALIVE_THRESHOLD
         )

# samenvoegen
CP_CA_tresholds <- rbind(CA_tresholds, CP_tresholds)

  
# wegfilteren van deze waar rA3 = rA4
check_rA3A4gelijk <- CP_CA_tresholds %>% 
  filter(plottype == "CP") %>% 
  group_by(forest_reserve_fieldmap, period, CIRCLE_RADIUS) %>% 
  summarize(n= n()) %>% 
  ungroup() %>% 
  filter(n > 1)

# Liedekerke en Withoefse heide effectief rA3 = rA4
CP_CA_tresholds <- CP_CA_tresholds %>% 
  filter(!(forest_reserve_fieldmap %in% c("Liedekerke", "Withoefse heide") & CIRCLE_NO == 2))


```

```{r combine, results = 'hide'}
names(plotdata0)
names(CP_CA_tresholds)
# groeperen per plot-id (geen)
plotdata <- plotdata0 %>% 
  left_join(CP_CA_tresholds, by = c("forest_reserve_fieldmap", "period", "plottype"))

plotdata %>% filter(plot_id == 11000)
plotdata %>% filter(plot_id == 205)
plotdata %>% filter(plot_id == 101)
```
CONSISTENT_ID_STANDING: aanpassen voor Kerss, CP's survey 2: niet gekoppeld, want 
rA3 gaat van 9m (survey 1) naar 12m (survey 2 en 3) 
=> "CONSISTENT_ID_STANDING": "NA" voor de 1ste periode (= standaard), én "N" voor de 2de periode

```{r}
plotdata <- plotdata %>% 
  mutate(CONSISTENT_ID_STANDING = 
           ifelse(forest_reserve_fieldmap == "Kersselaerspleyn" & 
                    survey_number == 2 & plottype == "CP"
                  , "N"
                  , CONSISTENT_ID_STANDING)
  )
     
```


SITE_ID	SITE_NAME			LPI_ID	SPI_ID		SLOPE	TOPO	EXPO	ELEV_CENTER	ELEV_RANGE
WILDCARD_sub_ID	INVENTORY_YEAR CIRCLE_NO	CIRCLE_RADIUS	PLOT_SAMPLED	SAMPLED_AREA
CONSISTENT_ID_STANDING	CONSISTENT_ID_LYING	OTHER	X	Y	Z	WKT_GEOM		
		

```{r plotdata_vars, results = 'hide'}
names(plotdata)

plotdata_def <- plotdata %>%
  select(INVENTORY_YEAR
         # , SITE_ID, SITE_NAME, WILDCARD_sub_ID
         , LPI_ID, SPI_ID
         , CIRCLE_NO, CIRCLE_RADIUS
         , PLOT_SAMPLED, SAMPLED_AREA
         , CONSISTENT_ID_STANDING, CONSISTENT_ID_LYING, OTHER
         , X, Y, Z
         # extra vars
         , forest_reserve_fieldmap, forest_reserve_fieldmap_new
         , plot_id, plottype, period
         )


#check
plotdata_def %>% filter(plot_id == 101)
plotdata_def %>% filter(plot_id == 205)
plotdata_def %>% filter(plot_id == 1101)
plotdata_def %>% filter(plot_id == 11000)
```

```{r}
names(plotdata_def)
```

# Overview plots and forest reserves

```{r table_BR}
# unique(plotdata_def$forest_reserve_fieldmap)
# names(plotdata_def)

plotdata_def %>% group_by(forest_reserve_fieldmap_new, plottype, LPI_ID) %>% 
  summarize(n_surveys = n_distinct(INVENTORY_YEAR)
            , min_year = min(INVENTORY_YEAR)
            , max_year = max(INVENTORY_YEAR)) %>% 
  ungroup() %>% 
  dplyr::select(forest_reserve_fieldmap = forest_reserve_fieldmap_new # Sevendonck A en Q
                , plottype, n_surveys, min_year, max_year) %>%  
    DT :: datatable(filter = 'top', options = list(dom = 'rt'), rownames = FALSE)  

```



```{r list_plots, results='hide'}
list_plots <- plotdata_def %>% 
  select(plot_id, period
         , forest_reserve_fieldmap_new
         , plottype
         , X, Y, Z, LPI_ID, SPI_ID, INVENTORY_YEAR, 
         , CONSISTENT_ID_STANDING, CONSISTENT_ID_LYING
         , SAMPLED_AREA) %>% 
  unique()

t <- list_plots %>% filter(str_detect(forest_reserve_fieldmap_new, "Sevendonck"))
list_plots %>% filter(is.na(forest_reserve_fieldmap_new)) %>% nrow() == 0
list_plots %>% filter(forest_reserve_fieldmap_new == "Everzwijnbad" & period == 3)

nrow(plotdata_def); nrow(list_plots)*2
# enkel de CP's hebben twee records in plotdata_def: A3 en A4 => +/- gelijk
```


```{r list_BR, results ='hide'}
names(list_plots)
list_BR <- list_plots %>% 
  group_by(forest_reserve_fieldmap_new, plottype, period, INVENTORY_YEAR) %>% 
  summarize(n_periods = n_distinct(period)
            , n_plots = n_distinct((plot_id))
            , plot_id_min = min(plot_id)
            , plot_id_max = max(plot_id)
            , PLOTS_LIST = paste(plot_id, collapse = ";")
  ) %>% 
  ungroup() %>% 
  mutate(plot_id = ifelse(plottype == "CA"
                               , as.character(plot_id_min)
                               , paste0(plot_id_min, "-", plot_id_max)
                               )) %>% 
  select(-plot_id_min, -plot_id_max)

# t2 <- list_BR_ %>% 
#   anti_join(list_BR, by = c("forest_reserve_fieldmap", "plottype", "PLOTS_LIST"))

list_BR %>% filter(str_detect(forest_reserve_fieldmap_new,"Sevendonck"))
list_BR %>% filter(str_detect(forest_reserve_fieldmap_new,"Everzw") & period == 3)
```

## Different inventory years, same period

**Ter info**: sommige reservaten hebben per 
opname-periode toch twee verschillende jaartallen voor `INVENTORY_yEAR`.
Zo bv.Zwaenepoel 2nd extension: de dendro werd opgemeten tss 8/1/2020 en 15/5/2020
=> `INVENTORY_YEAR` is deels 2019 (voor 1/5/2020) en deels 2020 (na 1/5/2020), 
aangezien er voor gekozen werd om alles wat voor 1 mei opgemeten wordt bij 
het voorafgaande kalenderjaar/groeiseizoen te voegen.

Ook bij de andere reservaten blijkt het eerste jaar steeds de hoofdmoot van 
opnames.
Dit heeft als gevolg dat er voor deze reservaten dubbel zoveel records zijn in 
`INBO_design.txt`.

Het gaat om volgende bosreservaten:

```{r}
# list_BR %>% group_by(forest_reserve_fieldmap, period, plottype, subarea) %>% 
#   summarise(n = n()) %>% ungroup() %>% filter(n > 1)

dubbbel_BR <- list_BR %>% group_by(forest_reserve_fieldmap_new, period, plottype) %>% 
  summarise(n = n()) %>% ungroup() %>% filter(n > 1)

list_BR %>% inner_join(dubbbel_BR) %>% 
  select(forest_reserve = forest_reserve_fieldmap_new, plottype
         , period, INV_YEAR = INVENTORY_YEAR, n_plots) %>% 
  DT::datatable()
# telkens een aantal plots net op een later moment opgemeten 
# het eerste jaar is steeds de hoofdmoot van opnames, maar eigenlijk correcter 
# om deze met een ander INVENTORY YEAR te behouden 
```



# STANDING data

Data File Title: Institute_Standing.txt
or: Institute_Standing_Site_ID.txt

Sheet "Standing_metadata" explains the recorded attributes of STANDING stems. These are divided into Basic strictly defined grey columns, where missing values are filled in as "NA"; coloured columns, where unused variants need to be deleted; and Extended attributes. Extended attributes are provided only if available.  Each data provider should clearly describe the methodology for measuring standing trees on their own research areas in the Standing_metadata.txt file;  for example: species code list, specification of height measurement, cause of death (extended).															
																
STANDING: This data table is designed to characterize alive and dead STANDING stems on a particular site, LPI or SPI, qualitative and quantitative attributes of each individual stem. These are divided into Basic strictly defined grey columns, where missing values are filled in as "NA"; coloured columns, where unused variants need to be deleted; and Extended attributes. Extended attributes are provided only if available. In case when the standing stem was measured in several inventories, the records are listed for each inventory on a separate row.		

**Wordt opgeslagen in `standing`**

## Load data dendrometry														


```{r load_lkp}
con <- odbcConnectAccess2007(path_to_fieldmap_db)

  qIndShootCop <- sqlFetch(con, "qIndShootCop", stringsAsFactors = FALSE)
  # deadw_test <- sqlFetch(con, "Deadwood_3eSET", stringsAsFactors = FALSE)
  qAliveDead <- sqlFetch(con, "qAliveDead", stringsAsFactors = FALSE)
  qSpecies <- sqlFetch(con, "qSpecies", stringsAsFactors = FALSE)
  qDecaystage <- sqlFetch(con, "qdecaystage", stringsAsFactors = FALSE)
  qIntactSnag <- sqlFetch(con, "qIntactSnag", stringsAsFactors = FALSE)
  qiufrovitality <- sqlFetch(con, "qiufrovitality", stringsAsFactors = FALSE)
  qcommonremark <- sqlFetch(con, "qcommonremark", stringsAsFactors = FALSE)
  qVdagnVfm <- sqlFetch(con, "qVdagnVfm", stringsAsFactors = FALSE)
  
odbcClose(con)

# 
qIndShootCop <- qIndShootCop %>% select(ID, ind_sht_cop_txt = Value1)
qIntactSnag <- qIntactSnag %>% select(ID, intact_snag_txt = Value1)
qAliveDead <- qAliveDead %>% select(ID, alive_dead_txt = Value1)
qSpecies <- qSpecies %>% select(ID, name_nl = Value1, name_sc = Value2)
qDecaystage <- qDecaystage %>% select(ID, decaystage_txt = Value2)
qiufrovitality <- qiufrovitality %>% select(ID, vitality_txt = Value2) %>% 
  unique() %>% filter(ID < 40)
qVdagnVfm <- qVdagnVfm %>% select(ID, intact_fragment_txt = Value1)

```


```{r load_dendro}
#names(plotdata_def)
data_dendro <- load_data_dendrometry(database = path_to_fieldmap_db
                                     , processed = TRUE 
                                     , extra_variables = TRUE)

data_shoots <- load_data_shoots(database = path_to_fieldmap_db
                                , extra_variables = TRUE)
```



## Unique tree-id 

CONSISTENT_ID_STANDING	
The identification numbers of standing stems from the previous inventory year were 
completely (Y), partly (P) reidentified or were not reidentified (N).
If you chose P, specify in the STANDING sheet which stems could not be reidentified and 
were assigned new IDs. 
For single-inventory sites and the first (oldest) inventories, fill in NA.

---

In Flanders trees, not stems, are coupled through time.

The function `create_unique_tree_id()` from package forrescalc, allows us to create unique
id's on **tree level** (based on old_id en coppice_id)
NOT on stem level!

=> plotdata_def: CONSISTENT_ID_STANDING = P (see above)    
=> standing_def: coppice => CONSISTENT_ID = N; individuel tree => CONSISTENT_ID = Y        

```{r create_unique_tree_id, results='hide'}
# ?create_unique_tree_id
data_dendro <- create_unique_tree_id(data_dendro)
names(data_dendro)
```


```{r }
data_dendro %>% filter(is.na(tree_id)) %>% nrow() == 0
```

```{r}
# check - ok
t <- data_dendro %>% 
  filter(plot_id == 53000 & tree_measure_id %in% c(11495, 11483, 256, 119)) %>% 
  select(plot_id, period
         , tree_id, tree_measure_id, old_id, coppice_id
         , ind_sht_cop, alive_dead, species)
```


```{r check_coppice}
t <- data_dendro %>% 
  filter(ind_sht_cop == 12) %>% 
  select(plot_id, period
         , tree_id, tree_measure_id, old_id, coppice_id
         , ind_sht_cop, alive_dead, species)

```

## Calculate dendro

```{r results='hide'}
data_stems <- compose_stem_data(data_dendro, data_shoots, extra_variables = TRUE)

height_model <- load_height_models()

data_deadwood <- load_data_deadwood(database = path_to_fieldmap_db, processed = TRUE)
data_deadwood <- calc_intact_deadwood(data_deadwood)  # overschrijft calc_volume_m3 uit db met volume intacte boom

data_stems_calc <- calc_variables_stem_level(data_stems, height_model)

summary(data_stems_calc)

# check tree_id
data_stems_calc %>% filter(is.na(tree_id))
# t <- data_stems_calc %>% group_by(tree_id, ind_sht_cop) %>% 
#   summarise(n = n()) %>% ungroup()
```


## Select processed plots

Enkel de dendro data van de reservaten die in `list_plots` zitten (idem als plots in `plotdata_def`).

```{r}
standing0 <- data_stems_calc %>% 
  inner_join(list_plots, by = c("plot_id", "period", "plottype"))

t <- standing0 %>% group_by(forest_reserve_fieldmap_new, plottype, year) %>% 
  summarise(n_trees = n(), n_plots = n_distinct(plot_id)) %>% ungroup()

# check - niet opgenomen
not_included <- data_stems_calc %>% 
  anti_join(plotdata_def %>% select(plot_id, period),
             by = c("plot_id", "period"))

t2 <- not_included %>% group_by(forest_reserve, plottype, year) %>% 
  summarise(n_trees = n(), n_plots = n_distinct(plot_id)) %>% ungroup()

# nrows?
nrow(standing0) == nrow(data_stems_calc) - t2$n_trees[1] - t2$n_trees[2]
nrow(list_plots) == 1891
```
## Variables

SITE_ID	LPI_ID	SPI_ID	TREE_ID	STEM_ID	INVENTORY_YEAR	CONSISTENT_ID	
STATUS : LIFE	POSITION	INTEGRITY	
HEIGHT	DATE


FULL_SCIENTIFIC	GENUS	SPECIES	CODE	ABBREVIATION

DBH_cm	DBH_mm

DECAY	: NUMERIC	TEXT
X	Y	Z	AZIMUTH	DISTANCE	WKT_GEOM

EXTENDED																
HOM_m	STATUS2	CAUSE_OF_DEATH	VOLUME	SUN_EXP	RED_FACTOR	HABITAT1	HABITAT2	HABITAT3	INSECT	CAVITIES	FUNGI	BARK_DAMAGE	BREAK_TYPE	VITALITY	LAYER	TAG

```{r extra vars}
# tijdelijk extra vars mee selecteren, vooraleer weg te schrijven terug verwijderen
extra_vars <- c("forest_reserve_fieldmap_new", "plot_id", "plottype", "period")
```

```{r standing_vars, results='hide'}
names(standing0)
unique(plotdata_def$CONSISTENT_ID_STANDING)
names(qSpecies)
names(qDecaystage)

# !! nog tree_id toevoegen en obdaarvan CONSISTENT_ID
# = sowieso NA in eerste survey

standing <- standing0 %>%
  left_join(qSpecies %>% select(-name_nl), by = c("species" = "ID")) %>% 
  left_join(qDecaystage, by = c("decaystage" = "ID")) %>% 
  left_join(qiufrovitality, by = c("iufro_vital" = "ID")) %>% 
  # left_join(list_plots) %>% 
  mutate(TREE_ID = tree_id
         , STEM_ID = shoot_measure_id
         , CONSISTENT_ID = ifelse(CONSISTENT_ID_STANDING == "P"
                                  # op stemniveau => "Y" voor single trees, "N" voor coppice
                                  , ifelse(ind_sht_cop == 10, "Y", "N")
                                  , CONSISTENT_ID_STANDING)
         , LIFE	= ifelse(alive_dead == 12, "D", "A")  # Life can be in form of Alive (A) or Dead (D). 
         , POSITION	= "S"
         , INTEGRITY = ifelse(intact_snag == 10, "F", "C")	 # Complete (C) or Fragmented (F)
         , HEIGHT = height_m # measured!
         , DATE =  date_dendro # Date of measurement of particular stem (format yyyy-mm-dd): 2002-12-01.
         , DBH_mm = dbh_mm
         , TREE_SPECIES_FULL_SCIENTIFIC = name_sc
         , TREE_SPECIES_CODE = species	
         , DECAY_NUMERIC = ifelse(alive_dead == 12, decaystage, NA)
         , DECAY_TEXT = ifelse(alive_dead == 12, decaystage_txt, NA)
         , X = X + x_local
         , Y = Y + y_local	
         , HOM_m = 1.3
         , HEIGHT_model = ifelse(intact_snag == 11, round(calc_height_m, 1), NA)
         , VOLUME = round(vol_bole_m3, 2)
         , VITALITY = vitality_txt
         ) %>% 
  select(LPI_ID,	SPI_ID,	TREE_ID,	STEM_ID,	INVENTORY_YEAR,	CONSISTENT_ID
         , LIFE, POSITION, INTEGRITY, 
         , HEIGHT, DATE
         , TREE_SPECIES_FULL_SCIENTIFIC, TREE_SPECIES_CODE
         , DBH_mm
         , DECAY_NUMERIC, DECAY_TEXT
         , X,	Y
         , HOM_m, HEIGHT_model, VOLUME, VITALITY
         , all_of(extra_vars)
         # , forest_reserve_fieldmap, plot_id, plottype, period
         , tree_measure_id
         )

#check
standing %>% filter(plot_id == 101)
t <- standing %>% filter(plot_id == 1101)
standing %>% filter(plot_id == 2001)
standing %>% filter(plot_id == 11000)

```

```{r}
names(standing)
```


# LYING data

Sheet "Lying_metadata" explains the recorded attributes of LYING stems (object sampling). These are divided into Basic strictly defined grey columns, where unavailable values are filled in as "NA"; coloured columns, where unused variants need to be deleted; and Extended attributes. Extended attributes are provided only if available. Each data provider should clearly describe the methodology for measuring lying stems on their own research sites in the Lying_metadata.txt file; for example: specification of the point of upper end diameter measurement, decay classification, method of volume calculation of lying stems/pieces (extended), etc.												
													
LYING: This data table is designed to provide obect-based descriptions of LYING stems on a particular site, LPI or SPI, i.e. qualitative and quantitative attributes of each individual stem. These are divided into Basic strictly defined grey columns, where missing values are filled in as "NA"; coloured columns, where unused variants need to be deleted; and Extended attributes. Extended attributes are provided only if available. In case when the lying stem was measured in several inventories, the records are listed for each inventory on a separate line.														

**Wordt opgeslagen in `lying`**

## Select processed plots

```{r results='hide'}
names(data_deadwood)
names(list_plots)

lying0 <- data_deadwood %>% 
  inner_join(list_plots, by = c("plot_id", "period", "plottype"))

t <- lying0 %>% group_by(forest_reserve_fieldmap_new, plottype, year) %>% 
  summarise(n_trees = n(), n_plots = n_distinct(plot_id)) %>% ungroup()

# check - niet opgenomen
not_included <- data_deadwood %>% 
  anti_join(plotdata_def %>% select(plot_id, period),
             by = c("plot_id", "period"))

t2 <- not_included %>% group_by(forest_reserve, plottype, year) %>% 
  summarise(n_trees = n(), n_plots = n_distinct(plot_id)) %>% ungroup()

# nrows?
nrow(lying0) == nrow(data_deadwood) - t2$n_trees[1]
nrow(list_plots) == 1891
```
				
				
## Variables				

SITE_ID	LPI_ID	SPI_ID	
TREE_ID	STEM_ID	PIECE_ID	
INVENTORY YEAR	CONSISTENT_ID	
DATE
LIFE	POSITION	INTEGRITY	

TREE_SPECIES FULL_SCIENTIFIC CODE
DBH_mm D1_mm D2_mm
LENGTH
DECAY NUMERIC TEXT

VOLUME


```{r lying_vars, results='hide'}
names(lying0)
unique(list_plots$CONSISTENT_ID_LYING)
names(qSpecies)
names(qDecaystage)
unique(lying0$intact_fragm)
unique(lying0$decaystage)

lying <- lying0 %>%
  left_join(qSpecies %>% select(-name_nl), by = c("species" = "ID")) %>% 
  left_join(qDecaystage, by = c("decaystage" = "ID")) %>% 
  left_join(qVdagnVfm, by = c("intact_fragm" = "ID")) %>% 
  mutate(TREE_ID = NA
         , STEM_ID = NA
         , PIECE_ID = lying_deadw_id
         , CONSISTENT_ID = ifelse(CONSISTENT_ID_LYING == "N"
                                  , "N"   # 
                                  , CONSISTENT_ID_LYING) # N of NA
         , LIFE	= "D"  # liggend is steeds dood bij ons
         , POSITION	= "L"
         , INTEGRITY = ifelse(intact_fragm == 10, "C", "F")	 # Complete (C) or Fragmented stem (F)
         , DATE =  date_dendro # Date of measurement of particular stem (format yyyy-mm-dd): 2002-12-01.
         , TREE_SPECIES_FULL_SCIENTIFIC = name_sc
         , TREE_SPECIES_CODE = species	
         , DBH_mm = ifelse(intact_fragm == 10, max_diam_mm, NA) # Diameter at distance of 1.3 m from the lower end of the lying log.
         , D1_mm = ifelse(intact_fragm == 10, NA, max_diam_mm)  
         #Diameter of the lower end, ev. nog bij te snijden
         , D2_mm = ifelse(intact_fragm == 10, NA, min_diam_mm) 
         # Diameter of the upper end of the lying log, ev. nog bij te snijden
         
         # x1, x2 en y1, y2 nog berekenen : deel dat IN plot valt cfr script Arno
         # , X_1 = X + x_1
         # , X_2 = X + x_2
         # , Y_1 = Y + x_1
         # , Y_2 = Y + x_1
         , LENGTH = round(calc_length_m, 1)
         , DECAY_NUMERIC = ifelse(decaystage == 0, NA, decaystage)
         , DECAY_TEXT = decaystage_txt
         , VOLUME = round(calc_volume_m3, 2)
         ) %>% 
  select(LPI_ID,	SPI_ID,	TREE_ID,	STEM_ID, PIECE_ID
         , INVENTORY_YEAR,	CONSISTENT_ID
         , LIFE, POSITION, INTEGRITY, 
         , DATE
         , TREE_SPECIES_FULL_SCIENTIFIC, TREE_SPECIES_CODE
         , DBH_mm, D1_mm, D2_mm
         # , X_1, X_2, Y_1, Y_2
         , LENGTH
         , DECAY_NUMERIC, DECAY_TEXT
         , VOLUME
         , all_of(extra_vars)
         # , forest_reserve_fieldmap_new, plot_id, plottype, period
         )

names(lying)
table(lying$DECAY_NUMERIC)
table(lying$DECAY_TEXT)

#check
lying %>% filter(plot_id == 101)
lying %>% filter(plot_id == 2001)
lying %>% filter(plot_id == 11000)


```

```{r}
names(lying)
```


# CWD data

Sheet "CWD_metadata" contains explanations of attributes of coarse woody debris (CWD data sheet) which is about plot level deadwood volume estimates, but unlike LYING data table does not include information on individual objects - dead stems and decaying logs. Please provide your methodology.													
														
CWD:	This data table is designed to provide plot level estimates of coarse woody debris volume (by line intersect sampling) summed by species and decay classes.

SITE_ID
SPI_ID
TREE_SPECIES
DECAY
VOLUME

**Wordt opgeslagen in `cwd`**

## Load LIS data

Het package forrescalc berekent deze data nog niet => rechtstreeks uit de databank te halen

Enkel uitgevoerd bij 
- Wijnendale CP
- Everzwijnbad CP
- Heirnisse CA: nog niet verwerkt

```{r results='hide'}
range(list_plots$INVENTORY_YEAR)
BR_LIS <- list_plots %>% 
  filter(INVENTORY_YEAR >= 2021 & plot_id < 11000)
unique(BR_LIS$forest_reserve_fieldmap)
```

```{r load_LIS, results='hide'}
# enkel bij 3eSET beschikbaar
query_LIS <- 
    "SELECT lis.IDPlots AS plot_id, 
    lis.IDLineIntersect_3eSet, 
    lis.ID, 
    lis.TreeSpecies AS species,
    lis.AliveDead,
    lis.DecayStage AS decaystage,
    lis.Diameter_mm AS diam_mm, 
    lis.Angle as angle_cde
    FROM LI_data_3eSet lis;"

con <- odbcConnectAccess2007(path_to_fieldmap_db)
  data_LIS_ <- sqlQuery(con, query_LIS, stringsAsFactors = TRUE)
  qLIangle <- sqlFetch(con, "qLIangle", stringsAsFactors = TRUE) %>% 
    select(ID, angle = Value2)
odbcClose(con)


names(data_LIS_)
nrow(data_LIS_)  # 991
range(data_LIS_$plot_id)
unique(data_LIS_$AliveDead) == 12  # enkel dood
```
```{r results='hide'}
data_LIS <- data_LIS_ %>% 
  mutate(period = 3) %>% 
  inner_join(list_plots %>% select(plot_id, forest_reserve_fieldmap_new, period))

unique(data_LIS$forest_reserve_fieldmap_new)

data_LIS %>% filter(is.na(diam_mm)) %>% nrow() == 0
data_LIS %>% filter(is.na(angle_cde)) %>% nrow() == 0
# mocht er in toekomst voor degrees niks ingevuld staan 
# => vervangen door "0" (anders geen berekening mogelijk voor die plot)

data_LIS <- data_LIS %>% 
 left_join(qLIangle, by = c("angle_cde" = "ID"))

```


```{r results='hide'}
colnames(data_LIS)
summary(data_LIS) # ok

Li<-45  # lengte van de drie transecten   

cwd_ <- data_LIS %>%
  mutate(diam_m = diam_mm/1000) %>% 
  dplyr::group_by(plot_id, period, species, decaystage) %>%
  dplyr::summarise(
    volume_m3_m2=pi^2/8/Li*sum((diam_m^2)/cos(angle*pi/180),na.rm=TRUE)) %>% 
  ungroup()
# bij mogelijkse verwarring tss VBI en BR: VBI rekent obv diam_cm en komt m3/ha uit, 
# BR gebruikt diam_m en komt m3/m2 uit

 
```



## Variables				

SITE_ID	SPI_ID	
INVENTORY YEAR	
TREE_SPECIES	
DECAY	
VOLUME


```{r cwd_vars, results='hide'}
## Add variables from reserve
cwd0 <- cwd_ %>% 
  inner_join(list_plots, by = c("plot_id", "period"))

names(cwd0)
names(qSpecies)
names(qDecaystage)
unique(cwd0$decaystage) # 12 13 11 14 10 15

cwd <- cwd0 %>%
  left_join(qSpecies %>% select(-name_nl), by = c("species" = "ID")) %>% 
  left_join(qDecaystage, by = c("decaystage" = "ID")) %>% 
  mutate(TREE_SPECIES_FULL_SCIENTIFIC = name_sc
         , TREE_SPECIES_CODE = species	
         , DECAY_NUMERIC = ifelse(decaystage == 0, NA, decaystage)
         , DECAY_TEXT = decaystage_txt
         , VOLUME = round(volume_m3_m2 * SAMPLED_AREA, 2)
         ) %>% 
  select(SPI_ID
         , INVENTORY_YEAR
         , TREE_SPECIES_FULL_SCIENTIFIC, TREE_SPECIES_CODE
         , DECAY_NUMERIC, DECAY_TEXT
         , VOLUME
         , all_of(extra_vars)
         # , forest_reserve_fieldmap_new, plot_id, plottype, period
         )

names(cwd)
table(cwd$DECAY_NUMERIC)
table(cwd$DECAY_TEXT)

#check
cwd %>% filter(plot_id == 101)

```

```{r}
names(cwd)
```



# DESIGN data

Request:
SITE_ID	SITE_NAME	WILDCARD_sub_ID	INVENTORY_YEAR	INVENTORY_TYPE	PLOTS_LIST	CIRCLE_NO	CIRCLE_RADIUS	CIRCLE_AZIMUTH	CIRCLE_DISTANCE	POM_MARK	STANDING_ALIVE_THRESHOLD	STANDING_DEAD_THRESHOLD	LYING_ALIVE_THRESHOLD	LYING_DEAD_THRESHOLD	SPECIES_POOL	LIS_CWD	BOUNDARY	STEM_COORD_REF_POINT	EPSG_CODE

Coordinate system (epsg code) used is specified in DESIGN sheet. If using WSG 84 (epsg code 4623), use decimal format with precision up to centimeters.

**Wordt opgeslagen in `design_def`**

## Variables

SITE_ID	SITE_NAME	WILDCARD_sub_ID	INVENTORY_YEAR	
INVENTORY_TYPE	PLOTS_LIST	
CIRCLE_NO	CIRCLE_RADIUS	CIRCLE_AZIMUTH	CIRCLE_DISTANCE	
POM_MARK	
STANDING_ALIVE_THRESHOLD	STANDING_DEAD_THRESHOLD	LYING_ALIVE_THRESHOLD	LYING_DEAD_THRESHOLD	
SPECIES_POOL	
LIS_CWD	
BOUNDARY	STEM_COORD_REF_POINT	EPSG_CODE

```{r results='hide'}
names(plotdata)
names(plotdata_def)
names(list_BR)

design_ <- plotdata %>%
  left_join(list_BR %>% select(forest_reserve_fieldmap_new, plottype
                               , period, INVENTORY_YEAR
                               , PLOTS_LIST)) %>% 
  group_by(INVENTORY_YEAR
           , forest_reserve_fieldmap_new, plottype, period
           , PLOTS_LIST
           , CIRCLE_NO, CIRCLE_RADIUS
           , STANDING_ALIVE_THRESHOLD, STANDING_DEAD_THRESHOLD
           , LYING_DEAD_THRESHOLD, LYING_ALIVE_THRESHOLD) %>% 
  summarize(n_plots = n()) %>% 
  ungroup() %>% 
  left_join(cwd %>% group_by(forest_reserve_fieldmap_new, period, plottype) %>% 
              summarize() %>% ungroup() %>% 
              mutate(cwd_survey = TRUE)
            , by = c("forest_reserve_fieldmap_new", "plottype", "period")) %>% 
  # left_join(link_WC_FM, by = c("forest_reserve_fieldmap", plottype))
  mutate(INVENTORY_TYPE = ifelse(plottype == "CA", "LPI", 
                                   ifelse(plottype == "CP", "SPI", NA))
         # , PLOTS_LIST
         , CIRCLE_AZIMUTH = ifelse(plottype == "CP", 0, NA)  # centre of the appropriate sub-circle
         , CIRCLE_DISTANCE = ifelse(plottype == "CP", 0, NA)  # centre of the appropriate sub-circle
         , POM_MARK = "N"
         , SPECIES_POOL = "AWS"  # all woody species
         # LIS enkel bij Wijnendale en Everzwijnbad, CP's, decade3
         , LIS_CWD = ifelse(cwd_survey & !is.na(cwd_survey), "Y", "N")
         , STEM_COORD_REF_POINT = "BHC"
         , EPSG_CODE = "4326"  # GCS_WGS_1984 - EPSG:4326
         ) 

names(design_)
nrow(design_)  # 108
t <- design_ %>% filter(str_detect(forest_reserve_fieldmap_new,"Sevendonck"))
design_ %>% filter(str_detect(forest_reserve_fieldmap_new,"Kerss"))
```


```{r}
design_def <- design_ %>%
  select(INVENTORY_YEAR
         # ,SITE_ID, SITE_NAME, WILDCARD_sub_ID # op einde pas link leggen
         , INVENTORY_TYPE
         , PLOTS_LIST
         , CIRCLE_NO, CIRCLE_RADIUS
         , CIRCLE_AZIMUTH, CIRCLE_DISTANCE, 
         , POM_MARK
         , STANDING_ALIVE_THRESHOLD, STANDING_DEAD_THRESHOLD
         , LYING_ALIVE_THRESHOLD, LYING_DEAD_THRESHOLD
         , SPECIES_POOL 
         , LIS_CWD
         # , BOUNDARY: NIET, shapefiles te bezorgen
         , STEM_COORD_REF_POINT, EPSG_CODE
         # extra vars (! zonder plot_id)
         , forest_reserve_fieldmap_new, plottype, period
         )

names(design_def)
```

# Link wildcard_id

Helemaal naar achteren, want `list_plots` nodig en die is gemaakt obv 
processed data.

Dan pas alles koppelen.

Wildcard id's:

- SITE_ID	
- SITE_NAME	
- WILDCARD_sub_ID

=> link met onze FM-id's van de reservaten

- plot_id
- period
- forest_reserve_fieldmap_new  (Sevendonck A/Q ipv Sevendonck)
- plottype


```{r link_DESIGN, results='hide'}
link_WC_FM <- read_xlsx(paste0(path_to_project_teamdrive, "/LINK_WILDCARD_fieldmap_Yannick_AL.xlsx")) %>% 
  select(-forest_reserve_fieldmap)

names(link_WC_FM)
names(design_def)

design_def_link <- design_def %>% 
  left_join(link_WC_FM %>% select(-comment, -subarea, -`LPI_ID / SPI_ID`)
            , by = c("forest_reserve_fieldmap_new", "plottype")) %>% 
  select(SITE_ID, SITE_NAME, WILDCARD_sub_ID
         , everything())

```

```{r results='hide'}
# check
t <- design_def_link %>% filter(str_detect(forest_reserve_fieldmap_new, "Sevendonck"))
names(list_BR)
names(list_plots)
t2 <- design_def_link %>% filter(forest_reserve_fieldmap_new == "Kersselaerspleyn")
t3 <- design_def_link %>% filter(str_detect(SITE_NAME, "Zoni"))

# zonder link
t <- design_def_link %>% filter(is.na(SITE_ID))
t$forest_reserve_fieldmap_new # De Heide (Meerdaal) - managed site => ok!
```

```{r results='hide'}
design_def_link_ <- design_def_link %>% 
  filter(!is.na(SITE_ID))

nrow(design_def_link_) == nrow(design_def_link) - 2

design_def_link <- design_def_link_
```

```{r link_PLOTS, results='hide'}
names(link_WC_FM)
names(plotdata_def)

plotdata_def_link <- plotdata_def %>% 
  left_join(list_BR %>% select(forest_reserve_fieldmap_new, plottype
                               , period, INVENTORY_YEAR)) %>% 
  left_join(link_WC_FM %>% select(-comment, -subarea, -`LPI_ID / SPI_ID`)
            , by = c("forest_reserve_fieldmap_new", "plottype")) %>% 
  select(SITE_ID, SITE_NAME, WILDCARD_sub_ID
         , everything())

nrow(plotdata_def_link) == nrow(plotdata_def) 
```

```{r results='hide'}
# check
t <- plotdata_def_link %>% filter(forest_reserve_fieldmap_new == "Sevendonck A")
names(list_BR)
names(list_plots)
t2 <- plotdata_def_link %>% filter(forest_reserve_fieldmap_new == "Everzwijnbad")

# zonder link
t <- plotdata_def_link %>% filter(is.na(SITE_ID))
range(t$SPI_ID, na.rm = T) # 1401 1452 - De Heide (Meerdaal) - managed site => ok!
```

```{r results='hide'}
plotdata_def_link_ <- plotdata_def_link %>% 
  filter(!is.na(SITE_ID))

nrow(plotdata_def_link_) == nrow(plotdata_def_link) - nrow(t)

plotdata_def_link <- plotdata_def_link_
```


```{r link_STANDING, results='hide'}
names(link_WC_FM)
names(standing)

standing_link <- standing %>% 
  left_join(list_BR %>% select(forest_reserve_fieldmap_new, plottype
                               , period, INVENTORY_YEAR)) %>% 
  left_join(link_WC_FM %>% select(-comment, -subarea, -`LPI_ID / SPI_ID`)
            , by = c("forest_reserve_fieldmap_new", "plottype")) %>% 
  select(SITE_ID, SITE_NAME, WILDCARD_sub_ID
         , everything())

nrow(standing_link) == nrow(standing) 
nrow(standing_link %>% filter(is.na(SITE_ID))) == nrow(standing_link %>% filter(forest_reserve_fieldmap_new == "De heide"))

standing_link <- standing_link %>% 
  filter(!is.na(SITE_ID))
```


```{r link_LYING, results='hide'}
names(link_WC_FM)
names(lying)

lying_link <- lying %>% 
  left_join(list_BR %>% select(forest_reserve_fieldmap_new, plottype
                               , period, INVENTORY_YEAR)) %>% 
  left_join(link_WC_FM %>% select(-comment, -subarea, -`LPI_ID / SPI_ID`)
            , by = c("forest_reserve_fieldmap_new", "plottype")) %>% 
  select(SITE_ID, SITE_NAME, WILDCARD_sub_ID
         , everything())

nrow(lying_link) == nrow(lying) 
nrow(lying_link %>% filter(is.na(SITE_ID))) == nrow(lying_link %>% filter(forest_reserve_fieldmap_new == "De heide"))

lying_link <- lying_link %>% 
  filter(!is.na(SITE_ID))
```


```{r link_CWD, results='hide'}
names(link_WC_FM)
names(cwd)

cwd_link <- cwd %>% 
  left_join(list_BR %>% select(forest_reserve_fieldmap_new, plottype
                               , period, INVENTORY_YEAR)) %>% 
  left_join(link_WC_FM %>% select(-comment, -subarea, -`LPI_ID / SPI_ID`)
            , by = c("forest_reserve_fieldmap_new", "plottype")) %>% 
  select(SITE_ID, SITE_NAME, WILDCARD_sub_ID
         , everything())

nrow(cwd_link) == nrow(cwd) 
nrow(cwd_link %>% filter(is.na(SITE_ID))) == nrow(cwd_link %>% filter(forest_reserve_fieldmap_new == "De heide"))

cwd_link <- cwd_link %>% 
  filter(!is.na(SITE_ID))
```


# Wegschrijven output

De resultaten worden weggeschreven naar txt (Separator = tab, Decimal =	.): 

- INBO_Design.txt
- INBO_Plots.txt   
- INBO_Standing.txt   
- INBO_Lying.txt   
- INBO_CWD.txt   

Daarnaast ook volgende lookuplijsten:   

- qSpecies.txt   
- qDecaystage.txt   
- qVitality.txt  

En tenslotte de shapefiles van de CA-plots en de grens van het reservaat (voor de CP's)
ipv veld "BOUNDARY" in DESIGN.txt (gevraagd aan Yannick (mail 25/9/2024)):   

- It defines the geometry of *site boundaries* and *LPI plot boundaries*. 
  Site boundary is indicated by the black line in Fig. 1A. 
  If possible fill in as a well-known text geometry (WKT).
  e.g. type Polygon for site boundary or one LPI plot, MultiPolygon for site boundary + one or multiple LIP plots. 

- Alternatively please provide shapefiles.

```{r final_check, eval = FALSE}
#
summary(lying_link)
# 45 NA's voor D1/2: OK, want intacte bomen
# 88 nA's voor decay - OK, kan
names(lying)
names(lying0)
t <- lying0 %>% filter(is.na(calc_volume_m3)) %>% 
  select(forest_reserve, plottype
         , plot_id, period, year, lying_deadw_id
         , intact_fragm
         , species
         , contains(c("calc", "total", "diam", "vol")))
t %>% distinct(forest_reserve, plottype)
# period 3: nog niet bijgewerkt (calc_volume inside plot en bijwerken calc_volume)
# ok 25/9/2024

#
summary(cwd_link)

#
summary(standing_link)
standing_link %>% filter(is.na(VOLUME))
standing0 %>% filter(is.na(vol_bole_m3)) %>% 
  select(plot_id, period
         , tree_id, tree_measure_id, old_id, coppice_id
         , ind_sht_cop, alive_dead, species, intact_snag
         , contains(c("m2", "m3")))
# !! intact_snag = 12, maar geen hoogte - ok; (intact van gemaakt in moederdb)

#
summary(plotdata_def_link)
plotdata_def_link %>% filter(is.na(SAMPLED_AREA))
plotdata_def_link %>% filter(SITE_ID == 7) # OK, opgelost

#
summary(design_def_link)
design_def_link %>% filter(is.na(LYING_DEAD_THRESHOLD)) %>% distinct(SITE_NAME, WILDCARD_sub_ID, period)
# OK, geen deadwood opname gebeurd
```

```{r}
# check voor NA's site-id
names(design_def_link)
col <- c("SITE_ID", "SITE_NAME", "INVENTORY_YEAR")

design_def_link %>% filter_at(col, any_vars(is.na(.)))
plotdata_def_link %>% filter_at(col, any_vars(is.na(.)))
standing_link %>% filter_at(col, any_vars(is.na(.)))
lying_link %>% filter_at(col, any_vars(is.na(.)))
cwd_link %>% filter_at(col, any_vars(is.na(.)))

```


```{r EENMALIG_deadw_bijwerken_moederdb, eval=FALSE}
# enkel deadw_3eSET
qry_update_calc_vol <- paste0("UPDATE Deadwood_3eSET SET Deadwood_3eSET.CalcVolume_m3 = Deadwood_3eSET.Volume_m3 WHERE ((Deadwood_3eSET.CalcVolume_m3 Is Null) AND (Deadwood_3eSET.IntactFragment=20))") %>%
           noquote()

qry_update_calc_length <- "UPDATE Deadwood_3eSET SET Deadwood_3eSET.CalcLength_m = Deadwood_3eSET.Length_m WHERE ((Deadwood_3eSET.CalcLength_m) Is Null)" %>%
           noquote()
  
conn <- odbcConnectAccess2007(path_to_fieldmap_db)

sqlQuery(conn,qry_update_calc_vol)
sqlQuery(conn,qry_update_calc_length)

odbcClose(conn)
```




```{r WegschrijvenOutput, eval = FALSE}
# zonder extra variables  "forest_reserve_fieldmap_new" "plot_id" "plottype" "period" 
# extra_vars

write.table(design_def_link %>% select(-forest_reserve_fieldmap_new, plottype, period)
            , paste0(path_to_datarequest_teamdrive, "INBO_Design.txt")
            , sep = " ", dec = ".")

write.table(plotdata_def_link %>% select(-all_of(extra_vars))
            , paste0(path_to_datarequest_teamdrive, "INBO_Plots.txt")
            , sep = " ", dec = ".")

write.table(standing_link %>% select(-all_of(extra_vars), -tree_measure_id)
            , paste0(path_to_datarequest_teamdrive, "INBO_Standing.txt")
            , sep = " ", dec = ".")
# lookuplists
write.table(qSpecies, paste0(path_to_datarequest_teamdrive, "qSpecies.txt")
            , sep = " ", dec = ".")
write.table(qDecaystage, paste0(path_to_datarequest_teamdrive, "qDecaystage.txt")
            , sep = " ", dec = ".")
write.table(qiufrovitality, paste0(path_to_datarequest_teamdrive, "qVitality.txt")
            , sep = " ", dec = ".")


write.table(lying_link %>% select(-all_of(extra_vars))
            , paste0(path_to_datarequest_teamdrive, "INBO_Lying.txt")
            , sep = " ", dec = ".")

write.table(cwd_link %>% select(-all_of(extra_vars))
            , paste0(path_to_datarequest_teamdrive, "INBO_CWD.txt")
            , sep = " ", dec = ".")
```



# Copy html to teamdrive

Na knitting - manueel

```{r eval = FALSE}
# Specify the path of the file you want to copy
source_file <- here::here(paste0("Scripts/AanvraagGegevens/INBO_Wildcard_EuFoRIa/Wildcard_Flanders.html"))

# Specify the destination directory where you want to copy the file
destination_dir <- path_to_html_teamdrive

# Copy the file to the destination directory
file.copy(from = source_file, to = destination_dir, overwrite = TRUE)
# ? file.copy
```
