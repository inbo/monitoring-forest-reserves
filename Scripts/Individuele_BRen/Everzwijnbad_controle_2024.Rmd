---
title: "Dataverwerking - controle"
subtitle: "Everzwijnbad - cirkelplots & kernvlakte"
author: "Anja Leyman"
date: "`r Sys.Date()`"
output: 
  html_document:
    keep_md: FALSE
    number_sections: yes
    fig_caption: yes
    code_folding: hide
    toc: TRUE
    toc_float:
      collapsed: TRUE
      smooth_scroll: TRUE
---

```{r Rm, eval = FALSE}
rm(list=ls())
```

```{r Setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  eval = TRUE,
  message = FALSE,
  warning = FALSE, 
  fig.width = 7,
  fig.height = 3,
  fig.align = TRUE)

library(here)
library(writexl)
library(scales)


# libraries & invoergegevens
source(here::here("scripts/Setup.R"))

```


```{r Setup2}
forestreserve <- "Everzwijnbad"
forestreserve_short <- forestreserve
# forestreserve_short <- "Wijnendale"
plot_type <- "CA"
plot_type <- "CP"

forestreserve_folder <- paste0(path_to_reserves, "4b_Everzw_DEELS")

path_to_datarequest <- paste0(forestreserve_folder, "/verwerking_2024_1e2e3eSET/output_forrescalc/")
path_to_datarequest_teamdrive <- paste0(path_to_teamdrive, "PRJ_BR_Gegevensverwerking/per_gebied/2024_", forestreserve_short, "/output_forrescalc/")
path_to_html_teamdrive <- paste0(path_to_teamdrive, "PRJ_BR_Gegevensverwerking/per_gebied/2024_", forestreserve_short, "/")

# plots_to_exclude <- c(701, 707, 709, 727, 728, 738, 739, 740, 759, 760)

path_to_datacontrol <- paste0(path_to_teamdrive, "PRJ_BR_Gegevensverwerking/per_gebied/2024_", forestreserve_short, "/datacontrole/")
```


TIJDELIJK `path_to_fieldmap_db` aanpassen naar export van wijnendale en everzwijnbad uit moederdb (4/3/2024)

```{r Path_tmp}
path_to_fieldmap_db <- "C:/03_BR_db_monitoring/3_db_Els_deel2_Wijn_Ever/FieldMapData_3_db_Els_deel2_Wijn_Ever.accdb"

```



# Vraagstelling

**Bosreservaat `r forestreserve`**

Datacontrole nalv opnames 3de decade, gebruik makend van (nieuwe) forrescalc.

<br>


```{r results='hold', eval=TRUE}
path_to_forresdat_data
path_to_analysis_set_db
path_to_plotlevel_csv
path_to_treelevel_csv
path_to_output_gdrive
path_to_meetgegevens

```


# Load lookuplijsten

```{r load_lkp}
con <- odbcConnectAccess2007(path_to_fieldmap_db)

  qind_shoot_cop <- sqlFetch(con, "qIndShootCop", stringsAsFactors = FALSE)
  # deadw_test <- sqlFetch(con, "Deadwood_3eSET", stringsAsFactors = FALSE)
  qalive_dead <- sqlFetch(con, "qAliveDead", stringsAsFactors = FALSE)
  qspecies <- sqlFetch(con, "qSpecies", stringsAsFactors = FALSE)
  qdecaystage <- sqlFetch(con, "qdecaystage", stringsAsFactors = FALSE)
  qintact_snag <- sqlFetch(con, "qIntactSnag", stringsAsFactors = FALSE)
  qVdagnVfm <- sqlFetch(con, "qVdagnVfm", stringsAsFactors = FALSE)
    
  qcommonremark <- sqlFetch(con, "qcommonremark", stringsAsFactors = FALSE)
  qcrown_vol_redu <- sqlFetch(con, "qCrownVolRedu", stringsAsFactors = FALSE)
  qBranchLenghtReduction <- sqlFetch(con, "qBranchLenghtReduction", stringsAsFactors = FALSE)

  qiufroheight <- sqlFetch(con, "qiufroheight", stringsAsFactors = FALSE)
  qiufroheight_shoots <- sqlFetch(con, "qiufroheight_shoots", stringsAsFactors = FALSE)
  qiufrovitality <- sqlFetch(con, "qiufrovitality", stringsAsFactors = FALSE)
  qiufrovitality_shoots <- sqlFetch(con, "qiufrovitality_shoots", stringsAsFactors = FALSE)
  qiufrosocialstatus <- sqlFetch(con, "qiufrosocialstatus", stringsAsFactors = FALSE)
  qiufrosocialstatus_shoots <- sqlFetch(con, "qiufrosocialstatus_shoots", stringsAsFactors = FALSE)
  
odbcClose(con)

```

# Check

Met behulp van controlefuncties in package `forrescalc`.

## Overkoepelende functie

```{r check_fmdb}
# missing data
incorrect_data <- check_data_fmdb(database = path_to_fieldmap_db, forest_reserve = forestreserve)  

nrow(incorrect_data) # 6757
view(incorrect_data)
names(incorrect_data)

```

```{r}

incorrect_overview <- incorrect_data %>% 
  group_by(period, layer, aberrant_field, anomaly) %>% 
  summarize(n = n()) %>% 
  ungroup()

incorrect_overview %>% DT :: datatable(options = list(pageLength = 10), rownames = FALSE, filter = "top")
#                   colnames = c('Soort', 'aantal hoogtes', 'aantal hoogtes hakhout', 'aandeel hakhout (%)')) 
```

Veel "missing" => met Peter overleggen hoe we daarmee gaan omgaan

Een paar "echte" of beter mogelijke fouten: deze alvast doorgeven aan Peter.

```{r}
incorrect_except_missing <- incorrect_data %>% 
  filter(anomaly != "missing")

nrow(incorrect_except_missing)

```

```{r}

incorrect_overview <- incorrect_except_missing %>% 
  group_by(period, layer, aberrant_field, anomaly) %>% 
  summarize(n = n()) %>% 
  ungroup()

incorrect_overview %>% DT :: datatable(options = list(pageLength = 10), rownames = FALSE, filter = "top")
```



## Functies per topic

```{r check_deadw, eval = FALSE}
incorrect_deadwood <- check_data_deadwood(database = path_to_fieldmap_db, forest_reserve = forestreserve)  

nrow(incorrect_deadwood)
view(incorrect_deadwood)


```


```{r check_dendro, eval = FALSE}
# trees
incorrect_trees <- check_data_trees(database = path_to_fieldmap_db, forest_reserve = forestreserve)  

nrow(incorrect_trees)
view(incorrect_trees)

# shoots
incorrect_shoots <- check_data_shoots(database = path_to_fieldmap_db, forest_reserve = forestreserve)  

nrow(incorrect_shoots)
view(incorrect_shoots)

#trees evolution - ev. rbind met trees
incorrect_trees_evolution <- check_trees_evolution(database = path_to_fieldmap_db, forest_reserve = forestreserve)  

nrow(incorrect_trees_evolution)
view(incorrect_trees_evolution)
incorrect_trees_evolution
```


```{r check_reg, eval = FALSE}
# regeneration
incorrect_regeneration <- check_data_regeneration(database = path_to_fieldmap_db, forest_reserve = forestreserve)  

nrow(incorrect_regeneration)
view(incorrect_regeneration)

# regspecies
incorrect_regspecies <- check_data_regspecies(database = path_to_fieldmap_db, forest_reserve = forestreserve)  

nrow(incorrect_regspecies)
view(incorrect_regspecies)
```


```{r check_veg, eval = FALSE}
# vegetation
incorrect_vegetation <- check_data_vegetation(database = path_to_fieldmap_db, forest_reserve = forestreserve)  

nrow(incorrect_vegetation)
view(incorrect_vegetation)

# herblayer
incorrect_herblayer <- check_data_herblayer(database = path_to_fieldmap_db, forest_reserve = forestreserve)  

nrow(incorrect_herblayer)
view(incorrect_herblayer)
```





```{r check_plots, eval = FALSE}
# plots
incorrect_plots <- check_data_plots(database = path_to_fieldmap_db, forest_reserve = forestreserve)  

nrow(incorrect_plots)
view(incorrect_plots)

# plotdetails
incorrect_plotdetails <- check_data_plotdetails(database = path_to_fieldmap_db, forest_reserve = forestreserve)  

nrow(incorrect_plotdetails)
view(incorrect_plotdetails)
```










# Processed

We controleren of er nog plots "not processed" zijn.

```{r plotinfo_load, eval = FALSE}
plotinfo <- load_plotinfo(database = path_to_fieldmap_db) %>% 
  filter(forest_reserve == forestreserve)
names(plotinfo)
```


```{r check_processed, results='hide', eval = FALSE}
# enkel checken bij deze waar er een dendro-opname gebeurd is
# anders ook deze van vorige decades mee, die niet kunne processed zijn
check_processed <- plotinfo %>% 
  filter(survey_trees == TRUE)

table(check_processed$forest_reserve, check_processed$data_processed)
# table(plotinfo$forest_reserve, plotinfo$data_processed)
```

```{r check_not_processed, results='hide', eval = FALSE}
plotinfo_check <- plotinfo %>% 
  group_by(forest_reserve, plottype, period, survey_trees, data_processed) %>% 
  summarize(n_plots = n()) %>% 
  ungroup()

plotinfo_check %>% 
  filter(survey_trees == TRUE & data_processed == FALSE)

# omgekeerd geen plots die processed zijn, en géén survey_trees
plotinfo %>%  filter(data_processed & !survey_trees) %>% nrow() == 0
```


**!! OPGEPAST:** nadat de data gecontroleerd zijn door Peter, moet veld `processed` aangepast worden.

Met behulp van een updatequery voor een vooraf geselecteerde decade, plottype en bosreservaat zetten we `DataProcessed_YN` op `10` (code 10 = 'ja'), indien `Survey_Trees_YN = 10`. 

```{r update_processed, eval = FALSE}
# Predefined strings
decade <- "3" 
# plot_type <- "CP"
# forestreserve <- "Wijnendalebos"

# Construct the query string using sprintf
query_update <- paste0(sprintf("UPDATE (PlotDetails_%seSET pd 
                         INNER JOIN Plots p ON pd.IDPlots = p.ID) 
                         INNER JOIN qPlotType q ON p.Plottype = q.ID 
                         SET pd.DataProcessed_YN = 10 
                         WHERE (pd.Survey_Trees_YN = 10) 
                         AND (q.Value3 = '%s') 
                         AND (pd.ForestReserve = '%s')",
                         decade, plot_type, forestreserve)
                       ) %>% noquote()

   sqlQuery(con,query_update)

odbcClose(con)

```


```{r plotinfo_load2, eval=FALSE}
plotinfo <- load_plotinfo(database = path_to_fieldmap_db) %>% 
  filter(forest_reserve == forestreserve)
names(plotinfo)
```

In het geval van `r forestreserve` gaat het om volgende plots die na de eerste decade niet 
meer heropgemeten werden:     

```{r eval = FALSE}
plotinfo %>% filter(survey_trees == FALSE) %>% distinct(plot_id)
```



# Export

Resultaten worden opgeslagen als csv op c-schijf en in teamdrive:

```{r}
path_to_datarequest
path_to_datarequest_teamdrive

```

Enkele verduidelijkingen:

* "number_of_tree_species" = aantal soorten obv de levende bomen

* "stems_per_tree" = meerstammigheid (stem_number_ha / number_of_trees_ha): heeft hier geen zin, maar dient als insteek voor berekeningen per soort

* "vol_bole_alive_m3_ha" en "vol_bole_dead_m3_ha": volume zonder crown, 
versus "vol_alive_m3_ha" en "vol_dead_standing_m3_ha"

* "vol_log_m3_ha": liggend dood hout (NA als er geen deadwood survey gebeurd is)

* "vol_deadw_m3_ha": staand en liggend dood hout (NA als er geen deadwood survey gebeurd is)


```{r save, eval=FALSE}
save_results_xlsx(
    results = list(plotinfo = plotinfo),
    output_dir = path_to_datarequest
  )

save_results_xlsx(
    results = dendro_plotinfo,
    output_dir = path_to_datarequest
  )

```


```{r save_teamdrive, eval=FALSE}
save_results_xlsx(
    results = list(plotinfo = plotinfo),
    output_dir = path_to_datarequest_teamdrive
  )

save_results_xlsx(
    results = dendro_plotinfo,
    output_dir = path_to_datarequest_teamdrive
  )

```



# Copy html to teamdrive

Na knitting - manueel

```{r eval = FALSE}
# Specify the path of the file you want to copy
source_file <- here::here("Scripts/Individuele_BRen/Wijnendale_dendro_2024.html")

# Specify the destination directory where you want to copy the file
destination_dir <- path_to_html_teamdrive

# Copy the file to the destination directory
file.copy(from = source_file, to = destination_dir, overwrite = TRUE)
# ? file.copy
```

